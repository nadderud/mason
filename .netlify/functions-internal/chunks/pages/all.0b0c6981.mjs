import require$$0$4 from 'os';
import 'fs';
import 'url';
import 'path';
import { c as createAstro, a as createComponent, r as renderTemplate, b as renderComponent, u as unescapeHTML, F as Fragment, d as renderSlot, e as renderHead, m as maybeRenderHead, f as commonjsGlobal, g as getAugmentedNamespace, s as spreadAttributes, h as addAttribute, i as createVNode } from '../astro.53bb2d17.mjs';
/* empty css                           */import axios from 'axios';
/* empty css                              *//* empty css                                                         */
const defaults$1 = {
  templateTitle: "",
  noindex: false,
  nofollow: false,
  defaultOpenGraphImageWidth: 0,
  defaultOpenGraphImageHeight: 0,
  defaultOpenGraphVideoWidth: 0,
  defaultOpenGraphVideoHeight: 0
};
const buildOpenGraphMediaTags = (mediaType, media = [], {
  defaultWidth,
  defaultHeight
} = {}) => {
  return media.reduce((tags, medium, index) => {
    tags.push(`<meta property="og:${mediaType}" content="${medium.url}" />`);
    if (medium.alt) {
      tags.push(`<meta property="og:${mediaType}:alt" content="${medium.alt}" />`);
    }
    if (medium.secureUrl) {
      tags.push(`<meta property="og:${mediaType}:secure_url" content="${medium.secureUrl.toString()}" />`);
    }
    if (medium.type) {
      tags.push(`<meta property="og:${mediaType}:type" content="${medium.type.toString()}" />`);
    }
    if (medium.width) {
      tags.push(`<meta property="og:${mediaType}:width" content="${medium.width.toString()}" />`);
    } else if (defaultWidth) {
      tags.push(`<meta property="og:${mediaType}:width" content="${defaultWidth.toString()}" />`);
    }
    if (medium.height) {
      tags.push(`<meta property="og:${mediaType}:height" content="${medium.height.toString()}" />`);
    } else if (defaultHeight) {
      tags.push(`<meta property="og:${mediaType}:height" content="${defaultHeight.toString()}" />`);
    }
    return tags;
  }, []);
};
const buildTags = (config) => {
  const tagsToRender = [];
  if (config.titleTemplate) {
    defaults$1.templateTitle = config.titleTemplate;
  }
  let updatedTitle = "";
  if (config.title) {
    updatedTitle = config.title;
    if (defaults$1.templateTitle) {
      updatedTitle = defaults$1.templateTitle.replace(/%s/g, () => updatedTitle);
    }
  } else if (config.defaultTitle) {
    updatedTitle = config.defaultTitle;
  }
  if (updatedTitle) {
    tagsToRender.push(`<title>${updatedTitle}</title>`);
  }
  const noindex = config.noindex || defaults$1.noindex || config.dangerouslySetAllPagesToNoIndex;
  const nofollow = config.nofollow || defaults$1.nofollow || config.dangerouslySetAllPagesToNoFollow;
  let robotsParams = "";
  if (config.robotsProps) {
    const {
      nosnippet,
      maxSnippet,
      maxImagePreview,
      maxVideoPreview,
      noarchive,
      noimageindex,
      notranslate,
      unavailableAfter
    } = config.robotsProps;
    robotsParams = `${nosnippet ? ",nosnippet" : ""}${maxSnippet ? `,max-snippet:${maxSnippet}` : ""}${maxImagePreview ? `,max-image-preview:${maxImagePreview}` : ""}${noarchive ? ",noarchive" : ""}${unavailableAfter ? `,unavailable_after:${unavailableAfter}` : ""}${noimageindex ? ",noimageindex" : ""}${maxVideoPreview ? `,max-video-preview:${maxVideoPreview}` : ""}${notranslate ? ",notranslate" : ""}`;
  }
  if (noindex || nofollow) {
    if (config.dangerouslySetAllPagesToNoIndex) {
      defaults$1.noindex = true;
    }
    if (config.dangerouslySetAllPagesToNoFollow) {
      defaults$1.nofollow = true;
    }
    tagsToRender.push(
      `<meta name="robots" content="${noindex ? "noindex" : "index"},${nofollow ? "nofollow" : "follow"}${robotsParams}" />`
    );
  } else {
    tagsToRender.push(`<meta name="robots" content="index,follow${robotsParams}" />`);
  }
  if (config.description) {
    tagsToRender.push(`<meta name="description" content="${config.description}" />`);
  }
  if (config.mobileAlternate) {
    tagsToRender.push(
      `<link rel="alternate" media="${config.mobileAlternate.media}" href="${config.mobileAlternate.href}" />`
    );
  }
  if (config.languageAlternates && config.languageAlternates.length > 0) {
    config.languageAlternates.forEach((languageAlternate) => {
      tagsToRender.push(
        `<link rel="alternate" hrefLang="${languageAlternate.hrefLang}" href="${languageAlternate.href}" />`
      );
    });
  }
  if (config.twitter) {
    if (config.twitter.cardType) {
      tagsToRender.push(`<meta name="twitter:card" content="${config.twitter.cardType}" />`);
    }
    if (config.twitter.site) {
      tagsToRender.push(`<meta name="twitter:site" content="${config.twitter.site}" />`);
    }
    if (config.twitter.handle) {
      tagsToRender.push(`<meta name="twitter:creator" content="${config.twitter.handle}" />`);
    }
  }
  if (config.facebook) {
    if (config.facebook.appId) {
      tagsToRender.push(`<meta property="fb:app_id" content="${config.facebook.appId}" />`);
    }
  }
  if (config.openGraph?.title || updatedTitle) {
    tagsToRender.push(`<meta property="og:title" content="${config.openGraph?.title || updatedTitle}" />`);
  }
  if (config.openGraph?.description || config.description) {
    tagsToRender.push(
      `<meta property="og:description" content="${config.openGraph?.description || config.description}" />`
    );
  }
  if (config.openGraph) {
    if (config.openGraph.url || config.canonical) {
      tagsToRender.push(`<meta property="og:url" content="${config.openGraph.url || config.canonical}" />`);
    }
    if (config.openGraph.type) {
      const type = config.openGraph.type.toLowerCase();
      tagsToRender.push(`<meta property="og:type" content="${type}" />`);
      if (type === "profile" && config.openGraph.profile) {
        if (config.openGraph.profile.firstName) {
          tagsToRender.push(`<meta property="profile:first_name" content="${config.openGraph.profile.firstName}" />`);
        }
        if (config.openGraph.profile.lastName) {
          tagsToRender.push(`<meta property="profile:last_name" content="${config.openGraph.profile.lastName}" />`);
        }
        if (config.openGraph.profile.username) {
          tagsToRender.push(`<meta property="profile:username" content="${config.openGraph.profile.username}" />`);
        }
        if (config.openGraph.profile.gender) {
          tagsToRender.push(`<meta property="profile:gender" content="${config.openGraph.profile.gender}" />`);
        }
      } else if (type === "book" && config.openGraph.book) {
        if (config.openGraph.book.authors && config.openGraph.book.authors.length) {
          config.openGraph.book.authors.forEach((author, index) => {
            tagsToRender.push(`<meta property="book:author" content="${author}" />`);
          });
        }
        if (config.openGraph.book.isbn) {
          tagsToRender.push(`<meta property="book:isbn" content="${config.openGraph.book.isbn}" />`);
        }
        if (config.openGraph.book.releaseDate) {
          tagsToRender.push(`<meta property="book:release_date" content="${config.openGraph.book.releaseDate}" />`);
        }
        if (config.openGraph.book.tags && config.openGraph.book.tags.length) {
          config.openGraph.book.tags.forEach((tag, index) => {
            tagsToRender.push(`<meta property="book:tag" content="${tag}" />`);
          });
        }
      } else if (type === "article" && config.openGraph.article) {
        if (config.openGraph.article.publishedTime) {
          tagsToRender.push(
            `<meta property="article:published_time" content="${config.openGraph.article.publishedTime}" />`
          );
        }
        if (config.openGraph.article.modifiedTime) {
          tagsToRender.push(
            `<meta property="article:modified_time" content="${config.openGraph.article.modifiedTime}" />`
          );
        }
        if (config.openGraph.article.expirationTime) {
          tagsToRender.push(
            `<meta property="article:expiration_time" content="${config.openGraph.article.expirationTime}" />`
          );
        }
        if (config.openGraph.article.authors && config.openGraph.article.authors.length) {
          config.openGraph.article.authors.forEach((author, index) => {
            tagsToRender.push(`<meta property="article:author" content="${author}" />`);
          });
        }
        if (config.openGraph.article.section) {
          tagsToRender.push(`<meta property="article:section" content="${config.openGraph.article.section}" />`);
        }
        if (config.openGraph.article.tags && config.openGraph.article.tags.length) {
          config.openGraph.article.tags.forEach((tag, index) => {
            tagsToRender.push(`<meta property="article:tag" content="${tag}" />`);
          });
        }
      } else if ((type === "video.movie" || type === "video.episode" || type === "video.tv_show" || type === "video.other") && config.openGraph.video) {
        if (config.openGraph.video.actors && config.openGraph.video.actors.length) {
          config.openGraph.video.actors.forEach((actor, index) => {
            if (actor.profile) {
              tagsToRender.push(`<meta property="video:actor" content="${actor.profile}" />`);
            }
            if (actor.role) {
              tagsToRender.push(`<meta property="video:actor:role" content="${actor.role}" />`);
            }
          });
        }
        if (config.openGraph.video.directors && config.openGraph.video.directors.length) {
          config.openGraph.video.directors.forEach((director, index) => {
            tagsToRender.push(`<meta property="video:director" content="${director}" />`);
          });
        }
        if (config.openGraph.video.writers && config.openGraph.video.writers.length) {
          config.openGraph.video.writers.forEach((writer, index) => {
            tagsToRender.push(`<meta property="video:writer" content="${writer}" />`);
          });
        }
        if (config.openGraph.video.duration) {
          tagsToRender.push(
            `<meta property="video:duration" content="${config.openGraph.video.duration.toString()}" />`
          );
        }
        if (config.openGraph.video.releaseDate) {
          tagsToRender.push(`<meta property="video:release_date" content="${config.openGraph.video.releaseDate}" />`);
        }
        if (config.openGraph.video.tags && config.openGraph.video.tags.length) {
          config.openGraph.video.tags.forEach((tag, index) => {
            tagsToRender.push(`<meta property="video:tag" content="${tag}" />`);
          });
        }
        if (config.openGraph.video.series) {
          tagsToRender.push(`<meta property="video:series" content="${config.openGraph.video.series}" />`);
        }
      }
    }
    if (config.defaultOpenGraphImageWidth) {
      defaults$1.defaultOpenGraphImageWidth = config.defaultOpenGraphImageWidth;
    }
    if (config.defaultOpenGraphImageHeight) {
      defaults$1.defaultOpenGraphImageHeight = config.defaultOpenGraphImageHeight;
    }
    if (config.openGraph.images && config.openGraph.images.length) {
      tagsToRender.push(
        ...buildOpenGraphMediaTags("image", config.openGraph.images, {
          defaultWidth: defaults$1.defaultOpenGraphImageWidth,
          defaultHeight: defaults$1.defaultOpenGraphImageHeight
        })
      );
    }
    if (config.defaultOpenGraphVideoWidth) {
      defaults$1.defaultOpenGraphVideoWidth = config.defaultOpenGraphVideoWidth;
    }
    if (config.defaultOpenGraphVideoHeight) {
      defaults$1.defaultOpenGraphVideoHeight = config.defaultOpenGraphVideoHeight;
    }
    if (config.openGraph.videos && config.openGraph.videos.length) {
      tagsToRender.push(
        ...buildOpenGraphMediaTags("video", config.openGraph.videos, {
          defaultWidth: defaults$1.defaultOpenGraphVideoWidth,
          defaultHeight: defaults$1.defaultOpenGraphVideoHeight
        })
      );
    }
    if (config.openGraph.locale) {
      tagsToRender.push(`<meta property="og:locale" content="${config.openGraph.locale}" />`);
    }
    if (config.openGraph.site_name) {
      tagsToRender.push(`<meta property="og:site_name" content="${config.openGraph.site_name}" />`);
    }
  }
  if (config.canonical) {
    tagsToRender.push(`<link rel="canonical" href="${config.canonical}" />`);
  }
  if (config.additionalMetaTags && config.additionalMetaTags.length > 0) {
    config.additionalMetaTags.forEach((tag) => {
      tagsToRender.push(
        `<meta key="meta:${tag.keyOverride ?? tag.name ?? tag.property ?? tag.httpEquiv}" ${Object.keys(tag).map((key) => `${key}="${tag[key]}"`).join(" ")} />`
      );
    });
  }
  if (config.additionalLinkTags?.length) {
    config.additionalLinkTags.forEach((tag) => {
      tagsToRender.push(
        `<link key="link${tag.keyOverride ?? tag.href}${tag.rel}" ${Object.keys(tag).map((key) => `${key}="${tag[key]}"`).join(" ")} />`
      );
    });
  }
  return tagsToRender ? tagsToRender.join("\n") : "";
};

const $$Astro$r = createAstro("https://nadderud.no");
const $$AstroSeo = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$r, $$props, $$slots);
  Astro2.self = $$AstroSeo;
  const {
    title,
    noindex = false,
    nofollow,
    robotsProps,
    description,
    canonical,
    openGraph,
    facebook,
    twitter,
    additionalMetaTags,
    titleTemplate,
    defaultTitle,
    mobileAlternate,
    languageAlternates,
    additionalLinkTags
  } = Astro2.props;
  return renderTemplate`${renderComponent($$result, "Fragment", Fragment, {}, { "default": ($$result2) => renderTemplate`${unescapeHTML(buildTags({
    title,
    noindex,
    nofollow,
    robotsProps,
    description,
    canonical,
    facebook,
    openGraph,
    additionalMetaTags,
    twitter,
    titleTemplate,
    defaultTitle,
    mobileAlternate,
    languageAlternates,
    additionalLinkTags
  }))}` })}`;
}, "/home/martin/Documents/GitHub/mason/node_modules/.pnpm/@astrolib+seo@0.3.0_astro@2.1.8/node_modules/@astrolib/seo/src/AstroSeo.astro");

const defaultImage = "/_astro/img_20210703_081612_706.3210ab54.jpg";

const CONFIG = {
  name: "Nadderud Spidergruppe",
  origin: "https://nadderud.no",
  basePathname: "/",
  title: "Nadderud Spidergruppe",
  description: "Spennende friluftsliv for barn og ungdom fra 3. klasse og oppover. Vi er en aktiv speidergruppe med ca. 100 medlemmer som dekker omrÃ¥det Nadderud, Bekkestua, Hosle, Eikeli og Haslum.",
  defaultImage,
  defaultTheme: "light",
  // Values: "system" | "light" | "dark" | "light:only" | "dark:only"
  language: "no",
  textDirection: "ltr",
  dateFormatter: new Intl.DateTimeFormat("no", {
    year: "numeric",
    month: "short",
    day: "numeric",
    timeZone: "UTC"
  }),
  blog: {
    disabled: false,
    postsPerPage: 4,
    post: {
      permalink: "/%slug%",
      // Variables: %slug%, %year%, %month%, %day%, %hour%, %minute%, %second%, %category%
      noindex: false,
      disabled: false
    },
    list: {
      pathname: "blog",
      // Blog main path, you can change this to "articles" (/articles)
      noindex: false,
      disabled: false
    },
    category: {
      pathname: "category",
      // Category main path /category/some-category
      noindex: true,
      disabled: false
    },
    tag: {
      pathname: "tag",
      // Tag main path /tag/some-tag
      noindex: true,
      disabled: false
    }
  }
};
const SITE = { ...CONFIG, blog: void 0 };

const getCanonical = (path = "") => {
  const url = String(new URL(path, SITE.origin));
  if (path && url.endsWith("/")) {
    return url.slice(0, -1);
  } else if (path && !url.endsWith("/")) {
    return url + "/";
  }
  return url;
};

const $$Astro$q = createAstro("https://nadderud.no");
const $$MetaTags = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$q, $$props, $$slots);
  Astro2.self = $$MetaTags;
  const defaultImage = SITE.defaultImage;
  const {
    title = SITE.name,
    description = SITE.description,
    image: _image = defaultImage,
    canonical = getCanonical(String(Astro2.url.pathname)),
    noindex = false,
    nofollow = false,
    ogTitle = title,
    ogType = "website",
    dontUseTitleTemplate = false
  } = Astro2.props;
  const image = typeof _image === "string" ? new URL(_image, Astro2.site) : _image && typeof _image["src"] !== "undefined" ? (
    //@ts-ignore
    SITE.url + SITE.defaultImagec
  ) : null;
  return renderTemplate`<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

${renderComponent($$result, "AstroSeo", $$AstroSeo, { "title": title, "titleTemplate": dontUseTitleTemplate ? "%s" : `%s \u2014 ${SITE.name}`, "description": description, "canonical": String(canonical), "noindex": noindex, "nofollow": nofollow, "openGraph": {
    url: String(canonical),
    title: ogTitle,
    description,
    type: ogType,
    images: image ? [
      {
        url: image.toString(),
        alt: ogTitle
      }
    ] : void 0,
    site_name: "Nadderud Speidergruppe"
  } })}

<link rel="shortcut icon" href="/favicon.ico">

<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="mask-icon" href="/favicon.ico" color="#8D46E7">

<meta name="google-site-verification" content="fzQckaZUaXqsoHHbSAvXg0MF_0qRcEBusx5mhhQDias">`;
}, "/home/martin/Documents/GitHub/mason/src/components/common/MetaTags.astro");

var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", { value: __freeze$2(raw || cooked.slice()) }));
var _a$2;
const $$Astro$p = createAstro("https://nadderud.no");
const $$BasicScripts = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$p, $$props, $$slots);
  Astro2.self = $$BasicScripts;
  return renderTemplate(_a$2 || (_a$2 = __template$2(["<script>\n  if (window.netlifyIdentity) {\n    window.netlifyIdentity.on('init', (user) => {\n      if (!user) {\n        window.netlifyIdentity.on('login', () => {\n          document.location.href = '/admin/';\n        });\n      }\n    });\n  }\n\n  function attachEvent(selector, event, fn) {\n    const matches =\n      typeof selector === 'string'\n        ? document.querySelectorAll(selector)\n        : selector;\n    if (matches && matches.length) {\n      matches.forEach((elem) => {\n        elem.addEventListener(event, (e) => fn(e, elem), false);\n      });\n    }\n  }\n\n  window.onload = function () {\n    let lastKnownScrollPosition = window.scrollY;\n    let ticking = true;\n\n    attachEvent('[data-aw-toggle-menu]', 'click', function (_, elem) {\n      elem.classList.toggle('expanded');\n      document.body.classList.toggle('overflow-hidden');\n      document.getElementById('header')?.classList.toggle('h-screen');\n      document.querySelector('#mobile-menue')?.classList.toggle('hidden');\n    });\n\n    function appyHeaderStylesOnScroll() {\n      const header = document.getElementById('header');\n      if (\n        lastKnownScrollPosition > 60 &&\n        !header.classList.contains('scroll')\n      ) {\n        document.getElementById('header').classList.add('scroll');\n      } else if (\n        lastKnownScrollPosition <= 60 &&\n        header.classList.contains('scroll')\n      ) {\n        document.getElementById('header').classList.remove('scroll');\n      }\n      ticking = false;\n    }\n    appyHeaderStylesOnScroll();\n\n    attachEvent([document], 'scroll', function () {\n      lastKnownScrollPosition = window.scrollY;\n\n      if (!ticking) {\n        window.requestAnimationFrame(() => {\n          appyHeaderStylesOnScroll();\n        });\n        ticking = true;\n      }\n    });\n  };\n\n  window.onpageshow = function () {\n    document.documentElement.classList.add('motion-safe:scroll-smooth');\n    const elem = document.querySelector('[data-aw-toggle-menu]');\n    if (elem) {\n      elem.classList.remove('expanded');\n    }\n    document.body.classList.remove('overflow-hidden');\n    document.getElementById('header')?.classList.remove('h-screen');\n    document.querySelector('#header nav')?.classList.add('hidden');\n  };\n<\/script>"])));
}, "/home/martin/Documents/GitHub/mason/src/components/common/BasicScripts.astro");

var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", { value: __freeze$1(raw || cooked.slice()) }));
var _a$1;
const $$Astro$o = createAstro("https://nadderud.no");
const $$BaseLayout = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$o, $$props, $$slots);
  Astro2.self = $$BaseLayout;
  const { meta = {} } = Astro2.props;
  return renderTemplate(_a$1 || (_a$1 = __template$1(['<html lang="no" data-theme="emerald" dir="auto" class="2xl:text-[20px]">\n  <head>\n    ', '\n    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"><\/script>\n  ', '</head>\n\n  <body class="min-h-screen flex flex-col">\n    ', "\n    ", "\n    \n  </body>\n</html>"])), renderComponent($$result, "MetaTags", $$MetaTags, { ...meta }), renderHead($$result), renderSlot($$result, $$slots["default"]), renderComponent($$result, "BasicScripts", $$BasicScripts, {}));
}, "/home/martin/Documents/GitHub/mason/src/layouts/BaseLayout.astro");

const $$Astro$n = createAstro("https://nadderud.no");
const $$Logo = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$n, $$props, $$slots);
  Astro2.self = $$Logo;
  return renderTemplate`${maybeRenderHead($$result)}<span class="logo astro-TVRURPNS"><img src="/img/nsf.png" alt="Logo" fetchpriority="high" loading="eager" class="astro-TVRURPNS"> Naddeurd <span class="sm:inline hidden ml-1 astro-TVRURPNS">Speidergruppe</span></span>`;
}, "/home/martin/Documents/GitHub/mason/src/components/Logo.astro");

const SPRITESHEET_NAMESPACE = `astroicon`;

const baseURL = "https://api.astroicon.dev/v1/";
const requests = /* @__PURE__ */ new Map();
const fetchCache = /* @__PURE__ */ new Map();
async function get(pack, name) {
  const url = new URL(`./${pack}/${name}`, baseURL).toString();
  if (requests.has(url)) {
    return await requests.get(url);
  }
  if (fetchCache.has(url)) {
    return fetchCache.get(url);
  }
  let request = async () => {
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(await res.text());
    }
    const contentType = res.headers.get("Content-Type");
    if (!contentType.includes("svg")) {
      throw new Error(`[astro-icon] Unable to load "${name}" because it did not resolve to an SVG!

Recieved the following "Content-Type":
${contentType}`);
    }
    const svg = await res.text();
    fetchCache.set(url, svg);
    requests.delete(url);
    return svg;
  };
  let promise = request();
  requests.set(url, promise);
  return await promise;
}

var svgo = {};

var config$1 = {};

var plugins$1 = {};

var plugins = {};

var xast = {};

var lib$8 = {};

var lib$7 = {};

var stringify$1 = {};

var lib$6 = {};

var lib$5 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
	/** Types of elements found in htmlparser2's DOM */
	var ElementType;
	(function (ElementType) {
	    /** Type for the root element of a document */
	    ElementType["Root"] = "root";
	    /** Type for Text */
	    ElementType["Text"] = "text";
	    /** Type for <? ... ?> */
	    ElementType["Directive"] = "directive";
	    /** Type for <!-- ... --> */
	    ElementType["Comment"] = "comment";
	    /** Type for <script> tags */
	    ElementType["Script"] = "script";
	    /** Type for <style> tags */
	    ElementType["Style"] = "style";
	    /** Type for Any tag */
	    ElementType["Tag"] = "tag";
	    /** Type for <![CDATA[ ... ]]> */
	    ElementType["CDATA"] = "cdata";
	    /** Type for <!doctype ...> */
	    ElementType["Doctype"] = "doctype";
	})(ElementType = exports.ElementType || (exports.ElementType = {}));
	/**
	 * Tests whether an element is a tag or not.
	 *
	 * @param elem Element to test
	 */
	function isTag(elem) {
	    return (elem.type === ElementType.Tag ||
	        elem.type === ElementType.Script ||
	        elem.type === ElementType.Style);
	}
	exports.isTag = isTag;
	// Exports for backwards compatibility
	/** Type for the root element of a document */
	exports.Root = ElementType.Root;
	/** Type for Text */
	exports.Text = ElementType.Text;
	/** Type for <? ... ?> */
	exports.Directive = ElementType.Directive;
	/** Type for <!-- ... --> */
	exports.Comment = ElementType.Comment;
	/** Type for <script> tags */
	exports.Script = ElementType.Script;
	/** Type for <style> tags */
	exports.Style = ElementType.Style;
	/** Type for Any tag */
	exports.Tag = ElementType.Tag;
	/** Type for <![CDATA[ ... ]]> */
	exports.CDATA = ElementType.CDATA;
	/** Type for <!doctype ...> */
	exports.Doctype = ElementType.Doctype;
} (lib$5));

var node$1 = {};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
Object.defineProperty(node$1, "__esModule", { value: true });
node$1.cloneNode = node$1.hasChildren = node$1.isDocument = node$1.isDirective = node$1.isComment = node$1.isText = node$1.isCDATA = node$1.isTag = node$1.Element = node$1.Document = node$1.NodeWithChildren = node$1.ProcessingInstruction = node$1.Comment = node$1.Text = node$1.DataNode = node$1.Node = void 0;
var domelementtype_1$1 = lib$5;
var nodeTypes = new Map([
    [domelementtype_1$1.ElementType.Tag, 1],
    [domelementtype_1$1.ElementType.Script, 1],
    [domelementtype_1$1.ElementType.Style, 1],
    [domelementtype_1$1.ElementType.Directive, 1],
    [domelementtype_1$1.ElementType.Text, 3],
    [domelementtype_1$1.ElementType.CDATA, 4],
    [domelementtype_1$1.ElementType.Comment, 8],
    [domelementtype_1$1.ElementType.Root, 9],
]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        /**
         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
         * node {@link type}.
         */
        get: function () {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
node$1.Node = Node;
/**
 * A node that contains some data.
 */
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node));
node$1.DataNode = DataNode;
/**
 * Text within the document.
 */
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text(data) {
        return _super.call(this, domelementtype_1$1.ElementType.Text, data) || this;
    }
    return Text;
}(DataNode));
node$1.Text = Text;
/**
 * Comments within the document.
 */
var Comment$2 = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(data) {
        return _super.call(this, domelementtype_1$1.ElementType.Comment, data) || this;
    }
    return Comment;
}(DataNode));
node$1.Comment = Comment$2;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, domelementtype_1$1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
node$1.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
node$1.NodeWithChildren = NodeWithChildren;
/**
 * The root node of the document.
 */
var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document(children) {
        return _super.call(this, domelementtype_1$1.ElementType.Root, children) || this;
    }
    return Document;
}(NodeWithChildren));
node$1.Document = Document;
/**
 * An element within the DOM.
 */
var Element$1 = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1$1.ElementType.Script
            : name === "style"
                ? domelementtype_1$1.ElementType.Style
                : domelementtype_1$1.ElementType.Tag; }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
node$1.Element = Element$1;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag$1(node) {
    return (0, domelementtype_1$1.isTag)(node);
}
node$1.isTag = isTag$1;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1$1.ElementType.CDATA;
}
node$1.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1$1.ElementType.Text;
}
node$1.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1$1.ElementType.Comment;
}
node$1.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1$1.ElementType.Directive;
}
node$1.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1$1.ElementType.Root;
}
node$1.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
node$1.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment$2(node.data);
    }
    else if (isTag$1(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element$1(node.name, __assign$1({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign$1({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign$1({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1$1.ElementType.CDATA, children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
node$1.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DomHandler = void 0;
	var domelementtype_1 = lib$5;
	var node_1 = node$1;
	__exportStar(node$1, exports);
	var reWhitespace = /\s+/g;
	// Default options
	var defaultOpts = {
	    normalizeWhitespace: false,
	    withStartIndices: false,
	    withEndIndices: false,
	    xmlMode: false,
	};
	var DomHandler = /** @class */ (function () {
	    /**
	     * @param callback Called once parsing has completed.
	     * @param options Settings for the handler.
	     * @param elementCB Callback whenever a tag is closed.
	     */
	    function DomHandler(callback, options, elementCB) {
	        /** The elements of the DOM */
	        this.dom = [];
	        /** The root element for the DOM */
	        this.root = new node_1.Document(this.dom);
	        /** Indicated whether parsing has been completed. */
	        this.done = false;
	        /** Stack of open tags. */
	        this.tagStack = [this.root];
	        /** A data node that is still being written to. */
	        this.lastNode = null;
	        /** Reference to the parser instance. Used for location information. */
	        this.parser = null;
	        // Make it possible to skip arguments, for backwards-compatibility
	        if (typeof options === "function") {
	            elementCB = options;
	            options = defaultOpts;
	        }
	        if (typeof callback === "object") {
	            options = callback;
	            callback = undefined;
	        }
	        this.callback = callback !== null && callback !== void 0 ? callback : null;
	        this.options = options !== null && options !== void 0 ? options : defaultOpts;
	        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
	    }
	    DomHandler.prototype.onparserinit = function (parser) {
	        this.parser = parser;
	    };
	    // Resets the handler back to starting state
	    DomHandler.prototype.onreset = function () {
	        this.dom = [];
	        this.root = new node_1.Document(this.dom);
	        this.done = false;
	        this.tagStack = [this.root];
	        this.lastNode = null;
	        this.parser = null;
	    };
	    // Signals the handler that parsing is done
	    DomHandler.prototype.onend = function () {
	        if (this.done)
	            return;
	        this.done = true;
	        this.parser = null;
	        this.handleCallback(null);
	    };
	    DomHandler.prototype.onerror = function (error) {
	        this.handleCallback(error);
	    };
	    DomHandler.prototype.onclosetag = function () {
	        this.lastNode = null;
	        var elem = this.tagStack.pop();
	        if (this.options.withEndIndices) {
	            elem.endIndex = this.parser.endIndex;
	        }
	        if (this.elementCB)
	            this.elementCB(elem);
	    };
	    DomHandler.prototype.onopentag = function (name, attribs) {
	        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
	        var element = new node_1.Element(name, attribs, undefined, type);
	        this.addNode(element);
	        this.tagStack.push(element);
	    };
	    DomHandler.prototype.ontext = function (data) {
	        var normalizeWhitespace = this.options.normalizeWhitespace;
	        var lastNode = this.lastNode;
	        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
	            if (normalizeWhitespace) {
	                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
	            }
	            else {
	                lastNode.data += data;
	            }
	            if (this.options.withEndIndices) {
	                lastNode.endIndex = this.parser.endIndex;
	            }
	        }
	        else {
	            if (normalizeWhitespace) {
	                data = data.replace(reWhitespace, " ");
	            }
	            var node = new node_1.Text(data);
	            this.addNode(node);
	            this.lastNode = node;
	        }
	    };
	    DomHandler.prototype.oncomment = function (data) {
	        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
	            this.lastNode.data += data;
	            return;
	        }
	        var node = new node_1.Comment(data);
	        this.addNode(node);
	        this.lastNode = node;
	    };
	    DomHandler.prototype.oncommentend = function () {
	        this.lastNode = null;
	    };
	    DomHandler.prototype.oncdatastart = function () {
	        var text = new node_1.Text("");
	        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
	        this.addNode(node);
	        text.parent = node;
	        this.lastNode = text;
	    };
	    DomHandler.prototype.oncdataend = function () {
	        this.lastNode = null;
	    };
	    DomHandler.prototype.onprocessinginstruction = function (name, data) {
	        var node = new node_1.ProcessingInstruction(name, data);
	        this.addNode(node);
	    };
	    DomHandler.prototype.handleCallback = function (error) {
	        if (typeof this.callback === "function") {
	            this.callback(error, this.dom);
	        }
	        else if (error) {
	            throw error;
	        }
	    };
	    DomHandler.prototype.addNode = function (node) {
	        var parent = this.tagStack[this.tagStack.length - 1];
	        var previousSibling = parent.children[parent.children.length - 1];
	        if (this.options.withStartIndices) {
	            node.startIndex = this.parser.startIndex;
	        }
	        if (this.options.withEndIndices) {
	            node.endIndex = this.parser.endIndex;
	        }
	        parent.children.push(node);
	        if (previousSibling) {
	            node.prev = previousSibling;
	            previousSibling.next = node;
	        }
	        node.parent = parent;
	        this.lastNode = null;
	    };
	    return DomHandler;
	}());
	exports.DomHandler = DomHandler;
	exports.default = DomHandler;
} (lib$6));

var lib$4 = {};

var lib$3 = {};

var decode = {};

const Aacute$1 = "Ã";
const aacute$1 = "Ã¡";
const Abreve = "Ä‚";
const abreve = "Äƒ";
const ac = "âˆ¾";
const acd = "âˆ¿";
const acE = "âˆ¾Ì³";
const Acirc$1 = "Ã‚";
const acirc$1 = "Ã¢";
const acute$1 = "Â´";
const Acy = "Ð";
const acy = "Ð°";
const AElig$1 = "Ã†";
const aelig$1 = "Ã¦";
const af = "â¡";
const Afr = "ð”„";
const afr = "ð”ž";
const Agrave$1 = "Ã€";
const agrave$1 = "Ã ";
const alefsym = "â„µ";
const aleph = "â„µ";
const Alpha = "Î‘";
const alpha = "Î±";
const Amacr = "Ä€";
const amacr = "Ä";
const amalg = "â¨¿";
const amp$2 = "&";
const AMP$1 = "&";
const andand = "â©•";
const And = "â©“";
const and = "âˆ§";
const andd = "â©œ";
const andslope = "â©˜";
const andv = "â©š";
const ang = "âˆ ";
const ange = "â¦¤";
const angle = "âˆ ";
const angmsdaa = "â¦¨";
const angmsdab = "â¦©";
const angmsdac = "â¦ª";
const angmsdad = "â¦«";
const angmsdae = "â¦¬";
const angmsdaf = "â¦­";
const angmsdag = "â¦®";
const angmsdah = "â¦¯";
const angmsd = "âˆ¡";
const angrt = "âˆŸ";
const angrtvb = "âŠ¾";
const angrtvbd = "â¦";
const angsph = "âˆ¢";
const angst = "Ã…";
const angzarr = "â¼";
const Aogon = "Ä„";
const aogon = "Ä…";
const Aopf = "ð”¸";
const aopf = "ð•’";
const apacir = "â©¯";
const ap = "â‰ˆ";
const apE = "â©°";
const ape = "â‰Š";
const apid = "â‰‹";
const apos$1 = "'";
const ApplyFunction = "â¡";
const approx = "â‰ˆ";
const approxeq = "â‰Š";
const Aring$1 = "Ã…";
const aring$1 = "Ã¥";
const Ascr = "ð’œ";
const ascr = "ð’¶";
const Assign = "â‰”";
const ast = "*";
const asymp = "â‰ˆ";
const asympeq = "â‰";
const Atilde$1 = "Ãƒ";
const atilde$1 = "Ã£";
const Auml$1 = "Ã„";
const auml$1 = "Ã¤";
const awconint = "âˆ³";
const awint = "â¨‘";
const backcong = "â‰Œ";
const backepsilon = "Ï¶";
const backprime = "â€µ";
const backsim = "âˆ½";
const backsimeq = "â‹";
const Backslash = "âˆ–";
const Barv = "â«§";
const barvee = "âŠ½";
const barwed = "âŒ…";
const Barwed = "âŒ†";
const barwedge = "âŒ…";
const bbrk = "âŽµ";
const bbrktbrk = "âŽ¶";
const bcong = "â‰Œ";
const Bcy = "Ð‘";
const bcy = "Ð±";
const bdquo = "â€ž";
const becaus = "âˆµ";
const because = "âˆµ";
const Because = "âˆµ";
const bemptyv = "â¦°";
const bepsi = "Ï¶";
const bernou = "â„¬";
const Bernoullis = "â„¬";
const Beta = "Î’";
const beta = "Î²";
const beth = "â„¶";
const between = "â‰¬";
const Bfr = "ð”…";
const bfr = "ð”Ÿ";
const bigcap = "â‹‚";
const bigcirc = "â—¯";
const bigcup = "â‹ƒ";
const bigodot = "â¨€";
const bigoplus = "â¨";
const bigotimes = "â¨‚";
const bigsqcup = "â¨†";
const bigstar = "â˜…";
const bigtriangledown = "â–½";
const bigtriangleup = "â–³";
const biguplus = "â¨„";
const bigvee = "â‹";
const bigwedge = "â‹€";
const bkarow = "â¤";
const blacklozenge = "â§«";
const blacksquare = "â–ª";
const blacktriangle = "â–´";
const blacktriangledown = "â–¾";
const blacktriangleleft = "â—‚";
const blacktriangleright = "â–¸";
const blank = "â£";
const blk12 = "â–’";
const blk14 = "â–‘";
const blk34 = "â–“";
const block = "â–ˆ";
const bne = "=âƒ¥";
const bnequiv = "â‰¡âƒ¥";
const bNot = "â«­";
const bnot = "âŒ";
const Bopf = "ð”¹";
const bopf = "ð•“";
const bot = "âŠ¥";
const bottom$1 = "âŠ¥";
const bowtie = "â‹ˆ";
const boxbox = "â§‰";
const boxdl = "â”";
const boxdL = "â••";
const boxDl = "â•–";
const boxDL = "â•—";
const boxdr = "â”Œ";
const boxdR = "â•’";
const boxDr = "â•“";
const boxDR = "â•”";
const boxh = "â”€";
const boxH = "â•";
const boxhd = "â”¬";
const boxHd = "â•¤";
const boxhD = "â•¥";
const boxHD = "â•¦";
const boxhu = "â”´";
const boxHu = "â•§";
const boxhU = "â•¨";
const boxHU = "â•©";
const boxminus = "âŠŸ";
const boxplus = "âŠž";
const boxtimes = "âŠ ";
const boxul = "â”˜";
const boxuL = "â•›";
const boxUl = "â•œ";
const boxUL = "â•";
const boxur = "â””";
const boxuR = "â•˜";
const boxUr = "â•™";
const boxUR = "â•š";
const boxv = "â”‚";
const boxV = "â•‘";
const boxvh = "â”¼";
const boxvH = "â•ª";
const boxVh = "â•«";
const boxVH = "â•¬";
const boxvl = "â”¤";
const boxvL = "â•¡";
const boxVl = "â•¢";
const boxVL = "â•£";
const boxvr = "â”œ";
const boxvR = "â•ž";
const boxVr = "â•Ÿ";
const boxVR = "â• ";
const bprime = "â€µ";
const breve = "Ë˜";
const Breve = "Ë˜";
const brvbar$1 = "Â¦";
const bscr = "ð’·";
const Bscr = "â„¬";
const bsemi = "â";
const bsim = "âˆ½";
const bsime = "â‹";
const bsolb = "â§…";
const bsol = "\\";
const bsolhsub = "âŸˆ";
const bull = "â€¢";
const bullet = "â€¢";
const bump = "â‰Ž";
const bumpE = "âª®";
const bumpe = "â‰";
const Bumpeq = "â‰Ž";
const bumpeq = "â‰";
const Cacute = "Ä†";
const cacute = "Ä‡";
const capand = "â©„";
const capbrcup = "â©‰";
const capcap = "â©‹";
const cap = "âˆ©";
const Cap = "â‹’";
const capcup = "â©‡";
const capdot = "â©€";
const CapitalDifferentialD = "â……";
const caps = "âˆ©ï¸€";
const caret = "â";
const caron = "Ë‡";
const Cayleys = "â„­";
const ccaps = "â©";
const Ccaron = "ÄŒ";
const ccaron = "Ä";
const Ccedil$1 = "Ã‡";
const ccedil$1 = "Ã§";
const Ccirc = "Äˆ";
const ccirc = "Ä‰";
const Cconint = "âˆ°";
const ccups = "â©Œ";
const ccupssm = "â©";
const Cdot = "ÄŠ";
const cdot = "Ä‹";
const cedil$1 = "Â¸";
const Cedilla = "Â¸";
const cemptyv = "â¦²";
const cent$1 = "Â¢";
const centerdot = "Â·";
const CenterDot = "Â·";
const cfr = "ð” ";
const Cfr = "â„­";
const CHcy = "Ð§";
const chcy = "Ñ‡";
const check = "âœ“";
const checkmark = "âœ“";
const Chi = "Î§";
const chi = "Ï‡";
const circ = "Ë†";
const circeq = "â‰—";
const circlearrowleft = "â†º";
const circlearrowright = "â†»";
const circledast = "âŠ›";
const circledcirc = "âŠš";
const circleddash = "âŠ";
const CircleDot = "âŠ™";
const circledR = "Â®";
const circledS = "â“ˆ";
const CircleMinus = "âŠ–";
const CirclePlus = "âŠ•";
const CircleTimes = "âŠ—";
const cir = "â—‹";
const cirE = "â§ƒ";
const cire = "â‰—";
const cirfnint = "â¨";
const cirmid = "â«¯";
const cirscir = "â§‚";
const ClockwiseContourIntegral = "âˆ²";
const CloseCurlyDoubleQuote = "â€";
const CloseCurlyQuote = "â€™";
const clubs = "â™£";
const clubsuit = "â™£";
const colon = ":";
const Colon = "âˆ·";
const Colone = "â©´";
const colone = "â‰”";
const coloneq = "â‰”";
const comma = ",";
const commat = "@";
const comp = "âˆ";
const compfn = "âˆ˜";
const complement = "âˆ";
const complexes = "â„‚";
const cong = "â‰…";
const congdot = "â©­";
const Congruent = "â‰¡";
const conint = "âˆ®";
const Conint = "âˆ¯";
const ContourIntegral = "âˆ®";
const copf = "ð•”";
const Copf = "â„‚";
const coprod = "âˆ";
const Coproduct = "âˆ";
const copy$3 = "Â©";
const COPY$1 = "Â©";
const copysr = "â„—";
const CounterClockwiseContourIntegral = "âˆ³";
const crarr = "â†µ";
const cross$1 = "âœ—";
const Cross = "â¨¯";
const Cscr = "ð’ž";
const cscr = "ð’¸";
const csub = "â«";
const csube = "â«‘";
const csup = "â«";
const csupe = "â«’";
const ctdot = "â‹¯";
const cudarrl = "â¤¸";
const cudarrr = "â¤µ";
const cuepr = "â‹ž";
const cuesc = "â‹Ÿ";
const cularr = "â†¶";
const cularrp = "â¤½";
const cupbrcap = "â©ˆ";
const cupcap = "â©†";
const CupCap = "â‰";
const cup = "âˆª";
const Cup = "â‹“";
const cupcup = "â©Š";
const cupdot = "âŠ";
const cupor = "â©…";
const cups = "âˆªï¸€";
const curarr = "â†·";
const curarrm = "â¤¼";
const curlyeqprec = "â‹ž";
const curlyeqsucc = "â‹Ÿ";
const curlyvee = "â‹Ž";
const curlywedge = "â‹";
const curren$1 = "Â¤";
const curvearrowleft = "â†¶";
const curvearrowright = "â†·";
const cuvee = "â‹Ž";
const cuwed = "â‹";
const cwconint = "âˆ²";
const cwint = "âˆ±";
const cylcty = "âŒ­";
const dagger = "â€ ";
const Dagger = "â€¡";
const daleth = "â„¸";
const darr = "â†“";
const Darr = "â†¡";
const dArr = "â‡“";
const dash = "â€";
const Dashv = "â«¤";
const dashv = "âŠ£";
const dbkarow = "â¤";
const dblac = "Ë";
const Dcaron = "ÄŽ";
const dcaron = "Ä";
const Dcy = "Ð”";
const dcy = "Ð´";
const ddagger = "â€¡";
const ddarr = "â‡Š";
const DD = "â……";
const dd = "â…†";
const DDotrahd = "â¤‘";
const ddotseq = "â©·";
const deg$1 = "Â°";
const Del = "âˆ‡";
const Delta = "Î”";
const delta = "Î´";
const demptyv = "â¦±";
const dfisht = "â¥¿";
const Dfr = "ð”‡";
const dfr = "ð”¡";
const dHar = "â¥¥";
const dharl = "â‡ƒ";
const dharr = "â‡‚";
const DiacriticalAcute = "Â´";
const DiacriticalDot = "Ë™";
const DiacriticalDoubleAcute = "Ë";
const DiacriticalGrave = "`";
const DiacriticalTilde = "Ëœ";
const diam = "â‹„";
const diamond = "â‹„";
const Diamond = "â‹„";
const diamondsuit = "â™¦";
const diams = "â™¦";
const die = "Â¨";
const DifferentialD = "â…†";
const digamma = "Ï";
const disin = "â‹²";
const div = "Ã·";
const divide$1 = "Ã·";
const divideontimes = "â‹‡";
const divonx = "â‹‡";
const DJcy = "Ð‚";
const djcy = "Ñ’";
const dlcorn = "âŒž";
const dlcrop = "âŒ";
const dollar = "$";
const Dopf = "ð”»";
const dopf = "ð••";
const Dot = "Â¨";
const dot$1 = "Ë™";
const DotDot = "âƒœ";
const doteq = "â‰";
const doteqdot = "â‰‘";
const DotEqual = "â‰";
const dotminus = "âˆ¸";
const dotplus = "âˆ”";
const dotsquare = "âŠ¡";
const doublebarwedge = "âŒ†";
const DoubleContourIntegral = "âˆ¯";
const DoubleDot = "Â¨";
const DoubleDownArrow = "â‡“";
const DoubleLeftArrow = "â‡";
const DoubleLeftRightArrow = "â‡”";
const DoubleLeftTee = "â«¤";
const DoubleLongLeftArrow = "âŸ¸";
const DoubleLongLeftRightArrow = "âŸº";
const DoubleLongRightArrow = "âŸ¹";
const DoubleRightArrow = "â‡’";
const DoubleRightTee = "âŠ¨";
const DoubleUpArrow = "â‡‘";
const DoubleUpDownArrow = "â‡•";
const DoubleVerticalBar = "âˆ¥";
const DownArrowBar = "â¤“";
const downarrow = "â†“";
const DownArrow = "â†“";
const Downarrow = "â‡“";
const DownArrowUpArrow = "â‡µ";
const DownBreve = "Ì‘";
const downdownarrows = "â‡Š";
const downharpoonleft = "â‡ƒ";
const downharpoonright = "â‡‚";
const DownLeftRightVector = "â¥";
const DownLeftTeeVector = "â¥ž";
const DownLeftVectorBar = "â¥–";
const DownLeftVector = "â†½";
const DownRightTeeVector = "â¥Ÿ";
const DownRightVectorBar = "â¥—";
const DownRightVector = "â‡";
const DownTeeArrow = "â†§";
const DownTee = "âŠ¤";
const drbkarow = "â¤";
const drcorn = "âŒŸ";
const drcrop = "âŒŒ";
const Dscr = "ð’Ÿ";
const dscr = "ð’¹";
const DScy = "Ð…";
const dscy = "Ñ•";
const dsol = "â§¶";
const Dstrok = "Ä";
const dstrok = "Ä‘";
const dtdot = "â‹±";
const dtri = "â–¿";
const dtrif = "â–¾";
const duarr = "â‡µ";
const duhar = "â¥¯";
const dwangle = "â¦¦";
const DZcy = "Ð";
const dzcy = "ÑŸ";
const dzigrarr = "âŸ¿";
const Eacute$1 = "Ã‰";
const eacute$1 = "Ã©";
const easter = "â©®";
const Ecaron = "Äš";
const ecaron = "Ä›";
const Ecirc$1 = "ÃŠ";
const ecirc$1 = "Ãª";
const ecir = "â‰–";
const ecolon = "â‰•";
const Ecy = "Ð­";
const ecy = "Ñ";
const eDDot = "â©·";
const Edot = "Ä–";
const edot = "Ä—";
const eDot = "â‰‘";
const ee = "â…‡";
const efDot = "â‰’";
const Efr = "ð”ˆ";
const efr = "ð”¢";
const eg = "âªš";
const Egrave$1 = "Ãˆ";
const egrave$1 = "Ã¨";
const egs = "âª–";
const egsdot = "âª˜";
const el = "âª™";
const Element = "âˆˆ";
const elinters = "â§";
const ell = "â„“";
const els = "âª•";
const elsdot = "âª—";
const Emacr = "Ä’";
const emacr = "Ä“";
const empty = "âˆ…";
const emptyset = "âˆ…";
const EmptySmallSquare = "â—»";
const emptyv = "âˆ…";
const EmptyVerySmallSquare = "â–«";
const emsp13 = "â€„";
const emsp14 = "â€…";
const emsp = "â€ƒ";
const ENG = "ÅŠ";
const eng = "Å‹";
const ensp = "â€‚";
const Eogon = "Ä˜";
const eogon = "Ä™";
const Eopf = "ð”¼";
const eopf = "ð•–";
const epar = "â‹•";
const eparsl = "â§£";
const eplus = "â©±";
const epsi = "Îµ";
const Epsilon = "Î•";
const epsilon = "Îµ";
const epsiv = "Ïµ";
const eqcirc = "â‰–";
const eqcolon = "â‰•";
const eqsim = "â‰‚";
const eqslantgtr = "âª–";
const eqslantless = "âª•";
const Equal = "â©µ";
const equals = "=";
const EqualTilde = "â‰‚";
const equest = "â‰Ÿ";
const Equilibrium = "â‡Œ";
const equiv = "â‰¡";
const equivDD = "â©¸";
const eqvparsl = "â§¥";
const erarr = "â¥±";
const erDot = "â‰“";
const escr = "â„¯";
const Escr = "â„°";
const esdot = "â‰";
const Esim = "â©³";
const esim = "â‰‚";
const Eta = "Î—";
const eta = "Î·";
const ETH$1 = "Ã";
const eth$1 = "Ã°";
const Euml$1 = "Ã‹";
const euml$1 = "Ã«";
const euro = "â‚¬";
const excl = "!";
const exist = "âˆƒ";
const Exists = "âˆƒ";
const expectation = "â„°";
const exponentiale = "â…‡";
const ExponentialE = "â…‡";
const fallingdotseq = "â‰’";
const Fcy = "Ð¤";
const fcy = "Ñ„";
const female = "â™€";
const ffilig = "ï¬ƒ";
const fflig = "ï¬€";
const ffllig = "ï¬„";
const Ffr = "ð”‰";
const ffr = "ð”£";
const filig = "ï¬";
const FilledSmallSquare = "â—¼";
const FilledVerySmallSquare = "â–ª";
const fjlig = "fj";
const flat = "â™­";
const fllig = "ï¬‚";
const fltns = "â–±";
const fnof = "Æ’";
const Fopf = "ð”½";
const fopf = "ð•—";
const forall = "âˆ€";
const ForAll = "âˆ€";
const fork = "â‹”";
const forkv = "â«™";
const Fouriertrf = "â„±";
const fpartint = "â¨";
const frac12$1 = "Â½";
const frac13 = "â…“";
const frac14$1 = "Â¼";
const frac15 = "â…•";
const frac16 = "â…™";
const frac18 = "â…›";
const frac23 = "â…”";
const frac25 = "â…–";
const frac34$1 = "Â¾";
const frac35 = "â…—";
const frac38 = "â…œ";
const frac45 = "â…˜";
const frac56 = "â…š";
const frac58 = "â…";
const frac78 = "â…ž";
const frasl = "â„";
const frown = "âŒ¢";
const fscr = "ð’»";
const Fscr = "â„±";
const gacute = "Çµ";
const Gamma = "Î“";
const gamma = "Î³";
const Gammad = "Ïœ";
const gammad = "Ï";
const gap$1 = "âª†";
const Gbreve = "Äž";
const gbreve = "ÄŸ";
const Gcedil = "Ä¢";
const Gcirc = "Äœ";
const gcirc = "Ä";
const Gcy = "Ð“";
const gcy = "Ð³";
const Gdot = "Ä ";
const gdot = "Ä¡";
const ge = "â‰¥";
const gE = "â‰§";
const gEl = "âªŒ";
const gel = "â‹›";
const geq = "â‰¥";
const geqq = "â‰§";
const geqslant = "â©¾";
const gescc = "âª©";
const ges = "â©¾";
const gesdot = "âª€";
const gesdoto = "âª‚";
const gesdotol = "âª„";
const gesl = "â‹›ï¸€";
const gesles = "âª”";
const Gfr = "ð”Š";
const gfr = "ð”¤";
const gg = "â‰«";
const Gg = "â‹™";
const ggg = "â‹™";
const gimel = "â„·";
const GJcy = "Ðƒ";
const gjcy = "Ñ“";
const gla = "âª¥";
const gl = "â‰·";
const glE = "âª’";
const glj = "âª¤";
const gnap = "âªŠ";
const gnapprox = "âªŠ";
const gne = "âªˆ";
const gnE = "â‰©";
const gneq = "âªˆ";
const gneqq = "â‰©";
const gnsim = "â‹§";
const Gopf = "ð”¾";
const gopf = "ð•˜";
const grave = "`";
const GreaterEqual = "â‰¥";
const GreaterEqualLess = "â‹›";
const GreaterFullEqual = "â‰§";
const GreaterGreater = "âª¢";
const GreaterLess = "â‰·";
const GreaterSlantEqual = "â©¾";
const GreaterTilde = "â‰³";
const Gscr = "ð’¢";
const gscr = "â„Š";
const gsim = "â‰³";
const gsime = "âªŽ";
const gsiml = "âª";
const gtcc = "âª§";
const gtcir = "â©º";
const gt$2 = ">";
const GT$1 = ">";
const Gt = "â‰«";
const gtdot = "â‹—";
const gtlPar = "â¦•";
const gtquest = "â©¼";
const gtrapprox = "âª†";
const gtrarr = "â¥¸";
const gtrdot = "â‹—";
const gtreqless = "â‹›";
const gtreqqless = "âªŒ";
const gtrless = "â‰·";
const gtrsim = "â‰³";
const gvertneqq = "â‰©ï¸€";
const gvnE = "â‰©ï¸€";
const Hacek = "Ë‡";
const hairsp = "â€Š";
const half = "Â½";
const hamilt = "â„‹";
const HARDcy = "Ðª";
const hardcy = "ÑŠ";
const harrcir = "â¥ˆ";
const harr = "â†”";
const hArr = "â‡”";
const harrw = "â†­";
const Hat = "^";
const hbar = "â„";
const Hcirc = "Ä¤";
const hcirc = "Ä¥";
const hearts = "â™¥";
const heartsuit = "â™¥";
const hellip = "â€¦";
const hercon = "âŠ¹";
const hfr = "ð”¥";
const Hfr = "â„Œ";
const HilbertSpace = "â„‹";
const hksearow = "â¤¥";
const hkswarow = "â¤¦";
const hoarr = "â‡¿";
const homtht = "âˆ»";
const hookleftarrow = "â†©";
const hookrightarrow = "â†ª";
const hopf = "ð•™";
const Hopf = "â„";
const horbar = "â€•";
const HorizontalLine = "â”€";
const hscr = "ð’½";
const Hscr = "â„‹";
const hslash = "â„";
const Hstrok = "Ä¦";
const hstrok = "Ä§";
const HumpDownHump = "â‰Ž";
const HumpEqual = "â‰";
const hybull = "âƒ";
const hyphen = "â€";
const Iacute$1 = "Ã";
const iacute$1 = "Ã­";
const ic = "â£";
const Icirc$1 = "ÃŽ";
const icirc$1 = "Ã®";
const Icy = "Ð˜";
const icy = "Ð¸";
const Idot = "Ä°";
const IEcy = "Ð•";
const iecy = "Ðµ";
const iexcl$1 = "Â¡";
const iff = "â‡”";
const ifr = "ð”¦";
const Ifr = "â„‘";
const Igrave$1 = "ÃŒ";
const igrave$1 = "Ã¬";
const ii = "â…ˆ";
const iiiint = "â¨Œ";
const iiint = "âˆ­";
const iinfin = "â§œ";
const iiota = "â„©";
const IJlig = "Ä²";
const ijlig = "Ä³";
const Imacr = "Äª";
const imacr = "Ä«";
const image$1 = "â„‘";
const ImaginaryI = "â…ˆ";
const imagline = "â„";
const imagpart = "â„‘";
const imath = "Ä±";
const Im = "â„‘";
const imof = "âŠ·";
const imped = "Æµ";
const Implies = "â‡’";
const incare = "â„…";
const infin = "âˆž";
const infintie = "â§";
const inodot = "Ä±";
const intcal = "âŠº";
const int = "âˆ«";
const Int = "âˆ¬";
const integers = "â„¤";
const Integral = "âˆ«";
const intercal = "âŠº";
const Intersection = "â‹‚";
const intlarhk = "â¨—";
const intprod = "â¨¼";
const InvisibleComma = "â£";
const InvisibleTimes = "â¢";
const IOcy = "Ð";
const iocy = "Ñ‘";
const Iogon = "Ä®";
const iogon = "Ä¯";
const Iopf = "ð•€";
const iopf = "ð•š";
const Iota = "Î™";
const iota = "Î¹";
const iprod = "â¨¼";
const iquest$1 = "Â¿";
const iscr = "ð’¾";
const Iscr = "â„";
const isin = "âˆˆ";
const isindot = "â‹µ";
const isinE = "â‹¹";
const isins = "â‹´";
const isinsv = "â‹³";
const isinv = "âˆˆ";
const it = "â¢";
const Itilde = "Ä¨";
const itilde = "Ä©";
const Iukcy = "Ð†";
const iukcy = "Ñ–";
const Iuml$1 = "Ã";
const iuml$1 = "Ã¯";
const Jcirc = "Ä´";
const jcirc = "Äµ";
const Jcy = "Ð™";
const jcy = "Ð¹";
const Jfr = "ð”";
const jfr = "ð”§";
const jmath = "È·";
const Jopf = "ð•";
const jopf = "ð•›";
const Jscr = "ð’¥";
const jscr = "ð’¿";
const Jsercy = "Ðˆ";
const jsercy = "Ñ˜";
const Jukcy = "Ð„";
const jukcy = "Ñ”";
const Kappa = "Îš";
const kappa = "Îº";
const kappav = "Ï°";
const Kcedil = "Ä¶";
const kcedil = "Ä·";
const Kcy = "Ðš";
const kcy = "Ðº";
const Kfr = "ð”Ž";
const kfr = "ð”¨";
const kgreen = "Ä¸";
const KHcy = "Ð¥";
const khcy = "Ñ…";
const KJcy = "ÐŒ";
const kjcy = "Ñœ";
const Kopf = "ð•‚";
const kopf = "ð•œ";
const Kscr = "ð’¦";
const kscr = "ð“€";
const lAarr = "â‡š";
const Lacute = "Ä¹";
const lacute = "Äº";
const laemptyv = "â¦´";
const lagran = "â„’";
const Lambda = "Î›";
const lambda = "Î»";
const lang$1 = "âŸ¨";
const Lang = "âŸª";
const langd = "â¦‘";
const langle = "âŸ¨";
const lap = "âª…";
const Laplacetrf = "â„’";
const laquo$1 = "Â«";
const larrb = "â‡¤";
const larrbfs = "â¤Ÿ";
const larr = "â†";
const Larr = "â†ž";
const lArr = "â‡";
const larrfs = "â¤";
const larrhk = "â†©";
const larrlp = "â†«";
const larrpl = "â¤¹";
const larrsim = "â¥³";
const larrtl = "â†¢";
const latail = "â¤™";
const lAtail = "â¤›";
const lat = "âª«";
const late = "âª­";
const lates = "âª­ï¸€";
const lbarr = "â¤Œ";
const lBarr = "â¤Ž";
const lbbrk = "â²";
const lbrace = "{";
const lbrack = "[";
const lbrke = "â¦‹";
const lbrksld = "â¦";
const lbrkslu = "â¦";
const Lcaron = "Ä½";
const lcaron = "Ä¾";
const Lcedil = "Ä»";
const lcedil = "Ä¼";
const lceil = "âŒˆ";
const lcub = "{";
const Lcy = "Ð›";
const lcy = "Ð»";
const ldca = "â¤¶";
const ldquo = "â€œ";
const ldquor = "â€ž";
const ldrdhar = "â¥§";
const ldrushar = "â¥‹";
const ldsh = "â†²";
const le = "â‰¤";
const lE = "â‰¦";
const LeftAngleBracket = "âŸ¨";
const LeftArrowBar = "â‡¤";
const leftarrow = "â†";
const LeftArrow = "â†";
const Leftarrow = "â‡";
const LeftArrowRightArrow = "â‡†";
const leftarrowtail = "â†¢";
const LeftCeiling = "âŒˆ";
const LeftDoubleBracket = "âŸ¦";
const LeftDownTeeVector = "â¥¡";
const LeftDownVectorBar = "â¥™";
const LeftDownVector = "â‡ƒ";
const LeftFloor = "âŒŠ";
const leftharpoondown = "â†½";
const leftharpoonup = "â†¼";
const leftleftarrows = "â‡‡";
const leftrightarrow = "â†”";
const LeftRightArrow = "â†”";
const Leftrightarrow = "â‡”";
const leftrightarrows = "â‡†";
const leftrightharpoons = "â‡‹";
const leftrightsquigarrow = "â†­";
const LeftRightVector = "â¥Ž";
const LeftTeeArrow = "â†¤";
const LeftTee = "âŠ£";
const LeftTeeVector = "â¥š";
const leftthreetimes = "â‹‹";
const LeftTriangleBar = "â§";
const LeftTriangle = "âŠ²";
const LeftTriangleEqual = "âŠ´";
const LeftUpDownVector = "â¥‘";
const LeftUpTeeVector = "â¥ ";
const LeftUpVectorBar = "â¥˜";
const LeftUpVector = "â†¿";
const LeftVectorBar = "â¥’";
const LeftVector = "â†¼";
const lEg = "âª‹";
const leg = "â‹š";
const leq = "â‰¤";
const leqq = "â‰¦";
const leqslant = "â©½";
const lescc = "âª¨";
const les = "â©½";
const lesdot = "â©¿";
const lesdoto = "âª";
const lesdotor = "âªƒ";
const lesg = "â‹šï¸€";
const lesges = "âª“";
const lessapprox = "âª…";
const lessdot = "â‹–";
const lesseqgtr = "â‹š";
const lesseqqgtr = "âª‹";
const LessEqualGreater = "â‹š";
const LessFullEqual = "â‰¦";
const LessGreater = "â‰¶";
const lessgtr = "â‰¶";
const LessLess = "âª¡";
const lesssim = "â‰²";
const LessSlantEqual = "â©½";
const LessTilde = "â‰²";
const lfisht = "â¥¼";
const lfloor = "âŒŠ";
const Lfr = "ð”";
const lfr = "ð”©";
const lg = "â‰¶";
const lgE = "âª‘";
const lHar = "â¥¢";
const lhard = "â†½";
const lharu = "â†¼";
const lharul = "â¥ª";
const lhblk = "â–„";
const LJcy = "Ð‰";
const ljcy = "Ñ™";
const llarr = "â‡‡";
const ll = "â‰ª";
const Ll = "â‹˜";
const llcorner = "âŒž";
const Lleftarrow = "â‡š";
const llhard = "â¥«";
const lltri = "â—º";
const Lmidot = "Ä¿";
const lmidot = "Å€";
const lmoustache = "âŽ°";
const lmoust = "âŽ°";
const lnap = "âª‰";
const lnapprox = "âª‰";
const lne = "âª‡";
const lnE = "â‰¨";
const lneq = "âª‡";
const lneqq = "â‰¨";
const lnsim = "â‹¦";
const loang = "âŸ¬";
const loarr = "â‡½";
const lobrk = "âŸ¦";
const longleftarrow = "âŸµ";
const LongLeftArrow = "âŸµ";
const Longleftarrow = "âŸ¸";
const longleftrightarrow = "âŸ·";
const LongLeftRightArrow = "âŸ·";
const Longleftrightarrow = "âŸº";
const longmapsto = "âŸ¼";
const longrightarrow = "âŸ¶";
const LongRightArrow = "âŸ¶";
const Longrightarrow = "âŸ¹";
const looparrowleft = "â†«";
const looparrowright = "â†¬";
const lopar = "â¦…";
const Lopf = "ð•ƒ";
const lopf = "ð•";
const loplus = "â¨­";
const lotimes = "â¨´";
const lowast = "âˆ—";
const lowbar = "_";
const LowerLeftArrow = "â†™";
const LowerRightArrow = "â†˜";
const loz = "â—Š";
const lozenge = "â—Š";
const lozf = "â§«";
const lpar = "(";
const lparlt = "â¦“";
const lrarr = "â‡†";
const lrcorner = "âŒŸ";
const lrhar = "â‡‹";
const lrhard = "â¥­";
const lrm = "â€Ž";
const lrtri = "âŠ¿";
const lsaquo = "â€¹";
const lscr = "ð“";
const Lscr = "â„’";
const lsh = "â†°";
const Lsh = "â†°";
const lsim = "â‰²";
const lsime = "âª";
const lsimg = "âª";
const lsqb = "[";
const lsquo = "â€˜";
const lsquor = "â€š";
const Lstrok = "Å";
const lstrok = "Å‚";
const ltcc = "âª¦";
const ltcir = "â©¹";
const lt$2 = "<";
const LT$1 = "<";
const Lt = "â‰ª";
const ltdot = "â‹–";
const lthree = "â‹‹";
const ltimes = "â‹‰";
const ltlarr = "â¥¶";
const ltquest = "â©»";
const ltri = "â—ƒ";
const ltrie = "âŠ´";
const ltrif = "â—‚";
const ltrPar = "â¦–";
const lurdshar = "â¥Š";
const luruhar = "â¥¦";
const lvertneqq = "â‰¨ï¸€";
const lvnE = "â‰¨ï¸€";
const macr$1 = "Â¯";
const male = "â™‚";
const malt = "âœ ";
const maltese = "âœ ";
const map = "â†¦";
const mapsto = "â†¦";
const mapstodown = "â†§";
const mapstoleft = "â†¤";
const mapstoup = "â†¥";
const marker = "â–®";
const mcomma = "â¨©";
const Mcy = "Ðœ";
const mcy = "Ð¼";
const mdash = "â€”";
const mDDot = "âˆº";
const measuredangle = "âˆ¡";
const MediumSpace = "âŸ";
const Mellintrf = "â„³";
const Mfr = "ð”";
const mfr = "ð”ª";
const mho = "â„§";
const micro$1 = "Âµ";
const midast = "*";
const midcir = "â«°";
const mid = "âˆ£";
const middot$1 = "Â·";
const minusb = "âŠŸ";
const minus$1 = "âˆ’";
const minusd = "âˆ¸";
const minusdu = "â¨ª";
const MinusPlus = "âˆ“";
const mlcp = "â«›";
const mldr = "â€¦";
const mnplus = "âˆ“";
const models = "âŠ§";
const Mopf = "ð•„";
const mopf = "ð•ž";
const mp = "âˆ“";
const mscr = "ð“‚";
const Mscr = "â„³";
const mstpos = "âˆ¾";
const Mu = "Îœ";
const mu = "Î¼";
const multimap = "âŠ¸";
const mumap = "âŠ¸";
const nabla = "âˆ‡";
const Nacute = "Åƒ";
const nacute = "Å„";
const nang = "âˆ âƒ’";
const nap = "â‰‰";
const napE = "â©°Ì¸";
const napid = "â‰‹Ì¸";
const napos = "Å‰";
const napprox = "â‰‰";
const natural = "â™®";
const naturals = "â„•";
const natur = "â™®";
const nbsp$1 = "Â ";
const nbump = "â‰ŽÌ¸";
const nbumpe = "â‰Ì¸";
const ncap = "â©ƒ";
const Ncaron = "Å‡";
const ncaron = "Åˆ";
const Ncedil = "Å…";
const ncedil = "Å†";
const ncong = "â‰‡";
const ncongdot = "â©­Ì¸";
const ncup = "â©‚";
const Ncy = "Ð";
const ncy = "Ð½";
const ndash = "â€“";
const nearhk = "â¤¤";
const nearr = "â†—";
const neArr = "â‡—";
const nearrow = "â†—";
const ne = "â‰ ";
const nedot = "â‰Ì¸";
const NegativeMediumSpace = "â€‹";
const NegativeThickSpace = "â€‹";
const NegativeThinSpace = "â€‹";
const NegativeVeryThinSpace = "â€‹";
const nequiv = "â‰¢";
const nesear = "â¤¨";
const nesim = "â‰‚Ì¸";
const NestedGreaterGreater = "â‰«";
const NestedLessLess = "â‰ª";
const NewLine = "\n";
const nexist = "âˆ„";
const nexists = "âˆ„";
const Nfr = "ð”‘";
const nfr = "ð”«";
const ngE = "â‰§Ì¸";
const nge = "â‰±";
const ngeq = "â‰±";
const ngeqq = "â‰§Ì¸";
const ngeqslant = "â©¾Ì¸";
const nges = "â©¾Ì¸";
const nGg = "â‹™Ì¸";
const ngsim = "â‰µ";
const nGt = "â‰«âƒ’";
const ngt = "â‰¯";
const ngtr = "â‰¯";
const nGtv = "â‰«Ì¸";
const nharr = "â†®";
const nhArr = "â‡Ž";
const nhpar = "â«²";
const ni = "âˆ‹";
const nis = "â‹¼";
const nisd = "â‹º";
const niv = "âˆ‹";
const NJcy = "ÐŠ";
const njcy = "Ñš";
const nlarr = "â†š";
const nlArr = "â‡";
const nldr = "â€¥";
const nlE = "â‰¦Ì¸";
const nle = "â‰°";
const nleftarrow = "â†š";
const nLeftarrow = "â‡";
const nleftrightarrow = "â†®";
const nLeftrightarrow = "â‡Ž";
const nleq = "â‰°";
const nleqq = "â‰¦Ì¸";
const nleqslant = "â©½Ì¸";
const nles = "â©½Ì¸";
const nless = "â‰®";
const nLl = "â‹˜Ì¸";
const nlsim = "â‰´";
const nLt = "â‰ªâƒ’";
const nlt = "â‰®";
const nltri = "â‹ª";
const nltrie = "â‹¬";
const nLtv = "â‰ªÌ¸";
const nmid = "âˆ¤";
const NoBreak = "â ";
const NonBreakingSpace = "Â ";
const nopf = "ð•Ÿ";
const Nopf = "â„•";
const Not = "â«¬";
const not$2 = "Â¬";
const NotCongruent = "â‰¢";
const NotCupCap = "â‰­";
const NotDoubleVerticalBar = "âˆ¦";
const NotElement = "âˆ‰";
const NotEqual = "â‰ ";
const NotEqualTilde = "â‰‚Ì¸";
const NotExists = "âˆ„";
const NotGreater = "â‰¯";
const NotGreaterEqual = "â‰±";
const NotGreaterFullEqual = "â‰§Ì¸";
const NotGreaterGreater = "â‰«Ì¸";
const NotGreaterLess = "â‰¹";
const NotGreaterSlantEqual = "â©¾Ì¸";
const NotGreaterTilde = "â‰µ";
const NotHumpDownHump = "â‰ŽÌ¸";
const NotHumpEqual = "â‰Ì¸";
const notin = "âˆ‰";
const notindot = "â‹µÌ¸";
const notinE = "â‹¹Ì¸";
const notinva = "âˆ‰";
const notinvb = "â‹·";
const notinvc = "â‹¶";
const NotLeftTriangleBar = "â§Ì¸";
const NotLeftTriangle = "â‹ª";
const NotLeftTriangleEqual = "â‹¬";
const NotLess = "â‰®";
const NotLessEqual = "â‰°";
const NotLessGreater = "â‰¸";
const NotLessLess = "â‰ªÌ¸";
const NotLessSlantEqual = "â©½Ì¸";
const NotLessTilde = "â‰´";
const NotNestedGreaterGreater = "âª¢Ì¸";
const NotNestedLessLess = "âª¡Ì¸";
const notni = "âˆŒ";
const notniva = "âˆŒ";
const notnivb = "â‹¾";
const notnivc = "â‹½";
const NotPrecedes = "âŠ€";
const NotPrecedesEqual = "âª¯Ì¸";
const NotPrecedesSlantEqual = "â‹ ";
const NotReverseElement = "âˆŒ";
const NotRightTriangleBar = "â§Ì¸";
const NotRightTriangle = "â‹«";
const NotRightTriangleEqual = "â‹­";
const NotSquareSubset = "âŠÌ¸";
const NotSquareSubsetEqual = "â‹¢";
const NotSquareSuperset = "âŠÌ¸";
const NotSquareSupersetEqual = "â‹£";
const NotSubset = "âŠ‚âƒ’";
const NotSubsetEqual = "âŠˆ";
const NotSucceeds = "âŠ";
const NotSucceedsEqual = "âª°Ì¸";
const NotSucceedsSlantEqual = "â‹¡";
const NotSucceedsTilde = "â‰¿Ì¸";
const NotSuperset = "âŠƒâƒ’";
const NotSupersetEqual = "âŠ‰";
const NotTilde = "â‰";
const NotTildeEqual = "â‰„";
const NotTildeFullEqual = "â‰‡";
const NotTildeTilde = "â‰‰";
const NotVerticalBar = "âˆ¤";
const nparallel = "âˆ¦";
const npar = "âˆ¦";
const nparsl = "â«½âƒ¥";
const npart = "âˆ‚Ì¸";
const npolint = "â¨”";
const npr = "âŠ€";
const nprcue = "â‹ ";
const nprec = "âŠ€";
const npreceq = "âª¯Ì¸";
const npre = "âª¯Ì¸";
const nrarrc = "â¤³Ì¸";
const nrarr = "â†›";
const nrArr = "â‡";
const nrarrw = "â†Ì¸";
const nrightarrow = "â†›";
const nRightarrow = "â‡";
const nrtri = "â‹«";
const nrtrie = "â‹­";
const nsc = "âŠ";
const nsccue = "â‹¡";
const nsce = "âª°Ì¸";
const Nscr = "ð’©";
const nscr = "ð“ƒ";
const nshortmid = "âˆ¤";
const nshortparallel = "âˆ¦";
const nsim = "â‰";
const nsime = "â‰„";
const nsimeq = "â‰„";
const nsmid = "âˆ¤";
const nspar = "âˆ¦";
const nsqsube = "â‹¢";
const nsqsupe = "â‹£";
const nsub = "âŠ„";
const nsubE = "â«…Ì¸";
const nsube = "âŠˆ";
const nsubset = "âŠ‚âƒ’";
const nsubseteq = "âŠˆ";
const nsubseteqq = "â«…Ì¸";
const nsucc = "âŠ";
const nsucceq = "âª°Ì¸";
const nsup = "âŠ…";
const nsupE = "â«†Ì¸";
const nsupe = "âŠ‰";
const nsupset = "âŠƒâƒ’";
const nsupseteq = "âŠ‰";
const nsupseteqq = "â«†Ì¸";
const ntgl = "â‰¹";
const Ntilde$1 = "Ã‘";
const ntilde$1 = "Ã±";
const ntlg = "â‰¸";
const ntriangleleft = "â‹ª";
const ntrianglelefteq = "â‹¬";
const ntriangleright = "â‹«";
const ntrianglerighteq = "â‹­";
const Nu = "Î";
const nu = "Î½";
const num = "#";
const numero = "â„–";
const numsp = "â€‡";
const nvap = "â‰âƒ’";
const nvdash = "âŠ¬";
const nvDash = "âŠ­";
const nVdash = "âŠ®";
const nVDash = "âŠ¯";
const nvge = "â‰¥âƒ’";
const nvgt = ">âƒ’";
const nvHarr = "â¤„";
const nvinfin = "â§ž";
const nvlArr = "â¤‚";
const nvle = "â‰¤âƒ’";
const nvlt = "<âƒ’";
const nvltrie = "âŠ´âƒ’";
const nvrArr = "â¤ƒ";
const nvrtrie = "âŠµâƒ’";
const nvsim = "âˆ¼âƒ’";
const nwarhk = "â¤£";
const nwarr = "â†–";
const nwArr = "â‡–";
const nwarrow = "â†–";
const nwnear = "â¤§";
const Oacute$1 = "Ã“";
const oacute$1 = "Ã³";
const oast = "âŠ›";
const Ocirc$1 = "Ã”";
const ocirc$1 = "Ã´";
const ocir = "âŠš";
const Ocy = "Ðž";
const ocy = "Ð¾";
const odash = "âŠ";
const Odblac = "Å";
const odblac = "Å‘";
const odiv = "â¨¸";
const odot = "âŠ™";
const odsold = "â¦¼";
const OElig = "Å’";
const oelig = "Å“";
const ofcir = "â¦¿";
const Ofr = "ð”’";
const ofr = "ð”¬";
const ogon = "Ë›";
const Ograve$1 = "Ã’";
const ograve$1 = "Ã²";
const ogt = "â§";
const ohbar = "â¦µ";
const ohm = "Î©";
const oint = "âˆ®";
const olarr = "â†º";
const olcir = "â¦¾";
const olcross = "â¦»";
const oline = "â€¾";
const olt = "â§€";
const Omacr = "ÅŒ";
const omacr = "Å";
const Omega = "Î©";
const omega = "Ï‰";
const Omicron = "ÎŸ";
const omicron = "Î¿";
const omid = "â¦¶";
const ominus = "âŠ–";
const Oopf = "ð•†";
const oopf = "ð• ";
const opar = "â¦·";
const OpenCurlyDoubleQuote = "â€œ";
const OpenCurlyQuote = "â€˜";
const operp = "â¦¹";
const oplus = "âŠ•";
const orarr = "â†»";
const Or = "â©”";
const or = "âˆ¨";
const ord = "â©";
const order$1 = "â„´";
const orderof = "â„´";
const ordf$1 = "Âª";
const ordm$1 = "Âº";
const origof = "âŠ¶";
const oror = "â©–";
const orslope = "â©—";
const orv = "â©›";
const oS = "â“ˆ";
const Oscr = "ð’ª";
const oscr = "â„´";
const Oslash$1 = "Ã˜";
const oslash$1 = "Ã¸";
const osol = "âŠ˜";
const Otilde$1 = "Ã•";
const otilde$1 = "Ãµ";
const otimesas = "â¨¶";
const Otimes = "â¨·";
const otimes = "âŠ—";
const Ouml$1 = "Ã–";
const ouml$1 = "Ã¶";
const ovbar = "âŒ½";
const OverBar = "â€¾";
const OverBrace = "âž";
const OverBracket = "âŽ´";
const OverParenthesis = "âœ";
const para$1 = "Â¶";
const parallel = "âˆ¥";
const par = "âˆ¥";
const parsim = "â«³";
const parsl = "â«½";
const part = "âˆ‚";
const PartialD = "âˆ‚";
const Pcy = "ÐŸ";
const pcy = "Ð¿";
const percnt = "%";
const period = ".";
const permil = "â€°";
const perp = "âŠ¥";
const pertenk = "â€±";
const Pfr = "ð”“";
const pfr = "ð”­";
const Phi = "Î¦";
const phi = "Ï†";
const phiv = "Ï•";
const phmmat = "â„³";
const phone = "â˜Ž";
const Pi = "Î ";
const pi = "Ï€";
const pitchfork = "â‹”";
const piv = "Ï–";
const planck = "â„";
const planckh = "â„Ž";
const plankv = "â„";
const plusacir = "â¨£";
const plusb = "âŠž";
const pluscir = "â¨¢";
const plus = "+";
const plusdo = "âˆ”";
const plusdu = "â¨¥";
const pluse = "â©²";
const PlusMinus = "Â±";
const plusmn$1 = "Â±";
const plussim = "â¨¦";
const plustwo = "â¨§";
const pm = "Â±";
const Poincareplane = "â„Œ";
const pointint = "â¨•";
const popf = "ð•¡";
const Popf = "â„™";
const pound$1 = "Â£";
const prap = "âª·";
const Pr = "âª»";
const pr = "â‰º";
const prcue = "â‰¼";
const precapprox = "âª·";
const prec = "â‰º";
const preccurlyeq = "â‰¼";
const Precedes = "â‰º";
const PrecedesEqual = "âª¯";
const PrecedesSlantEqual = "â‰¼";
const PrecedesTilde = "â‰¾";
const preceq = "âª¯";
const precnapprox = "âª¹";
const precneqq = "âªµ";
const precnsim = "â‹¨";
const pre = "âª¯";
const prE = "âª³";
const precsim = "â‰¾";
const prime = "â€²";
const Prime = "â€³";
const primes = "â„™";
const prnap = "âª¹";
const prnE = "âªµ";
const prnsim = "â‹¨";
const prod = "âˆ";
const Product = "âˆ";
const profalar = "âŒ®";
const profline = "âŒ’";
const profsurf = "âŒ“";
const prop = "âˆ";
const Proportional = "âˆ";
const Proportion = "âˆ·";
const propto = "âˆ";
const prsim = "â‰¾";
const prurel = "âŠ°";
const Pscr = "ð’«";
const pscr = "ð“…";
const Psi = "Î¨";
const psi = "Ïˆ";
const puncsp = "â€ˆ";
const Qfr = "ð””";
const qfr = "ð”®";
const qint = "â¨Œ";
const qopf = "ð•¢";
const Qopf = "â„š";
const qprime = "â—";
const Qscr = "ð’¬";
const qscr = "ð“†";
const quaternions = "â„";
const quatint = "â¨–";
const quest = "?";
const questeq = "â‰Ÿ";
const quot$2 = "\"";
const QUOT$1 = "\"";
const rAarr = "â‡›";
const race = "âˆ½Ì±";
const Racute = "Å”";
const racute = "Å•";
const radic = "âˆš";
const raemptyv = "â¦³";
const rang = "âŸ©";
const Rang = "âŸ«";
const rangd = "â¦’";
const range = "â¦¥";
const rangle = "âŸ©";
const raquo$1 = "Â»";
const rarrap = "â¥µ";
const rarrb = "â‡¥";
const rarrbfs = "â¤ ";
const rarrc = "â¤³";
const rarr = "â†’";
const Rarr = "â† ";
const rArr = "â‡’";
const rarrfs = "â¤ž";
const rarrhk = "â†ª";
const rarrlp = "â†¬";
const rarrpl = "â¥…";
const rarrsim = "â¥´";
const Rarrtl = "â¤–";
const rarrtl = "â†£";
const rarrw = "â†";
const ratail = "â¤š";
const rAtail = "â¤œ";
const ratio = "âˆ¶";
const rationals = "â„š";
const rbarr = "â¤";
const rBarr = "â¤";
const RBarr = "â¤";
const rbbrk = "â³";
const rbrace = "}";
const rbrack = "]";
const rbrke = "â¦Œ";
const rbrksld = "â¦Ž";
const rbrkslu = "â¦";
const Rcaron = "Å˜";
const rcaron = "Å™";
const Rcedil = "Å–";
const rcedil = "Å—";
const rceil = "âŒ‰";
const rcub = "}";
const Rcy = "Ð ";
const rcy = "Ñ€";
const rdca = "â¤·";
const rdldhar = "â¥©";
const rdquo = "â€";
const rdquor = "â€";
const rdsh = "â†³";
const real = "â„œ";
const realine = "â„›";
const realpart = "â„œ";
const reals = "â„";
const Re = "â„œ";
const rect = "â–­";
const reg$1 = "Â®";
const REG$1 = "Â®";
const ReverseElement = "âˆ‹";
const ReverseEquilibrium = "â‡‹";
const ReverseUpEquilibrium = "â¥¯";
const rfisht = "â¥½";
const rfloor = "âŒ‹";
const rfr = "ð”¯";
const Rfr = "â„œ";
const rHar = "â¥¤";
const rhard = "â‡";
const rharu = "â‡€";
const rharul = "â¥¬";
const Rho = "Î¡";
const rho = "Ï";
const rhov = "Ï±";
const RightAngleBracket = "âŸ©";
const RightArrowBar = "â‡¥";
const rightarrow = "â†’";
const RightArrow = "â†’";
const Rightarrow = "â‡’";
const RightArrowLeftArrow = "â‡„";
const rightarrowtail = "â†£";
const RightCeiling = "âŒ‰";
const RightDoubleBracket = "âŸ§";
const RightDownTeeVector = "â¥";
const RightDownVectorBar = "â¥•";
const RightDownVector = "â‡‚";
const RightFloor = "âŒ‹";
const rightharpoondown = "â‡";
const rightharpoonup = "â‡€";
const rightleftarrows = "â‡„";
const rightleftharpoons = "â‡Œ";
const rightrightarrows = "â‡‰";
const rightsquigarrow = "â†";
const RightTeeArrow = "â†¦";
const RightTee = "âŠ¢";
const RightTeeVector = "â¥›";
const rightthreetimes = "â‹Œ";
const RightTriangleBar = "â§";
const RightTriangle = "âŠ³";
const RightTriangleEqual = "âŠµ";
const RightUpDownVector = "â¥";
const RightUpTeeVector = "â¥œ";
const RightUpVectorBar = "â¥”";
const RightUpVector = "â†¾";
const RightVectorBar = "â¥“";
const RightVector = "â‡€";
const ring = "Ëš";
const risingdotseq = "â‰“";
const rlarr = "â‡„";
const rlhar = "â‡Œ";
const rlm = "â€";
const rmoustache = "âŽ±";
const rmoust = "âŽ±";
const rnmid = "â«®";
const roang = "âŸ­";
const roarr = "â‡¾";
const robrk = "âŸ§";
const ropar = "â¦†";
const ropf = "ð•£";
const Ropf = "â„";
const roplus = "â¨®";
const rotimes = "â¨µ";
const RoundImplies = "â¥°";
const rpar = ")";
const rpargt = "â¦”";
const rppolint = "â¨’";
const rrarr = "â‡‰";
const Rrightarrow = "â‡›";
const rsaquo = "â€º";
const rscr = "ð“‡";
const Rscr = "â„›";
const rsh = "â†±";
const Rsh = "â†±";
const rsqb = "]";
const rsquo = "â€™";
const rsquor = "â€™";
const rthree = "â‹Œ";
const rtimes = "â‹Š";
const rtri = "â–¹";
const rtrie = "âŠµ";
const rtrif = "â–¸";
const rtriltri = "â§Ž";
const RuleDelayed = "â§´";
const ruluhar = "â¥¨";
const rx = "â„ž";
const Sacute = "Åš";
const sacute = "Å›";
const sbquo = "â€š";
const scap = "âª¸";
const Scaron = "Å ";
const scaron = "Å¡";
const Sc = "âª¼";
const sc = "â‰»";
const sccue = "â‰½";
const sce = "âª°";
const scE = "âª´";
const Scedil = "Åž";
const scedil = "ÅŸ";
const Scirc = "Åœ";
const scirc = "Å";
const scnap = "âªº";
const scnE = "âª¶";
const scnsim = "â‹©";
const scpolint = "â¨“";
const scsim = "â‰¿";
const Scy = "Ð¡";
const scy = "Ñ";
const sdotb = "âŠ¡";
const sdot = "â‹…";
const sdote = "â©¦";
const searhk = "â¤¥";
const searr = "â†˜";
const seArr = "â‡˜";
const searrow = "â†˜";
const sect$1 = "Â§";
const semi = ";";
const seswar = "â¤©";
const setminus = "âˆ–";
const setmn = "âˆ–";
const sext = "âœ¶";
const Sfr = "ð”–";
const sfr = "ð”°";
const sfrown = "âŒ¢";
const sharp = "â™¯";
const SHCHcy = "Ð©";
const shchcy = "Ñ‰";
const SHcy = "Ð¨";
const shcy = "Ñˆ";
const ShortDownArrow = "â†“";
const ShortLeftArrow = "â†";
const shortmid = "âˆ£";
const shortparallel = "âˆ¥";
const ShortRightArrow = "â†’";
const ShortUpArrow = "â†‘";
const shy$1 = "Â­";
const Sigma = "Î£";
const sigma = "Ïƒ";
const sigmaf = "Ï‚";
const sigmav = "Ï‚";
const sim = "âˆ¼";
const simdot = "â©ª";
const sime = "â‰ƒ";
const simeq = "â‰ƒ";
const simg = "âªž";
const simgE = "âª ";
const siml = "âª";
const simlE = "âªŸ";
const simne = "â‰†";
const simplus = "â¨¤";
const simrarr = "â¥²";
const slarr = "â†";
const SmallCircle = "âˆ˜";
const smallsetminus = "âˆ–";
const smashp = "â¨³";
const smeparsl = "â§¤";
const smid = "âˆ£";
const smile = "âŒ£";
const smt = "âªª";
const smte = "âª¬";
const smtes = "âª¬ï¸€";
const SOFTcy = "Ð¬";
const softcy = "ÑŒ";
const solbar = "âŒ¿";
const solb = "â§„";
const sol = "/";
const Sopf = "ð•Š";
const sopf = "ð•¤";
const spades = "â™ ";
const spadesuit = "â™ ";
const spar = "âˆ¥";
const sqcap = "âŠ“";
const sqcaps = "âŠ“ï¸€";
const sqcup = "âŠ”";
const sqcups = "âŠ”ï¸€";
const Sqrt = "âˆš";
const sqsub = "âŠ";
const sqsube = "âŠ‘";
const sqsubset = "âŠ";
const sqsubseteq = "âŠ‘";
const sqsup = "âŠ";
const sqsupe = "âŠ’";
const sqsupset = "âŠ";
const sqsupseteq = "âŠ’";
const square = "â–¡";
const Square = "â–¡";
const SquareIntersection = "âŠ“";
const SquareSubset = "âŠ";
const SquareSubsetEqual = "âŠ‘";
const SquareSuperset = "âŠ";
const SquareSupersetEqual = "âŠ’";
const SquareUnion = "âŠ”";
const squarf = "â–ª";
const squ = "â–¡";
const squf = "â–ª";
const srarr = "â†’";
const Sscr = "ð’®";
const sscr = "ð“ˆ";
const ssetmn = "âˆ–";
const ssmile = "âŒ£";
const sstarf = "â‹†";
const Star = "â‹†";
const star = "â˜†";
const starf = "â˜…";
const straightepsilon = "Ïµ";
const straightphi = "Ï•";
const strns = "Â¯";
const sub$1 = "âŠ‚";
const Sub = "â‹";
const subdot = "âª½";
const subE = "â«…";
const sube = "âŠ†";
const subedot = "â«ƒ";
const submult = "â«";
const subnE = "â«‹";
const subne = "âŠŠ";
const subplus = "âª¿";
const subrarr = "â¥¹";
const subset = "âŠ‚";
const Subset = "â‹";
const subseteq = "âŠ†";
const subseteqq = "â«…";
const SubsetEqual = "âŠ†";
const subsetneq = "âŠŠ";
const subsetneqq = "â«‹";
const subsim = "â«‡";
const subsub = "â«•";
const subsup = "â«“";
const succapprox = "âª¸";
const succ = "â‰»";
const succcurlyeq = "â‰½";
const Succeeds = "â‰»";
const SucceedsEqual = "âª°";
const SucceedsSlantEqual = "â‰½";
const SucceedsTilde = "â‰¿";
const succeq = "âª°";
const succnapprox = "âªº";
const succneqq = "âª¶";
const succnsim = "â‹©";
const succsim = "â‰¿";
const SuchThat = "âˆ‹";
const sum = "âˆ‘";
const Sum = "âˆ‘";
const sung = "â™ª";
const sup1$1 = "Â¹";
const sup2$1 = "Â²";
const sup3$1 = "Â³";
const sup = "âŠƒ";
const Sup = "â‹‘";
const supdot = "âª¾";
const supdsub = "â«˜";
const supE = "â«†";
const supe = "âŠ‡";
const supedot = "â«„";
const Superset = "âŠƒ";
const SupersetEqual = "âŠ‡";
const suphsol = "âŸ‰";
const suphsub = "â«—";
const suplarr = "â¥»";
const supmult = "â«‚";
const supnE = "â«Œ";
const supne = "âŠ‹";
const supplus = "â«€";
const supset = "âŠƒ";
const Supset = "â‹‘";
const supseteq = "âŠ‡";
const supseteqq = "â«†";
const supsetneq = "âŠ‹";
const supsetneqq = "â«Œ";
const supsim = "â«ˆ";
const supsub = "â«”";
const supsup = "â«–";
const swarhk = "â¤¦";
const swarr = "â†™";
const swArr = "â‡™";
const swarrow = "â†™";
const swnwar = "â¤ª";
const szlig$1 = "ÃŸ";
const Tab = "\t";
const target$1 = "âŒ–";
const Tau = "Î¤";
const tau = "Ï„";
const tbrk = "âŽ´";
const Tcaron = "Å¤";
const tcaron = "Å¥";
const Tcedil = "Å¢";
const tcedil = "Å£";
const Tcy = "Ð¢";
const tcy = "Ñ‚";
const tdot = "âƒ›";
const telrec = "âŒ•";
const Tfr = "ð”—";
const tfr = "ð”±";
const there4 = "âˆ´";
const therefore = "âˆ´";
const Therefore = "âˆ´";
const Theta = "Î˜";
const theta = "Î¸";
const thetasym = "Ï‘";
const thetav = "Ï‘";
const thickapprox = "â‰ˆ";
const thicksim = "âˆ¼";
const ThickSpace = "âŸâ€Š";
const ThinSpace = "â€‰";
const thinsp = "â€‰";
const thkap = "â‰ˆ";
const thksim = "âˆ¼";
const THORN$1 = "Ãž";
const thorn$1 = "Ã¾";
const tilde = "Ëœ";
const Tilde = "âˆ¼";
const TildeEqual = "â‰ƒ";
const TildeFullEqual = "â‰…";
const TildeTilde = "â‰ˆ";
const timesbar = "â¨±";
const timesb = "âŠ ";
const times$1 = "Ã—";
const timesd = "â¨°";
const tint = "âˆ­";
const toea = "â¤¨";
const topbot = "âŒ¶";
const topcir = "â«±";
const top$1 = "âŠ¤";
const Topf = "ð•‹";
const topf = "ð•¥";
const topfork = "â«š";
const tosa = "â¤©";
const tprime = "â€´";
const trade = "â„¢";
const TRADE = "â„¢";
const triangle = "â–µ";
const triangledown = "â–¿";
const triangleleft = "â—ƒ";
const trianglelefteq = "âŠ´";
const triangleq = "â‰œ";
const triangleright = "â–¹";
const trianglerighteq = "âŠµ";
const tridot = "â—¬";
const trie = "â‰œ";
const triminus = "â¨º";
const TripleDot = "âƒ›";
const triplus = "â¨¹";
const trisb = "â§";
const tritime = "â¨»";
const trpezium = "â¢";
const Tscr = "ð’¯";
const tscr = "ð“‰";
const TScy = "Ð¦";
const tscy = "Ñ†";
const TSHcy = "Ð‹";
const tshcy = "Ñ›";
const Tstrok = "Å¦";
const tstrok = "Å§";
const twixt = "â‰¬";
const twoheadleftarrow = "â†ž";
const twoheadrightarrow = "â† ";
const Uacute$1 = "Ãš";
const uacute$1 = "Ãº";
const uarr = "â†‘";
const Uarr = "â†Ÿ";
const uArr = "â‡‘";
const Uarrocir = "â¥‰";
const Ubrcy = "ÐŽ";
const ubrcy = "Ñž";
const Ubreve = "Å¬";
const ubreve = "Å­";
const Ucirc$1 = "Ã›";
const ucirc$1 = "Ã»";
const Ucy = "Ð£";
const ucy = "Ñƒ";
const udarr = "â‡…";
const Udblac = "Å°";
const udblac = "Å±";
const udhar = "â¥®";
const ufisht = "â¥¾";
const Ufr = "ð”˜";
const ufr = "ð”²";
const Ugrave$1 = "Ã™";
const ugrave$1 = "Ã¹";
const uHar = "â¥£";
const uharl = "â†¿";
const uharr = "â†¾";
const uhblk = "â–€";
const ulcorn = "âŒœ";
const ulcorner = "âŒœ";
const ulcrop = "âŒ";
const ultri = "â—¸";
const Umacr = "Åª";
const umacr = "Å«";
const uml$1 = "Â¨";
const UnderBar = "_";
const UnderBrace = "âŸ";
const UnderBracket = "âŽµ";
const UnderParenthesis = "â";
const Union = "â‹ƒ";
const UnionPlus = "âŠŽ";
const Uogon = "Å²";
const uogon = "Å³";
const Uopf = "ð•Œ";
const uopf = "ð•¦";
const UpArrowBar = "â¤’";
const uparrow = "â†‘";
const UpArrow = "â†‘";
const Uparrow = "â‡‘";
const UpArrowDownArrow = "â‡…";
const updownarrow = "â†•";
const UpDownArrow = "â†•";
const Updownarrow = "â‡•";
const UpEquilibrium = "â¥®";
const upharpoonleft = "â†¿";
const upharpoonright = "â†¾";
const uplus = "âŠŽ";
const UpperLeftArrow = "â†–";
const UpperRightArrow = "â†—";
const upsi = "Ï…";
const Upsi = "Ï’";
const upsih = "Ï’";
const Upsilon = "Î¥";
const upsilon = "Ï…";
const UpTeeArrow = "â†¥";
const UpTee = "âŠ¥";
const upuparrows = "â‡ˆ";
const urcorn = "âŒ";
const urcorner = "âŒ";
const urcrop = "âŒŽ";
const Uring = "Å®";
const uring = "Å¯";
const urtri = "â—¹";
const Uscr = "ð’°";
const uscr = "ð“Š";
const utdot = "â‹°";
const Utilde = "Å¨";
const utilde = "Å©";
const utri = "â–µ";
const utrif = "â–´";
const uuarr = "â‡ˆ";
const Uuml$1 = "Ãœ";
const uuml$1 = "Ã¼";
const uwangle = "â¦§";
const vangrt = "â¦œ";
const varepsilon = "Ïµ";
const varkappa = "Ï°";
const varnothing = "âˆ…";
const varphi = "Ï•";
const varpi = "Ï–";
const varpropto = "âˆ";
const varr = "â†•";
const vArr = "â‡•";
const varrho = "Ï±";
const varsigma = "Ï‚";
const varsubsetneq = "âŠŠï¸€";
const varsubsetneqq = "â«‹ï¸€";
const varsupsetneq = "âŠ‹ï¸€";
const varsupsetneqq = "â«Œï¸€";
const vartheta = "Ï‘";
const vartriangleleft = "âŠ²";
const vartriangleright = "âŠ³";
const vBar = "â«¨";
const Vbar = "â««";
const vBarv = "â«©";
const Vcy = "Ð’";
const vcy = "Ð²";
const vdash = "âŠ¢";
const vDash = "âŠ¨";
const Vdash = "âŠ©";
const VDash = "âŠ«";
const Vdashl = "â«¦";
const veebar = "âŠ»";
const vee = "âˆ¨";
const Vee = "â‹";
const veeeq = "â‰š";
const vellip = "â‹®";
const verbar = "|";
const Verbar = "â€–";
const vert = "|";
const Vert = "â€–";
const VerticalBar = "âˆ£";
const VerticalLine = "|";
const VerticalSeparator = "â˜";
const VerticalTilde = "â‰€";
const VeryThinSpace = "â€Š";
const Vfr = "ð”™";
const vfr = "ð”³";
const vltri = "âŠ²";
const vnsub = "âŠ‚âƒ’";
const vnsup = "âŠƒâƒ’";
const Vopf = "ð•";
const vopf = "ð•§";
const vprop = "âˆ";
const vrtri = "âŠ³";
const Vscr = "ð’±";
const vscr = "ð“‹";
const vsubnE = "â«‹ï¸€";
const vsubne = "âŠŠï¸€";
const vsupnE = "â«Œï¸€";
const vsupne = "âŠ‹ï¸€";
const Vvdash = "âŠª";
const vzigzag = "â¦š";
const Wcirc = "Å´";
const wcirc = "Åµ";
const wedbar = "â©Ÿ";
const wedge = "âˆ§";
const Wedge = "â‹€";
const wedgeq = "â‰™";
const weierp = "â„˜";
const Wfr = "ð”š";
const wfr = "ð”´";
const Wopf = "ð•Ž";
const wopf = "ð•¨";
const wp = "â„˜";
const wr = "â‰€";
const wreath = "â‰€";
const Wscr = "ð’²";
const wscr = "ð“Œ";
const xcap = "â‹‚";
const xcirc = "â—¯";
const xcup = "â‹ƒ";
const xdtri = "â–½";
const Xfr = "ð”›";
const xfr = "ð”µ";
const xharr = "âŸ·";
const xhArr = "âŸº";
const Xi = "Îž";
const xi = "Î¾";
const xlarr = "âŸµ";
const xlArr = "âŸ¸";
const xmap = "âŸ¼";
const xnis = "â‹»";
const xodot = "â¨€";
const Xopf = "ð•";
const xopf = "ð•©";
const xoplus = "â¨";
const xotime = "â¨‚";
const xrarr = "âŸ¶";
const xrArr = "âŸ¹";
const Xscr = "ð’³";
const xscr = "ð“";
const xsqcup = "â¨†";
const xuplus = "â¨„";
const xutri = "â–³";
const xvee = "â‹";
const xwedge = "â‹€";
const Yacute$1 = "Ã";
const yacute$1 = "Ã½";
const YAcy = "Ð¯";
const yacy = "Ñ";
const Ycirc = "Å¶";
const ycirc = "Å·";
const Ycy = "Ð«";
const ycy = "Ñ‹";
const yen$1 = "Â¥";
const Yfr = "ð”œ";
const yfr = "ð”¶";
const YIcy = "Ð‡";
const yicy = "Ñ—";
const Yopf = "ð•";
const yopf = "ð•ª";
const Yscr = "ð’´";
const yscr = "ð“Ž";
const YUcy = "Ð®";
const yucy = "ÑŽ";
const yuml$1 = "Ã¿";
const Yuml = "Å¸";
const Zacute = "Å¹";
const zacute = "Åº";
const Zcaron = "Å½";
const zcaron = "Å¾";
const Zcy = "Ð—";
const zcy = "Ð·";
const Zdot = "Å»";
const zdot = "Å¼";
const zeetrf = "â„¨";
const ZeroWidthSpace = "â€‹";
const Zeta = "Î–";
const zeta = "Î¶";
const zfr = "ð”·";
const Zfr = "â„¨";
const ZHcy = "Ð–";
const zhcy = "Ð¶";
const zigrarr = "â‡";
const zopf = "ð•«";
const Zopf = "â„¤";
const Zscr = "ð’µ";
const zscr = "ð“";
const zwj = "â€";
const zwnj = "â€Œ";
const require$$1$2 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	Acy: Acy,
	acy: acy,
	AElig: AElig$1,
	aelig: aelig$1,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave$1,
	agrave: agrave$1,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$2,
	AMP: AMP$1,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring$1,
	aring: aring$1,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom$1,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar$1,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil$1,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent$1,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy$3,
	COPY: COPY$1,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross$1,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg$1,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot$1,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute$1,
	eacute: eacute$1,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave$1,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap$1,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$2,
	GT: GT$1,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute$1,
	iacute: iacute$1,
	ic: ic,
	Icirc: Icirc$1,
	icirc: icirc$1,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave$1,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image$1,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "âˆˆ",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest$1,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml$1,
	iuml: iuml$1,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang$1,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$2,
	LT: LT$1,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "â¤…",
	map: map,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro$1,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot$1,
	minusb: minusb,
	minus: minus$1,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not$2,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute$1,
	oacute: oacute$1,
	oast: oast,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order$1,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash$1,
	oslash: oslash$1,
	osol: osol,
	Otilde: Otilde$1,
	otilde: otilde$1,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml$1,
	ouml: ouml$1,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para$1,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound$1,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$2,
	QUOT: QUOT$1,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg$1,
	REG: REG$1,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy$1,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub$1,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig$1,
	Tab: Tab,
	target: target$1,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN$1,
	thorn: thorn$1,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top$1,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute$1,
	uacute: uacute$1,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml$1,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml$1,
	uuml: uuml$1,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute$1,
	yacute: yacute$1,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen$1,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml$1,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

const Aacute = "Ã";
const aacute = "Ã¡";
const Acirc = "Ã‚";
const acirc = "Ã¢";
const acute = "Â´";
const AElig = "Ã†";
const aelig = "Ã¦";
const Agrave = "Ã€";
const agrave = "Ã ";
const amp$1 = "&";
const AMP = "&";
const Aring = "Ã…";
const aring = "Ã¥";
const Atilde = "Ãƒ";
const atilde = "Ã£";
const Auml = "Ã„";
const auml = "Ã¤";
const brvbar = "Â¦";
const Ccedil = "Ã‡";
const ccedil = "Ã§";
const cedil = "Â¸";
const cent = "Â¢";
const copy$2 = "Â©";
const COPY = "Â©";
const curren = "Â¤";
const deg = "Â°";
const divide = "Ã·";
const Eacute = "Ã‰";
const eacute = "Ã©";
const Ecirc = "ÃŠ";
const ecirc = "Ãª";
const Egrave = "Ãˆ";
const egrave = "Ã¨";
const ETH = "Ã";
const eth = "Ã°";
const Euml = "Ã‹";
const euml = "Ã«";
const frac12 = "Â½";
const frac14 = "Â¼";
const frac34 = "Â¾";
const gt$1 = ">";
const GT = ">";
const Iacute = "Ã";
const iacute = "Ã­";
const Icirc = "ÃŽ";
const icirc = "Ã®";
const iexcl = "Â¡";
const Igrave = "ÃŒ";
const igrave = "Ã¬";
const iquest = "Â¿";
const Iuml = "Ã";
const iuml = "Ã¯";
const laquo = "Â«";
const lt$1 = "<";
const LT = "<";
const macr = "Â¯";
const micro = "Âµ";
const middot = "Â·";
const nbsp = "Â ";
const not$1 = "Â¬";
const Ntilde = "Ã‘";
const ntilde = "Ã±";
const Oacute = "Ã“";
const oacute = "Ã³";
const Ocirc = "Ã”";
const ocirc = "Ã´";
const Ograve = "Ã’";
const ograve = "Ã²";
const ordf = "Âª";
const ordm = "Âº";
const Oslash = "Ã˜";
const oslash = "Ã¸";
const Otilde = "Ã•";
const otilde = "Ãµ";
const Ouml = "Ã–";
const ouml = "Ã¶";
const para = "Â¶";
const plusmn = "Â±";
const pound = "Â£";
const quot$1 = "\"";
const QUOT = "\"";
const raquo = "Â»";
const reg = "Â®";
const REG = "Â®";
const sect = "Â§";
const shy = "Â­";
const sup1 = "Â¹";
const sup2 = "Â²";
const sup3 = "Â³";
const szlig = "ÃŸ";
const THORN = "Ãž";
const thorn = "Ã¾";
const times = "Ã—";
const Uacute = "Ãš";
const uacute = "Ãº";
const Ucirc = "Ã›";
const ucirc = "Ã»";
const Ugrave = "Ã™";
const ugrave = "Ã¹";
const uml = "Â¨";
const Uuml = "Ãœ";
const uuml = "Ã¼";
const Yacute = "Ã";
const yacute = "Ã½";
const yen = "Â¥";
const yuml = "Ã¿";
const require$$1$1 = {
	Aacute: Aacute,
	aacute: aacute,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	AElig: AElig,
	aelig: aelig,
	Agrave: Agrave,
	agrave: agrave,
	amp: amp$1,
	AMP: AMP,
	Aring: Aring,
	aring: aring,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	brvbar: brvbar,
	Ccedil: Ccedil,
	ccedil: ccedil,
	cedil: cedil,
	cent: cent,
	copy: copy$2,
	COPY: COPY,
	curren: curren,
	deg: deg,
	divide: divide,
	Eacute: Eacute,
	eacute: eacute,
	Ecirc: Ecirc,
	ecirc: ecirc,
	Egrave: Egrave,
	egrave: egrave,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	frac12: frac12,
	frac14: frac14,
	frac34: frac34,
	gt: gt$1,
	GT: GT,
	Iacute: Iacute,
	iacute: iacute,
	Icirc: Icirc,
	icirc: icirc,
	iexcl: iexcl,
	Igrave: Igrave,
	igrave: igrave,
	iquest: iquest,
	Iuml: Iuml,
	iuml: iuml,
	laquo: laquo,
	lt: lt$1,
	LT: LT,
	macr: macr,
	micro: micro,
	middot: middot,
	nbsp: nbsp,
	not: not$1,
	Ntilde: Ntilde,
	ntilde: ntilde,
	Oacute: Oacute,
	oacute: oacute,
	Ocirc: Ocirc,
	ocirc: ocirc,
	Ograve: Ograve,
	ograve: ograve,
	ordf: ordf,
	ordm: ordm,
	Oslash: Oslash,
	oslash: oslash,
	Otilde: Otilde,
	otilde: otilde,
	Ouml: Ouml,
	ouml: ouml,
	para: para,
	plusmn: plusmn,
	pound: pound,
	quot: quot$1,
	QUOT: QUOT,
	raquo: raquo,
	reg: reg,
	REG: REG,
	sect: sect,
	shy: shy,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	szlig: szlig,
	THORN: THORN,
	thorn: thorn,
	times: times,
	Uacute: Uacute,
	uacute: uacute,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uml: uml,
	Uuml: Uuml,
	uuml: uuml,
	Yacute: Yacute,
	yacute: yacute,
	yen: yen,
	yuml: yuml
};

const amp = "&";
const apos = "'";
const gt = ">";
const lt = "<";
const quot = "\"";
const require$$0$3 = {
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot
};

var decode_codepoint = {};

const require$$0$2 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: true });
var decode_json_1 = __importDefault$5(require$$0$2);
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
}
decode_codepoint.default = decodeCodePoint;

var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode, "__esModule", { value: true });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$4(require$$1$2);
var legacy_json_1 = __importDefault$4(require$$1$1);
var xml_json_1$1 = __importDefault$4(require$$0$3);
var decode_codepoint_1 = __importDefault$4(decode_codepoint);
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
decode.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1$1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1$1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}

var encode = {};

var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(encode, "__esModule", { value: true });
encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
var xml_json_1 = __importDefault$3(require$$0$3);
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault$3(require$$1$2);
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
}
encode.escape = escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
encode.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
	var decode_1 = decode;
	var encode_1 = encode;
	/**
	 * Decodes a string with entities.
	 *
	 * @param data String to decode.
	 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
	 * @deprecated Use `decodeXML` or `decodeHTML` directly.
	 */
	function decode$1(data, level) {
	    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
	}
	exports.decode = decode$1;
	/**
	 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
	 *
	 * @param data String to decode.
	 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
	 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
	 */
	function decodeStrict(data, level) {
	    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
	}
	exports.decodeStrict = decodeStrict;
	/**
	 * Encodes a string with entities.
	 *
	 * @param data String to encode.
	 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
	 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
	 */
	function encode$1(data, level) {
	    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
	}
	exports.encode = encode$1;
	var encode_2 = encode;
	Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
	Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
	Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
	Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
	Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
	// Legacy aliases (deprecated)
	Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
	Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
	var decode_2 = decode;
	Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
	Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
	Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
	// Legacy aliases (deprecated)
	Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
	Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
	Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
	Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
	Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });
} (lib$3));

var foreignNames = {};

Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"],
]);
foreignNames.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"],
]);

var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(lib$4, "__esModule", { value: true });
/*
 * Module dependencies
 */
var ElementType = __importStar(lib$5);
var entities_1 = lib$3;
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = foreignNames;
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    if (!attributes)
        return;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return key + "=\"" + (opts.decodeEntities !== false
            ? entities_1.encodeXML(value)
            : value.replace(/"/g, "&quot;")) + "\"";
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
lib$4.default = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " " + attribs;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<" + elem.data + ">";
}
function renderText(elem, opts) {
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (opts.decodeEntities !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
    return "<!--" + elem.data + "-->";
}

var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(stringify$1, "__esModule", { value: true });
stringify$1.innerText = stringify$1.textContent = stringify$1.getText = stringify$1.getInnerHTML = stringify$1.getOuterHTML = void 0;
var domhandler_1$4 = lib$6;
var dom_serializer_1 = __importDefault$2(lib$4);
var domelementtype_1 = lib$5;
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
stringify$1.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return (0, domhandler_1$4.hasChildren)(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
stringify$1.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText$1(node) {
    if (Array.isArray(node))
        return node.map(getText$1).join("");
    if ((0, domhandler_1$4.isTag)(node))
        return node.name === "br" ? "\n" : getText$1(node.children);
    if ((0, domhandler_1$4.isCDATA)(node))
        return getText$1(node.children);
    if ((0, domhandler_1$4.isText)(node))
        return node.data;
    return "";
}
stringify$1.getText = getText$1;
/**
 * Get a node's text content.
 *
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if ((0, domhandler_1$4.hasChildren)(node) && !(0, domhandler_1$4.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1$4.isText)(node))
        return node.data;
    return "";
}
stringify$1.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if ((0, domhandler_1$4.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1$4.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1$4.isText)(node))
        return node.data;
    return "";
}
stringify$1.innerText = innerText;

var traversal = {};

Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
var domhandler_1$3 = lib$6;
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren$1(elem) {
    var _a;
    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
traversal.getChildren = getChildren$1;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent$1(elem) {
    return elem.parent || null;
}
traversal.getParent = getParent$1;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings$1(elem) {
    var _a, _b;
    var parent = getParent$1(elem);
    if (parent != null)
        return getChildren$1(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
traversal.getSiblings = getSiblings$1;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue$1(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
traversal.getAttributeValue = getAttributeValue$1;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib$1(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
traversal.hasAttrib = hasAttrib$1;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName$1(elem) {
    return elem.name;
}
traversal.getName = getName$1;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1$3.isTag)(next))
        (_a = next, next = _a.next);
    return next;
}
traversal.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1$3.isTag)(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
traversal.prevElementSibling = prevElementSibling;

var manipulation = {};

Object.defineProperty(manipulation, "__esModule", { value: true });
manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
manipulation.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
manipulation.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
manipulation.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append$1(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
manipulation.append = append$1;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
manipulation.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
manipulation.prepend = prepend;

var querying = {};

Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
var domhandler_1$2 = lib$6;
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter$1(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find(test, node, recurse, limit);
}
querying.filter = filter$1;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && (0, domhandler_1$2.hasChildren)(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
querying.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
querying.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne$1(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1$2.isTag)(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne$1(test, checked.children);
        }
    }
    return elem;
}
querying.findOne = findOne$1;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne$1(test, nodes) {
    return nodes.some(function (checked) {
        return (0, domhandler_1$2.isTag)(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne$1(test, checked.children)));
    });
}
querying.existsOne = existsOne$1;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll$1(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1$2.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1$2.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
querying.findAll = findAll$1;

var legacy = {};

Object.defineProperty(legacy, "__esModule", { value: true });
legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
var domhandler_1$1 = lib$6;
var querying_1 = querying;
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return (0, domhandler_1$1.isTag)(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1$1.isTag;
        }
        return function (elem) { return (0, domhandler_1$1.isTag)(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return (0, domhandler_1$1.isText)(elem) && data(elem.data); };
        }
        return function (elem) { return (0, domhandler_1$1.isText)(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return (0, domhandler_1$1.isTag)(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return (0, domhandler_1$1.isTag)(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
legacy.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
}
legacy.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
legacy.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
}
legacy.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
}
legacy.getElementsByTagType = getElementsByTagType;

var helpers = {};

Object.defineProperty(helpers, "__esModule", { value: true });
helpers.uniqueSort = helpers.compareDocumentPosition = helpers.removeSubsets = void 0;
var domhandler_1 = lib$6;
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets$1(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
helpers.removeSubsets = removeSubsets$1;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    if (sharedParent === nodeA) {
        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
    }
    return 2 /* PRECEDING */;
}
helpers.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
helpers.uniqueSort = uniqueSort;

var feeds = {};

Object.defineProperty(feeds, "__esModule", { value: true });
feeds.getFeed = void 0;
var stringify_1 = stringify$1;
var legacy_1 = legacy;
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot
        ? null
        : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
}
feeds.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function (item) {
            var _a;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
            if (href) {
                entry.link = href;
            }
            var description = fetch$1("summary", children) || fetch$1("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch$1("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        }),
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch$1("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch$1("pubDate", children);
            if (pubDate)
                entry.pubDate = new Date(pubDate);
            return entry;
        }),
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch$1("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
    return (0, legacy_1.getElementsByTagName)("media:content", where).map(function (elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs.medium,
            isDefault: !!attribs.isDefault,
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs.expression) {
            media.expression =
                attribs.expression;
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
    return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where  Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch$1(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var val = fetch$1(tagName, where, recurse);
    if (val)
        obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
	__exportStar(stringify$1, exports);
	__exportStar(traversal, exports);
	__exportStar(manipulation, exports);
	__exportStar(querying, exports);
	__exportStar(legacy, exports);
	__exportStar(helpers, exports);
	__exportStar(feeds, exports);
	/** @deprecated Use these methods from `domhandler` directly. */
	var domhandler_1 = lib$6;
	Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
	Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
	Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
	Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
	Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
	Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });
} (lib$7));

var boolbase = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

var compile$3 = {};

var SelectorType;
(function (SelectorType) {
    SelectorType["Attribute"] = "attribute";
    SelectorType["Pseudo"] = "pseudo";
    SelectorType["PseudoElement"] = "pseudo-element";
    SelectorType["Tag"] = "tag";
    SelectorType["Universal"] = "universal";
    // Traversals
    SelectorType["Adjacent"] = "adjacent";
    SelectorType["Child"] = "child";
    SelectorType["Descendant"] = "descendant";
    SelectorType["Parent"] = "parent";
    SelectorType["Sibling"] = "sibling";
    SelectorType["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
/**
 * Modes for ignore case.
 *
 * This could be updated to an enum, and the object is
 * the current stand-in that will allow code to be updated
 * without big changes.
 */
const IgnoreCaseMode = {
    Unknown: null,
    QuirksMode: "quirks",
    IgnoreCase: true,
    CaseSensitive: false,
};
var AttributeAction;
(function (AttributeAction) {
    AttributeAction["Any"] = "any";
    AttributeAction["Element"] = "element";
    AttributeAction["End"] = "end";
    AttributeAction["Equals"] = "equals";
    AttributeAction["Exists"] = "exists";
    AttributeAction["Hyphen"] = "hyphen";
    AttributeAction["Not"] = "not";
    AttributeAction["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = new Map([
    [126 /* Tilde */, AttributeAction.Element],
    [94 /* Circumflex */, AttributeAction.Start],
    [36 /* Dollar */, AttributeAction.End],
    [42 /* Asterisk */, AttributeAction.Any],
    [33 /* ExclamationMark */, AttributeAction.Not],
    [124 /* Pipe */, AttributeAction.Hyphen],
]);
// Pseudos, whose data property is parsed as well.
const unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    switch (selector.type) {
        case SelectorType.Adjacent:
        case SelectorType.Child:
        case SelectorType.Descendant:
        case SelectorType.Parent:
        case SelectorType.Sibling:
        case SelectorType.ColumnCombinator:
            return true;
        default:
            return false;
    }
}
const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    const high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isQuote(c) {
    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
}
function isWhitespace(c) {
    return (c === 32 /* Space */ ||
        c === 9 /* Tab */ ||
        c === 10 /* NewLine */ ||
        c === 12 /* FormFeed */ ||
        c === 13 /* CarriageReturn */);
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$6(selector) {
    const subselects = [];
    const endIndex = parseSelector(subselects, `${selector}`, 0);
    if (endIndex < selector.length) {
        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
    }
    return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
    let tokens = [];
    function getName(offset) {
        const match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
        }
        const [name] = match;
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length &&
            isWhitespace(selector.charCodeAt(selectorIndex))) {
            selectorIndex++;
        }
    }
    function readValueWithParenthesis() {
        selectorIndex += 1;
        const start = selectorIndex;
        let counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
            if (selector.charCodeAt(selectorIndex) ===
                40 /* LeftParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter++;
            }
            else if (selector.charCodeAt(selectorIndex) ===
                41 /* RightParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter--;
            }
        }
        if (counter) {
            throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
    }
    function isEscaped(pos) {
        let slashCount = 0;
        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    function addTraversal(type) {
        if (tokens.length > 0 &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens[tokens.length - 1].type = type;
            return;
        }
        ensureNotTraversal();
        tokens.push({ type });
    }
    function addSpecialAttribute(name, action) {
        tokens.push({
            type: SelectorType.Attribute,
            name,
            action,
            value: getName(1),
            namespace: null,
            ignoreCase: "quirks",
        });
    }
    /**
     * We have finished parsing the current part of the selector.
     *
     * Remove descendant tokens at the end if they exist,
     * and return the last index, so that parsing can be
     * picked up from here.
     */
    function finalizeSubselector() {
        if (tokens.length &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens.pop();
        }
        if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
    }
    stripWhitespace(0);
    if (selector.length === selectorIndex) {
        return selectorIndex;
    }
    loop: while (selectorIndex < selector.length) {
        const firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
            // Whitespace
            case 32 /* Space */:
            case 9 /* Tab */:
            case 10 /* NewLine */:
            case 12 /* FormFeed */:
            case 13 /* CarriageReturn */: {
                if (tokens.length === 0 ||
                    tokens[0].type !== SelectorType.Descendant) {
                    ensureNotTraversal();
                    tokens.push({ type: SelectorType.Descendant });
                }
                stripWhitespace(1);
                break;
            }
            // Traversals
            case 62 /* GreaterThan */: {
                addTraversal(SelectorType.Child);
                stripWhitespace(1);
                break;
            }
            case 60 /* LessThan */: {
                addTraversal(SelectorType.Parent);
                stripWhitespace(1);
                break;
            }
            case 126 /* Tilde */: {
                addTraversal(SelectorType.Sibling);
                stripWhitespace(1);
                break;
            }
            case 43 /* Plus */: {
                addTraversal(SelectorType.Adjacent);
                stripWhitespace(1);
                break;
            }
            // Special attribute selectors: .class, #id
            case 46 /* Period */: {
                addSpecialAttribute("class", AttributeAction.Element);
                break;
            }
            case 35 /* Hash */: {
                addSpecialAttribute("id", AttributeAction.Equals);
                break;
            }
            case 91 /* LeftSquareBracket */: {
                stripWhitespace(1);
                // Determine attribute name and namespace
                let name;
                let namespace = null;
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
                    // Equivalent to no namespace
                    name = getName(1);
                }
                else if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    name = getName(2);
                }
                else {
                    name = getName(0);
                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                        selector.charCodeAt(selectorIndex + 1) !==
                            61 /* Equal */) {
                        namespace = name;
                        name = getName(1);
                    }
                }
                stripWhitespace(0);
                // Determine comparison operation
                let action = AttributeAction.Exists;
                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charCodeAt(selectorIndex + 1) !==
                        61 /* Equal */) {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
                    action = AttributeAction.Equals;
                    stripWhitespace(1);
                }
                // Determine value
                let value = "";
                let ignoreCase = null;
                if (action !== "exists") {
                    if (isQuote(selector.charCodeAt(selectorIndex))) {
                        const quote = selector.charCodeAt(selectorIndex);
                        let sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charCodeAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charCodeAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        const valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                                selector.charCodeAt(selectorIndex) !==
                                    93 /* RightSquareBracket */) ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === 115 /* LowerS */) {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === 105 /* LowerI */) {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                if (selector.charCodeAt(selectorIndex) !==
                    93 /* RightSquareBracket */) {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                const attributeSelector = {
                    type: SelectorType.Attribute,
                    name,
                    action,
                    value,
                    namespace,
                    ignoreCase,
                };
                tokens.push(attributeSelector);
                break;
            }
            case 58 /* Colon */: {
                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
                    tokens.push({
                        type: SelectorType.PseudoElement,
                        name: getName(2).toLowerCase(),
                        data: selector.charCodeAt(selectorIndex) ===
                            40 /* LeftParenthesis */
                            ? readValueWithParenthesis()
                            : null,
                    });
                    continue;
                }
                const name = getName(1).toLowerCase();
                let data = null;
                if (selector.charCodeAt(selectorIndex) ===
                    40 /* LeftParenthesis */) {
                    if (unpackPseudos.has(name)) {
                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                        if (selector.charCodeAt(selectorIndex) !==
                            41 /* RightParenthesis */) {
                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
                        }
                        selectorIndex += 1;
                    }
                    else {
                        data = readValueWithParenthesis();
                        if (stripQuotesFromPseudos.has(name)) {
                            const quot = data.charCodeAt(0);
                            if (quot === data.charCodeAt(data.length - 1) &&
                                isQuote(quot)) {
                                data = data.slice(1, -1);
                            }
                        }
                        data = unescapeCSS(data);
                    }
                }
                tokens.push({ type: SelectorType.Pseudo, name, data });
                break;
            }
            case 44 /* Comma */: {
                finalizeSubselector();
                tokens = [];
                stripWhitespace(1);
                break;
            }
            default: {
                if (selector.startsWith("/*", selectorIndex)) {
                    const endIndex = selector.indexOf("*/", selectorIndex + 2);
                    if (endIndex < 0) {
                        throw new Error("Comment was not terminated");
                    }
                    selectorIndex = endIndex + 2;
                    // Remove leading whitespace
                    if (tokens.length === 0) {
                        stripWhitespace(0);
                    }
                    break;
                }
                let namespace = null;
                let name;
                if (firstChar === 42 /* Asterisk */) {
                    selectorIndex += 1;
                    name = "*";
                }
                else if (firstChar === 124 /* Pipe */) {
                    name = "";
                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
                        addTraversal(SelectorType.ColumnCombinator);
                        stripWhitespace(2);
                        break;
                    }
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    name = getName(0);
                }
                else {
                    break loop;
                }
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
                    namespace = name;
                    if (selector.charCodeAt(selectorIndex + 1) ===
                        42 /* Asterisk */) {
                        name = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name = getName(1);
                    }
                }
                tokens.push(name === "*"
                    ? { type: SelectorType.Universal, namespace }
                    : { type: SelectorType.Tag, name, namespace });
            }
        }
    }
    finalizeSubselector();
    return selectorIndex;
}

const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInName = new Set([
    ...pseudoValChars,
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    ".",
].map((c) => c.charCodeAt(0)));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
    return selector
        .map((token) => token.map(stringifyToken).join(""))
        .join(", ");
}
function stringifyToken(token, index, arr) {
    switch (token.type) {
        // Simple types
        case SelectorType.Child:
            return index === 0 ? "> " : " > ";
        case SelectorType.Parent:
            return index === 0 ? "< " : " < ";
        case SelectorType.Sibling:
            return index === 0 ? "~ " : " ~ ";
        case SelectorType.Adjacent:
            return index === 0 ? "+ " : " + ";
        case SelectorType.Descendant:
            return " ";
        case SelectorType.ColumnCombinator:
            return index === 0 ? "|| " : " || ";
        case SelectorType.Universal:
            // Return an empty string if the selector isn't needed.
            return token.namespace === "*" &&
                index + 1 < arr.length &&
                "name" in arr[index + 1]
                ? ""
                : `${getNamespace(token.namespace)}*`;
        case SelectorType.Tag:
            return getNamespacedName(token);
        case SelectorType.PseudoElement:
            return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
        case SelectorType.Pseudo:
            return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${typeof token.data === "string"
                    ? escapeName(token.data, charsToEscapeInPseudoValue)
                    : stringify(token.data)})`}`;
        case SelectorType.Attribute: {
            if (token.name === "id" &&
                token.action === AttributeAction.Equals &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `#${escapeName(token.value, charsToEscapeInName)}`;
            }
            if (token.name === "class" &&
                token.action === AttributeAction.Element &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `.${escapeName(token.value, charsToEscapeInName)}`;
            }
            const name = getNamespacedName(token);
            if (token.action === AttributeAction.Exists) {
                return `[${name}]`;
            }
            return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
        }
    }
}
function getActionValue(action) {
    switch (action) {
        case AttributeAction.Equals:
            return "";
        case AttributeAction.Element:
            return "~";
        case AttributeAction.Start:
            return "^";
        case AttributeAction.End:
            return "$";
        case AttributeAction.Any:
            return "*";
        case AttributeAction.Not:
            return "!";
        case AttributeAction.Hyphen:
            return "|";
        case AttributeAction.Exists:
            throw new Error("Shouldn't be here");
    }
}
function getNamespacedName(token) {
    return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
    return namespace !== null
        ? `${namespace === "*"
            ? "*"
            : escapeName(namespace, charsToEscapeInName)}|`
        : "";
}
function escapeName(str, charsToEscape) {
    let lastIdx = 0;
    let ret = "";
    for (let i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
            ret += `${str.slice(lastIdx, i)}\\${str.charAt(i)}`;
            lastIdx = i + 1;
        }
    }
    return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}

const es = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  get AttributeAction () { return AttributeAction; },
  IgnoreCaseMode,
  get SelectorType () { return SelectorType; },
  isTraversal,
  parse: parse$6,
  stringify
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$1 = /*@__PURE__*/getAugmentedNamespace(es);

var sort = {};

var procedure = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isTraversal = exports.procedure = void 0;
	exports.procedure = {
	    universal: 50,
	    tag: 30,
	    attribute: 1,
	    pseudo: 0,
	    "pseudo-element": 0,
	    "column-combinator": -1,
	    descendant: -1,
	    child: -1,
	    parent: -1,
	    sibling: -1,
	    adjacent: -1,
	    _flexibleDescendant: -1,
	};
	function isTraversal(t) {
	    return exports.procedure[t.type] < 0;
	}
	exports.isTraversal = isTraversal;
} (procedure));

Object.defineProperty(sort, "__esModule", { value: true });
var css_what_1$2 = require$$0$1;
var procedure_1$1 = procedure;
var attributes$1 = {
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4,
};
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
            continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}
sort.default = sortByProcedure;
function getProcedure(token) {
    var proc = procedure_1$1.procedure[token.type];
    if (token.type === css_what_1$2.SelectorType.Attribute) {
        proc = attributes$1[token.action];
        if (proc === attributes$1.equals && token.name === "id") {
            // Prefer ID selectors (eg. #ID)
            proc = 9;
        }
        if (token.ignoreCase) {
            /*
             * IgnoreCase adds some overhead, prefer "normal" token
             * this is a binary operation, to ensure it's still an int
             */
            proc >>= 1;
        }
    }
    else if (token.type === css_what_1$2.SelectorType.Pseudo) {
        if (!token.data) {
            proc = 3;
        }
        else if (token.name === "has" || token.name === "contains") {
            proc = 0; // Expensive in any case
        }
        else if (Array.isArray(token.data)) {
            // "matches" and "not"
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                // TODO better handling of complex selectors
                if (token.data[i].length !== 1)
                    continue;
                var cur = getProcedure(token.data[i][0]);
                // Avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc)
                    proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
                proc -= 1;
        }
        else {
            proc = 1;
        }
    }
    return proc;
}

var general = {};

var attributes = {};

Object.defineProperty(attributes, "__esModule", { value: true });
attributes.attributeRules = void 0;
var boolbase_1$2 = boolbase;
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
}
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink",
]);
function shouldIgnoreCase(selector, options) {
    return typeof selector.ignoreCase === "boolean"
        ? selector.ignoreCase
        : selector.ignoreCase === "quirks"
            ? !!options.quirksMode
            : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
/**
 * Attribute selectors
 */
attributes.attributeRules = {
    equals: function (next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length === value.length &&
                    attr.toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function (next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len) === value &&
                next(elem));
        };
    },
    element: function (next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
            return boolbase_1$2.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                attr.length >= value.length &&
                regex.test(attr) &&
                next(elem));
        };
    },
    exists: function (next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
    },
    start: function (next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= len &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                next(elem);
        };
    },
    end: function (next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
                var _a;
                return ((_a = adapter
                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                next(elem);
        };
    },
    any: function (next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
            return boolbase_1$2.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= value.length &&
                    regex_1.test(attr) &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                next(elem);
        };
    },
    not: function (next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
            return function (elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        }
        else if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return ((attr == null ||
                    attr.length !== value.length ||
                    attr.toLowerCase() !== value) &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    },
};

var pseudoSelectors = {};

var filters$1 = {};

var lib$2 = {};

var parse$5 = {};

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(parse$5, "__esModule", { value: true });
parse$5.parse = void 0;
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
var whitespace = new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse$4(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
        return [2, 0];
    }
    else if (formula === "odd") {
        return [2, 1];
    }
    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    var idx = 0;
    var a = 0;
    var sign = readSign();
    var number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
        }
        else {
            sign = number = 0;
        }
    }
    // Throw if there is anything else
    if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
    }
    return [a, sign * number];
    function readSign() {
        if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
        }
        if (formula.charAt(idx) === "+") {
            idx++;
        }
        return 1;
    }
    function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length &&
            formula.charCodeAt(idx) >= ZERO &&
            formula.charCodeAt(idx) <= NINE) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
        }
        // Return `null` if we didn't read anything.
        return idx === start ? null : value;
    }
    function skipWhitespace() {
        while (idx < formula.length &&
            whitespace.has(formula.charCodeAt(idx))) {
            idx++;
        }
    }
}
parse$5.parse = parse$4;

var compile$2 = {};

var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(compile$2, "__esModule", { value: true });
compile$2.generate = compile$2.compile = void 0;
var boolbase_1$1 = __importDefault$1(boolbase);
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 *
 * ```js
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 * ```
 */
function compile$1(parsed) {
    var a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    var b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */
    if (b < 0 && a <= 0)
        return boolbase_1$1.default.falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1)
        return function (index) { return index <= b; };
    if (a === 0)
        return function (index) { return index === b; };
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1)
        return b < 0 ? boolbase_1$1.default.trueFunc : function (index) { return index >= b; };
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */
    var absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    var bMod = ((b % absA) + absA) % absA;
    return a > 1
        ? function (index) { return index >= b && index % absA === bMod; }
        : function (index) { return index <= b && index % absA === bMod; };
}
compile$2.compile = compile$1;
/**
 * Returns a function that produces a monotonously increasing sequence of indices.
 *
 * If the sequence has an end, the returned function will return `null` after
 * the last index in the sequence.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A function that produces a sequence of indices.
 * @example <caption>Always increasing (2n+3)</caption>
 *
 * ```js
 * const gen = nthCheck.generate([2, 3])
 *
 * gen() // `1`
 * gen() // `3`
 * gen() // `5`
 * gen() // `8`
 * gen() // `11`
 * ```
 *
 * @example <caption>With end value (-2n+10)</caption>
 *
 * ```js
 *
 * const gen = nthCheck.generate([-2, 5]);
 *
 * gen() // 0
 * gen() // 2
 * gen() // 4
 * gen() // null
 * ```
 */
function generate$9(parsed) {
    var a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    var b = parsed[1] - 1;
    var n = 0;
    // Make sure to always return an increasing sequence
    if (a < 0) {
        var aPos_1 = -a;
        // Get `b mod a`
        var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;
        return function () {
            var val = minValue_1 + aPos_1 * n++;
            return val > b ? null : val;
        };
    }
    if (a === 0)
        return b < 0
            ? // There are no result â€” always return `null`
                function () { return null; }
            : // Return `b` exactly once
                function () { return (n++ === 0 ? b : null); };
    if (b < 0) {
        b += a * Math.ceil(-b / a);
    }
    return function () { return a * n++ + b; };
}
compile$2.generate = generate$9;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
	var parse_js_1 = parse$5;
	Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parse_js_1.parse; } });
	var compile_js_1 = compile$2;
	Object.defineProperty(exports, "compile", { enumerable: true, get: function () { return compile_js_1.compile; } });
	Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return compile_js_1.generate; } });
	/**
	 * Parses and compiles a formula to a highly optimized function.
	 * Combination of {@link parse} and {@link compile}.
	 *
	 * If the formula doesn't match any elements,
	 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
	 * Otherwise, a function accepting an _index_ is returned, which returns
	 * whether or not the passed _index_ matches the formula.
	 *
	 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
	 *
	 * @param formula The formula to compile.
	 * @example
	 * const check = nthCheck("2n+3");
	 *
	 * check(0); // `false`
	 * check(1); // `false`
	 * check(2); // `true`
	 * check(3); // `false`
	 * check(4); // `true`
	 * check(5); // `false`
	 * check(6); // `true`
	 */
	function nthCheck(formula) {
	    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
	}
	exports.default = nthCheck;
	/**
	 * Parses and compiles a formula to a generator that produces a sequence of indices.
	 * Combination of {@link parse} and {@link generate}.
	 *
	 * @param formula The formula to compile.
	 * @returns A function that produces a sequence of indices.
	 * @example <caption>Always increasing</caption>
	 *
	 * ```js
	 * const gen = nthCheck.sequence('2n+3')
	 *
	 * gen() // `1`
	 * gen() // `3`
	 * gen() // `5`
	 * gen() // `8`
	 * gen() // `11`
	 * ```
	 *
	 * @example <caption>With end value</caption>
	 *
	 * ```js
	 *
	 * const gen = nthCheck.sequence('-2n+5');
	 *
	 * gen() // 0
	 * gen() // 2
	 * gen() // 4
	 * gen() // null
	 * ```
	 */
	function sequence(formula) {
	    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
	}
	exports.sequence = sequence;
	
} (lib$2));

(function (exports) {
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.filters = void 0;
	var nth_check_1 = __importDefault(lib$2);
	var boolbase_1 = boolbase;
	function getChildFunc(next, adapter) {
	    return function (elem) {
	        var parent = adapter.getParent(elem);
	        return parent != null && adapter.isTag(parent) && next(elem);
	    };
	}
	exports.filters = {
	    contains: function (next, text, _a) {
	        var adapter = _a.adapter;
	        return function contains(elem) {
	            return next(elem) && adapter.getText(elem).includes(text);
	        };
	    },
	    icontains: function (next, text, _a) {
	        var adapter = _a.adapter;
	        var itext = text.toLowerCase();
	        return function icontains(elem) {
	            return (next(elem) &&
	                adapter.getText(elem).toLowerCase().includes(itext));
	        };
	    },
	    // Location specific methods
	    "nth-child": function (next, rule, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var func = (0, nth_check_1.default)(rule);
	        if (func === boolbase_1.falseFunc)
	            return boolbase_1.falseFunc;
	        if (func === boolbase_1.trueFunc)
	            return getChildFunc(next, adapter);
	        return function nthChild(elem) {
	            var siblings = adapter.getSiblings(elem);
	            var pos = 0;
	            for (var i = 0; i < siblings.length; i++) {
	                if (equals(elem, siblings[i]))
	                    break;
	                if (adapter.isTag(siblings[i])) {
	                    pos++;
	                }
	            }
	            return func(pos) && next(elem);
	        };
	    },
	    "nth-last-child": function (next, rule, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var func = (0, nth_check_1.default)(rule);
	        if (func === boolbase_1.falseFunc)
	            return boolbase_1.falseFunc;
	        if (func === boolbase_1.trueFunc)
	            return getChildFunc(next, adapter);
	        return function nthLastChild(elem) {
	            var siblings = adapter.getSiblings(elem);
	            var pos = 0;
	            for (var i = siblings.length - 1; i >= 0; i--) {
	                if (equals(elem, siblings[i]))
	                    break;
	                if (adapter.isTag(siblings[i])) {
	                    pos++;
	                }
	            }
	            return func(pos) && next(elem);
	        };
	    },
	    "nth-of-type": function (next, rule, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var func = (0, nth_check_1.default)(rule);
	        if (func === boolbase_1.falseFunc)
	            return boolbase_1.falseFunc;
	        if (func === boolbase_1.trueFunc)
	            return getChildFunc(next, adapter);
	        return function nthOfType(elem) {
	            var siblings = adapter.getSiblings(elem);
	            var pos = 0;
	            for (var i = 0; i < siblings.length; i++) {
	                var currentSibling = siblings[i];
	                if (equals(elem, currentSibling))
	                    break;
	                if (adapter.isTag(currentSibling) &&
	                    adapter.getName(currentSibling) === adapter.getName(elem)) {
	                    pos++;
	                }
	            }
	            return func(pos) && next(elem);
	        };
	    },
	    "nth-last-of-type": function (next, rule, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var func = (0, nth_check_1.default)(rule);
	        if (func === boolbase_1.falseFunc)
	            return boolbase_1.falseFunc;
	        if (func === boolbase_1.trueFunc)
	            return getChildFunc(next, adapter);
	        return function nthLastOfType(elem) {
	            var siblings = adapter.getSiblings(elem);
	            var pos = 0;
	            for (var i = siblings.length - 1; i >= 0; i--) {
	                var currentSibling = siblings[i];
	                if (equals(elem, currentSibling))
	                    break;
	                if (adapter.isTag(currentSibling) &&
	                    adapter.getName(currentSibling) === adapter.getName(elem)) {
	                    pos++;
	                }
	            }
	            return func(pos) && next(elem);
	        };
	    },
	    // TODO determine the actual root element
	    root: function (next, _rule, _a) {
	        var adapter = _a.adapter;
	        return function (elem) {
	            var parent = adapter.getParent(elem);
	            return (parent == null || !adapter.isTag(parent)) && next(elem);
	        };
	    },
	    scope: function (next, rule, options, context) {
	        var equals = options.equals;
	        if (!context || context.length === 0) {
	            // Equivalent to :root
	            return exports.filters.root(next, rule, options);
	        }
	        if (context.length === 1) {
	            // NOTE: can't be unpacked, as :has uses this for side-effects
	            return function (elem) { return equals(context[0], elem) && next(elem); };
	        }
	        return function (elem) { return context.includes(elem) && next(elem); };
	    },
	    hover: dynamicStatePseudo("isHovered"),
	    visited: dynamicStatePseudo("isVisited"),
	    active: dynamicStatePseudo("isActive"),
	};
	/**
	 * Dynamic state pseudos. These depend on optional Adapter methods.
	 *
	 * @param name The name of the adapter method to call.
	 * @returns Pseudo for the `filters` object.
	 */
	function dynamicStatePseudo(name) {
	    return function dynamicPseudo(next, _rule, _a) {
	        var adapter = _a.adapter;
	        var func = adapter[name];
	        if (typeof func !== "function") {
	            return boolbase_1.falseFunc;
	        }
	        return function active(elem) {
	            return func(elem) && next(elem);
	        };
	    };
	}
} (filters$1));

var pseudos = {};

Object.defineProperty(pseudos, "__esModule", { value: true });
pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
pseudos.pseudos = {
    empty: function (elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function (elem) {
            // FIXME: `getText` call is potentially expensive.
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
        });
    },
    "first-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter
            .getSiblings(elem)
            .find(function (elem) { return adapter.isTag(elem); });
        return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
                return true;
            if (adapter.isTag(siblings[i]))
                break;
        }
        return false;
    },
    "first-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "last-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "only-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter
            .getSiblings(elem)
            .every(function (sibling) {
            return equals(elem, sibling) ||
                !adapter.isTag(sibling) ||
                adapter.getName(sibling) !== elemName;
        });
    },
    "only-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter
            .getSiblings(elem)
            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
    },
};
function verifyPseudoArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2) {
            throw new Error("pseudo-selector :".concat(name, " requires an argument"));
        }
    }
    else if (func.length === 2) {
        throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
    }
}
pseudos.verifyPseudoArgs = verifyPseudoArgs;

var aliases = {};

Object.defineProperty(aliases, "__esModule", { value: true });
aliases.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
aliases.aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])",
};

var subselects = {};

(function (exports) {
	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
	var boolbase_1 = boolbase;
	var procedure_1 = procedure;
	/** Used as a placeholder for :has. Will be replaced with the actual element. */
	exports.PLACEHOLDER_ELEMENT = {};
	function ensureIsTag(next, adapter) {
	    if (next === boolbase_1.falseFunc)
	        return boolbase_1.falseFunc;
	    return function (elem) { return adapter.isTag(elem) && next(elem); };
	}
	exports.ensureIsTag = ensureIsTag;
	function getNextSiblings(elem, adapter) {
	    var siblings = adapter.getSiblings(elem);
	    if (siblings.length <= 1)
	        return [];
	    var elemIndex = siblings.indexOf(elem);
	    if (elemIndex < 0 || elemIndex === siblings.length - 1)
	        return [];
	    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
	}
	exports.getNextSiblings = getNextSiblings;
	var is = function (next, token, options, context, compileToken) {
	    var opts = {
	        xmlMode: !!options.xmlMode,
	        adapter: options.adapter,
	        equals: options.equals,
	    };
	    var func = compileToken(token, opts, context);
	    return function (elem) { return func(elem) && next(elem); };
	};
	/*
	 * :not, :has, :is, :matches and :where have to compile selectors
	 * doing this in src/pseudos.ts would lead to circular dependencies,
	 * so we add them here
	 */
	exports.subselects = {
	    is: is,
	    /**
	     * `:matches` and `:where` are aliases for `:is`.
	     */
	    matches: is,
	    where: is,
	    not: function (next, token, options, context, compileToken) {
	        var opts = {
	            xmlMode: !!options.xmlMode,
	            adapter: options.adapter,
	            equals: options.equals,
	        };
	        var func = compileToken(token, opts, context);
	        if (func === boolbase_1.falseFunc)
	            return next;
	        if (func === boolbase_1.trueFunc)
	            return boolbase_1.falseFunc;
	        return function not(elem) {
	            return !func(elem) && next(elem);
	        };
	    },
	    has: function (next, subselect, options, _context, compileToken) {
	        var adapter = options.adapter;
	        var opts = {
	            xmlMode: !!options.xmlMode,
	            adapter: adapter,
	            equals: options.equals,
	        };
	        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
	        var context = subselect.some(function (s) {
	            return s.some(procedure_1.isTraversal);
	        })
	            ? [exports.PLACEHOLDER_ELEMENT]
	            : undefined;
	        var compiled = compileToken(subselect, opts, context);
	        if (compiled === boolbase_1.falseFunc)
	            return boolbase_1.falseFunc;
	        if (compiled === boolbase_1.trueFunc) {
	            return function (elem) {
	                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
	            };
	        }
	        var hasElement = ensureIsTag(compiled, adapter);
	        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
	        /*
	         * `shouldTestNextSiblings` will only be true if the query starts with
	         * a traversal (sibling or adjacent). That means we will always have a context.
	         */
	        if (context) {
	            return function (elem) {
	                context[0] = elem;
	                var childs = adapter.getChildren(elem);
	                var nextElements = shouldTestNextSiblings
	                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
	                return (next(elem) && adapter.existsOne(hasElement, nextElements));
	            };
	        }
	        return function (elem) {
	            return next(elem) &&
	                adapter.existsOne(hasElement, adapter.getChildren(elem));
	        };
	    },
	};
} (subselects));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
	/*
	 * Pseudo selectors
	 *
	 * Pseudo selectors are available in three forms:
	 *
	 * 1. Filters are called when the selector is compiled and return a function
	 *  that has to return either false, or the results of `next()`.
	 * 2. Pseudos are called on execution. They have to return a boolean.
	 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
	 *
	 * Filters are great if you want to do some pre-processing, or change the call order
	 * of `next()` and your code.
	 * Pseudos should be used to implement simple checks.
	 */
	var boolbase_1 = boolbase;
	var css_what_1 = require$$0$1;
	var filters_1 = filters$1;
	Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return filters_1.filters; } });
	var pseudos_1 = pseudos;
	Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudos_1.pseudos; } });
	var aliases_1 = aliases;
	Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return aliases_1.aliases; } });
	var subselects_1 = subselects;
	function compilePseudoSelector(next, selector, options, context, compileToken) {
	    var name = selector.name, data = selector.data;
	    if (Array.isArray(data)) {
	        return subselects_1.subselects[name](next, data, options, context, compileToken);
	    }
	    if (name in aliases_1.aliases) {
	        if (data != null) {
	            throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
	        }
	        // The alias has to be parsed here, to make sure options are respected.
	        var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
	        return subselects_1.subselects.is(next, alias, options, context, compileToken);
	    }
	    if (name in filters_1.filters) {
	        return filters_1.filters[name](next, data, options, context);
	    }
	    if (name in pseudos_1.pseudos) {
	        var pseudo_1 = pseudos_1.pseudos[name];
	        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
	        return pseudo_1 === boolbase_1.falseFunc
	            ? boolbase_1.falseFunc
	            : next === boolbase_1.trueFunc
	                ? function (elem) { return pseudo_1(elem, options, data); }
	                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
	    }
	    throw new Error("unmatched pseudo-class :".concat(name));
	}
	exports.compilePseudoSelector = compilePseudoSelector;
} (pseudoSelectors));

Object.defineProperty(general, "__esModule", { value: true });
general.compileGeneralSelector = void 0;
var attributes_1 = attributes;
var pseudo_selectors_1 = pseudoSelectors;
var css_what_1$1 = require$$0$1;
/*
 * All available rules
 */
function compileGeneralSelector(next, selector, options, context, compileToken) {
    var adapter = options.adapter, equals = options.equals;
    switch (selector.type) {
        case css_what_1$1.SelectorType.PseudoElement: {
            throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1$1.SelectorType.ColumnCombinator: {
            throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1$1.SelectorType.Attribute: {
            if (selector.namespace != null) {
                throw new Error("Namespaced attributes are not yet supported by css-select");
            }
            if (!options.xmlMode || options.lowerCaseAttributeNames) {
                selector.name = selector.name.toLowerCase();
            }
            return attributes_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1$1.SelectorType.Pseudo: {
            return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        }
        // Tags
        case css_what_1$1.SelectorType.Tag: {
            if (selector.namespace != null) {
                throw new Error("Namespaced tag names are not yet supported by css-select");
            }
            var name_1 = selector.name;
            if (!options.xmlMode || options.lowerCaseTags) {
                name_1 = name_1.toLowerCase();
            }
            return function tag(elem) {
                return adapter.getName(elem) === name_1 && next(elem);
            };
        }
        // Traversal
        case css_what_1$1.SelectorType.Descendant: {
            if (options.cacheResults === false ||
                typeof WeakSet === "undefined") {
                return function descendant(elem) {
                    var current = elem;
                    while ((current = adapter.getParent(current))) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            // @ts-expect-error `ElementNode` is not extending object
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
                var current = elem;
                while ((current = adapter.getParent(current))) {
                    if (!isFalseCache_1.has(current)) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                        isFalseCache_1.add(current);
                    }
                }
                return false;
            };
        }
        case "_flexibleDescendant": {
            // Include element itself, only used while querying an array
            return function flexibleDescendant(elem) {
                var current = elem;
                do {
                    if (adapter.isTag(current) && next(current))
                        return true;
                } while ((current = adapter.getParent(current)));
                return false;
            };
        }
        case css_what_1$1.SelectorType.Parent: {
            return function parent(elem) {
                return adapter
                    .getChildren(elem)
                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
            };
        }
        case css_what_1$1.SelectorType.Child: {
            return function child(elem) {
                var parent = adapter.getParent(elem);
                return parent != null && adapter.isTag(parent) && next(parent);
            };
        }
        case css_what_1$1.SelectorType.Sibling: {
            return function sibling(elem) {
                var siblings = adapter.getSiblings(elem);
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
                        return true;
                    }
                }
                return false;
            };
        }
        case css_what_1$1.SelectorType.Adjacent: {
            if (adapter.prevElementSibling) {
                return function adjacent(elem) {
                    var previous = adapter.prevElementSibling(elem);
                    return previous != null && next(previous);
                };
            }
            return function adjacent(elem) {
                var siblings = adapter.getSiblings(elem);
                var lastElement;
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling)) {
                        lastElement = currentSibling;
                    }
                }
                return !!lastElement && next(lastElement);
            };
        }
        case css_what_1$1.SelectorType.Universal: {
            if (selector.namespace != null && selector.namespace !== "*") {
                throw new Error("Namespaced universal selectors are not yet supported by css-select");
            }
            return next;
        }
    }
}
general.compileGeneralSelector = compileGeneralSelector;

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(compile$3, "__esModule", { value: true });
compile$3.compileToken = compile$3.compileUnsafe = compile$3.compile = void 0;
var css_what_1 = require$$0$1;
var boolbase_1 = boolbase;
var sort_1 = __importDefault(sort);
var procedure_1 = procedure;
var general_1 = general;
var subselects_1 = subselects;
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return (0, subselects_1.ensureIsTag)(next, options.adapter);
}
compile$3.compile = compile;
function compileUnsafe(selector, options, context) {
    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
    return compileToken(token, options, context);
}
compile$3.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
    return (t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant",
};
var SCOPE_TOKEN = {
    type: css_what_1.SelectorType.Pseudo,
    name: "scope",
    data: null,
};
/*
 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
    var adapter = _a.adapter;
    // TODO Use better check if the context is a document
    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
    }));
    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") ;
        else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
        }
        else {
            continue;
        }
        t.unshift(SCOPE_TOKEN);
    }
}
function compileToken(token, options, context) {
    var _a;
    token = token.filter(function (t) { return t.length > 0; });
    token.forEach(sort_1.default);
    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    absolutize(token, options, finalContext);
    var shouldTestNextSiblings = false;
    var query = token
        .map(function (rules) {
        if (rules.length >= 2) {
            var first = rules[0], second = rules[1];
            if (first.type !== "pseudo" || first.name !== "scope") ;
            else if (isArrayContext && second.type === "descendant") {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            }
            else if (second.type === "adjacent" ||
                second.type === "sibling") {
                shouldTestNextSiblings = true;
            }
        }
        return compileRules(rules, options, finalContext);
    })
        .reduce(reduceRules, boolbase_1.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
}
compile$3.compileToken = compileToken;
function compileRules(rules, options, context) {
    var _a;
    return rules.reduce(function (previous, rule) {
        return previous === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
}
function reduceRules(a, b) {
    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
        return a;
    }
    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
        return b;
    }
    return function combine(elem) {
        return a(elem) || b(elem);
    };
}

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
	var DomUtils = __importStar(lib$7);
	var boolbase_1 = boolbase;
	var compile_1 = compile$3;
	var subselects_1 = subselects;
	var defaultEquals = function (a, b) { return a === b; };
	var defaultOptions = {
	    adapter: DomUtils,
	    equals: defaultEquals,
	};
	function convertOptionFormats(options) {
	    var _a, _b, _c, _d;
	    /*
	     * We force one format of options to the other one.
	     */
	    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
	    var opts = options !== null && options !== void 0 ? options : defaultOptions;
	    // @ts-expect-error Same as above.
	    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
	    // @ts-expect-error `equals` does not exist on `Options`
	    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
	    return opts;
	}
	function wrapCompile(func) {
	    return function addAdapter(selector, options, context) {
	        var opts = convertOptionFormats(options);
	        return func(selector, opts, context);
	    };
	}
	/**
	 * Compiles the query, returns a function.
	 */
	exports.compile = wrapCompile(compile_1.compile);
	exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
	exports._compileToken = wrapCompile(compile_1.compileToken);
	function getSelectorFunc(searchFunc) {
	    return function select(query, elements, options) {
	        var opts = convertOptionFormats(options);
	        if (typeof query !== "function") {
	            query = (0, compile_1.compileUnsafe)(query, opts, elements);
	        }
	        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
	        return searchFunc(query, filteredElements, opts);
	    };
	}
	function prepareContext(elems, adapter, shouldTestNextSiblings) {
	    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
	    /*
	     * Add siblings if the query requires them.
	     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
	     */
	    if (shouldTestNextSiblings) {
	        elems = appendNextSiblings(elems, adapter);
	    }
	    return Array.isArray(elems)
	        ? adapter.removeSubsets(elems)
	        : adapter.getChildren(elems);
	}
	exports.prepareContext = prepareContext;
	function appendNextSiblings(elem, adapter) {
	    // Order matters because jQuery seems to check the children before the siblings
	    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
	    var elemsLength = elems.length;
	    for (var i = 0; i < elemsLength; i++) {
	        var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
	        elems.push.apply(elems, nextSiblings);
	    }
	    return elems;
	}
	/**
	 * @template Node The generic Node type for the DOM adapter being used.
	 * @template ElementNode The Node type for elements for the DOM adapter being used.
	 * @param elems Elements to query. If it is an element, its children will be queried..
	 * @param query can be either a CSS selector string or a compiled query function.
	 * @param [options] options for querying the document.
	 * @see compile for supported selector queries.
	 * @returns All matching elements.
	 *
	 */
	exports.selectAll = getSelectorFunc(function (query, elems, options) {
	    return query === boolbase_1.falseFunc || !elems || elems.length === 0
	        ? []
	        : options.adapter.findAll(query, elems);
	});
	/**
	 * @template Node The generic Node type for the DOM adapter being used.
	 * @template ElementNode The Node type for elements for the DOM adapter being used.
	 * @param elems Elements to query. If it is an element, its children will be queried..
	 * @param query can be either a CSS selector string or a compiled query function.
	 * @param [options] options for querying the document.
	 * @see compile for supported selector queries.
	 * @returns the first match, or null if there was no match.
	 */
	exports.selectOne = getSelectorFunc(function (query, elems, options) {
	    return query === boolbase_1.falseFunc || !elems || elems.length === 0
	        ? null
	        : options.adapter.findOne(query, elems);
	});
	/**
	 * Tests whether or not an element is matched by query.
	 *
	 * @template Node The generic Node type for the DOM adapter being used.
	 * @template ElementNode The Node type for elements for the DOM adapter being used.
	 * @param elem The element to test if it matches the query.
	 * @param query can be either a CSS selector string or a compiled query function.
	 * @param [options] options for querying the document.
	 * @see compile for supported selector queries.
	 * @returns
	 */
	function is(elem, query, options) {
	    var opts = convertOptionFormats(options);
	    return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
	}
	exports.is = is;
	/**
	 * Alias for selectAll(query, elems, options).
	 * @see [compile] for supported selector queries.
	 */
	exports.default = exports.selectAll;
	// Export filters, pseudos and aliases to allow users to supply their own.
	var pseudo_selectors_1 = pseudoSelectors;
	Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return pseudo_selectors_1.filters; } });
	Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } });
	Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return pseudo_selectors_1.aliases; } });
} (lib$8));

const isTag = (node) => {
  return node.type === 'element';
};

const existsOne = (test, elems) => {
  return elems.some((elem) => {
    if (isTag(elem)) {
      return test(elem) || existsOne(test, getChildren(elem));
    } else {
      return false;
    }
  });
};

const getAttributeValue = (elem, name) => {
  return elem.attributes[name];
};

const getChildren = (node) => {
  return node.children || [];
};

const getName = (elemAst) => {
  return elemAst.name;
};

const getParent = (node) => {
  return node.parentNode || null;
};

const getSiblings = (elem) => {
  var parent = getParent(elem);
  return parent ? getChildren(parent) : [];
};

const getText = (node) => {
  if (node.children[0].type === 'text' && node.children[0].type === 'cdata') {
    return node.children[0].value;
  }
  return '';
};

const hasAttrib = (elem, name) => {
  return elem.attributes[name] !== undefined;
};

const removeSubsets = (nodes) => {
  let idx = nodes.length;
  let node;
  let ancestor;
  let replace;
  // Check if each node (or one of its ancestors) is already contained in the
  // array.
  while (--idx > -1) {
    node = ancestor = nodes[idx];
    // Temporarily remove the node under consideration
    nodes[idx] = null;
    replace = true;
    while (ancestor) {
      if (nodes.includes(ancestor)) {
        replace = false;
        nodes.splice(idx, 1);
        break;
      }
      ancestor = getParent(ancestor);
    }
    // If the node has been found to be unique, re-insert it.
    if (replace) {
      nodes[idx] = node;
    }
  }
  return nodes;
};

const findAll = (test, elems) => {
  const result = [];
  for (const elem of elems) {
    if (isTag(elem)) {
      if (test(elem)) {
        result.push(elem);
      }
      result.push(...findAll(test, getChildren(elem)));
    }
  }
  return result;
};

const findOne = (test, elems) => {
  for (const elem of elems) {
    if (isTag(elem)) {
      if (test(elem)) {
        return elem;
      }
      const result = findOne(test, getChildren(elem));
      if (result) {
        return result;
      }
    }
  }
  return null;
};

const svgoCssSelectAdapter$1 = {
  isTag,
  existsOne,
  getAttributeValue,
  getChildren,
  getName,
  getParent,
  getSiblings,
  getText,
  hasAttrib,
  removeSubsets,
  findAll,
  findOne,
};

var cssSelectAdapter = svgoCssSelectAdapter$1;

/**
 * @typedef {import('./types').XastNode} XastNode
 * @typedef {import('./types').XastChild} XastChild
 * @typedef {import('./types').XastParent} XastParent
 * @typedef {import('./types').Visitor} Visitor
 */

const { selectAll: selectAll$1, selectOne: selectOne$1, is: is$1 } = lib$8;
const xastAdaptor = cssSelectAdapter;

const cssSelectOptions = {
  xmlMode: true,
  adapter: xastAdaptor,
};

/**
 * @type {(node: XastNode, selector: string) => Array<XastChild>}
 */
const querySelectorAll$2 = (node, selector) => {
  return selectAll$1(selector, node, cssSelectOptions);
};
xast.querySelectorAll = querySelectorAll$2;

/**
 * @type {(node: XastNode, selector: string) => null | XastChild}
 */
const querySelector$1 = (node, selector) => {
  return selectOne$1(selector, node, cssSelectOptions);
};
xast.querySelector = querySelector$1;

/**
 * @type {(node: XastChild, selector: string) => boolean}
 */
const matches$2 = (node, selector) => {
  return is$1(node, selector, cssSelectOptions);
};
xast.matches = matches$2;

/**
 * @type {(node: XastChild, name: string) => null | XastChild}
 */
const closestByName$1 = (node, name) => {
  let currentNode = node;
  while (currentNode) {
    if (currentNode.type === 'element' && currentNode.name === name) {
      return currentNode;
    }
    // @ts-ignore parentNode is hidden from public usage
    currentNode = currentNode.parentNode;
  }
  return null;
};
xast.closestByName = closestByName$1;

const visitSkip$6 = Symbol();
xast.visitSkip = visitSkip$6;

/**
 * @type {(node: XastNode, visitor: Visitor, parentNode?: any) => void}
 */
const visit$5 = (node, visitor, parentNode) => {
  const callbacks = visitor[node.type];
  if (callbacks && callbacks.enter) {
    // @ts-ignore hard to infer
    const symbol = callbacks.enter(node, parentNode);
    if (symbol === visitSkip$6) {
      return;
    }
  }
  // visit root children
  if (node.type === 'root') {
    // copy children array to not loose cursor when children is spliced
    for (const child of node.children) {
      visit$5(child, visitor, node);
    }
  }
  // visit element children if still attached to parent
  if (node.type === 'element') {
    if (parentNode.children.includes(node)) {
      for (const child of node.children) {
        visit$5(child, visitor, node);
      }
    }
  }
  if (callbacks && callbacks.exit) {
    // @ts-ignore hard to infer
    callbacks.exit(node, parentNode);
  }
};
xast.visit = visit$5;

/**
 * @type {(node: XastChild, parentNode: XastParent) => void}
 */
const detachNodeFromParent$m = (node, parentNode) => {
  // avoid splice to not break for loops
  parentNode.children = parentNode.children.filter((child) => child !== node);
};
xast.detachNodeFromParent = detachNodeFromParent$m;

const { visit: visit$4 } = xast;

/**
 * Plugins engine.
 *
 * @module plugins
 *
 * @param {Object} ast input ast
 * @param {Object} info extra information
 * @param {Array} plugins plugins object from config
 * @return {Object} output ast
 */
const invokePlugins$1 = (ast, info, plugins, overrides, globalOverrides) => {
  for (const plugin of plugins) {
    const override = overrides == null ? null : overrides[plugin.name];
    if (override === false) {
      continue;
    }
    const params = { ...plugin.params, ...globalOverrides, ...override };

    if (plugin.type === 'perItem') {
      ast = perItem(ast, info, plugin, params);
    }
    if (plugin.type === 'perItemReverse') {
      ast = perItem(ast, info, plugin, params, true);
    }
    if (plugin.type === 'full') {
      if (plugin.active) {
        ast = plugin.fn(ast, params, info);
      }
    }
    if (plugin.type === 'visitor') {
      if (plugin.active) {
        const visitor = plugin.fn(ast, params, info);
        if (visitor != null) {
          visit$4(ast, visitor);
        }
      }
    }
  }
  return ast;
};
plugins.invokePlugins = invokePlugins$1;

/**
 * Direct or reverse per-item loop.
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins list to process
 * @param {boolean} [reverse] reverse pass?
 * @return {Object} output data
 */
function perItem(data, info, plugin, params, reverse) {
  function monkeys(items) {
    items.children = items.children.filter(function (item) {
      // reverse pass
      if (reverse && item.children) {
        monkeys(item);
      }
      // main filter
      let kept = true;
      if (plugin.active) {
        kept = plugin.fn(item, params, info) !== false;
      }
      // direct pass
      if (!reverse && item.children) {
        monkeys(item);
      }
      return kept;
    });
    return items;
  }
  return monkeys(data);
}

const createPreset$1 = ({ name, plugins }) => {
  return {
    name,
    type: 'full',
    fn: (ast, params, info) => {
      const { floatPrecision, overrides } = params;
      const globalOverrides = {};
      if (floatPrecision != null) {
        globalOverrides.floatPrecision = floatPrecision;
      }
      if (overrides) {
        for (const [pluginName, override] of Object.entries(overrides)) {
          if (override === true) {
            console.warn(
              `You are trying to enable ${pluginName} which is not part of preset.\n` +
                `Try to put it before or after preset, for example\n\n` +
                `plugins: [\n` +
                `  {\n` +
                `    name: 'preset-default',\n` +
                `  },\n` +
                `  'cleanupListOfValues'\n` +
                `]\n`
            );
          }
        }
      }
      return invokePlugins$1(ast, info, plugins, overrides, globalOverrides);
    },
  };
};
plugins.createPreset = createPreset$1;

var removeDoctype$1 = {};

const { detachNodeFromParent: detachNodeFromParent$l } = xast;

removeDoctype$1.name = 'removeDoctype';
removeDoctype$1.type = 'visitor';
removeDoctype$1.active = true;
removeDoctype$1.description = 'removes doctype declaration';

/**
 * Remove DOCTYPE declaration.
 *
 * "Unfortunately the SVG DTDs are a source of so many
 * issues that the SVG WG has decided not to write one
 * for the upcoming SVG 1.2 standard. In fact SVG WG
 * members are even telling people not to use a DOCTYPE
 * declaration in SVG 1.0 and 1.1 documents"
 * https://jwatt.org/svg/authoring/#doctype-declaration
 *
 * @example
 * <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 * q"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 *
 * @example
 * <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 * "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" [
 *     <!-- an internal subset can be embedded here -->
 * ]>
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeDoctype$1.fn = () => {
  return {
    doctype: {
      enter: (node, parentNode) => {
        detachNodeFromParent$l(node, parentNode);
      },
    },
  };
};

var removeXMLProcInst$1 = {};

const { detachNodeFromParent: detachNodeFromParent$k } = xast;

removeXMLProcInst$1.name = 'removeXMLProcInst';
removeXMLProcInst$1.type = 'visitor';
removeXMLProcInst$1.active = true;
removeXMLProcInst$1.description = 'removes XML processing instructions';

/**
 * Remove XML Processing Instruction.
 *
 * @example
 * <?xml version="1.0" encoding="utf-8"?>
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeXMLProcInst$1.fn = () => {
  return {
    instruction: {
      enter: (node, parentNode) => {
        if (node.name === 'xml') {
          detachNodeFromParent$k(node, parentNode);
        }
      },
    },
  };
};

var removeComments$1 = {};

const { detachNodeFromParent: detachNodeFromParent$j } = xast;

removeComments$1.name = 'removeComments';
removeComments$1.type = 'visitor';
removeComments$1.active = true;
removeComments$1.description = 'removes comments';

/**
 * Remove comments.
 *
 * @example
 * <!-- Generator: Adobe Illustrator 15.0.0, SVG Export
 * Plug-In . SVG Version: 6.00 Build 0)  -->
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeComments$1.fn = () => {
  return {
    comment: {
      enter: (node, parentNode) => {
        if (node.value.charAt(0) !== '!') {
          detachNodeFromParent$j(node, parentNode);
        }
      },
    },
  };
};

var removeMetadata$1 = {};

const { detachNodeFromParent: detachNodeFromParent$i } = xast;

removeMetadata$1.name = 'removeMetadata';
removeMetadata$1.type = 'visitor';
removeMetadata$1.active = true;
removeMetadata$1.description = 'removes <metadata>';

/**
 * Remove <metadata>.
 *
 * https://www.w3.org/TR/SVG11/metadata.html
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeMetadata$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'metadata') {
          detachNodeFromParent$i(node, parentNode);
        }
      },
    },
  };
};

var removeEditorsNSData$1 = {};

var _collections = {};

(function (exports) {

	// https://www.w3.org/TR/SVG11/intro.html#Definitions

	/**
	 * @type {Record<string, Array<string>>}
	 */
	exports.elemsGroups = {
	  animation: [
	    'animate',
	    'animateColor',
	    'animateMotion',
	    'animateTransform',
	    'set',
	  ],
	  descriptive: ['desc', 'metadata', 'title'],
	  shape: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'],
	  structural: ['defs', 'g', 'svg', 'symbol', 'use'],
	  paintServer: [
	    'solidColor',
	    'linearGradient',
	    'radialGradient',
	    'meshGradient',
	    'pattern',
	    'hatch',
	  ],
	  nonRendering: [
	    'linearGradient',
	    'radialGradient',
	    'pattern',
	    'clipPath',
	    'mask',
	    'marker',
	    'symbol',
	    'filter',
	    'solidColor',
	  ],
	  container: [
	    'a',
	    'defs',
	    'g',
	    'marker',
	    'mask',
	    'missing-glyph',
	    'pattern',
	    'svg',
	    'switch',
	    'symbol',
	    'foreignObject',
	  ],
	  textContent: [
	    'altGlyph',
	    'altGlyphDef',
	    'altGlyphItem',
	    'glyph',
	    'glyphRef',
	    'textPath',
	    'text',
	    'tref',
	    'tspan',
	  ],
	  textContentChild: ['altGlyph', 'textPath', 'tref', 'tspan'],
	  lightSource: [
	    'feDiffuseLighting',
	    'feSpecularLighting',
	    'feDistantLight',
	    'fePointLight',
	    'feSpotLight',
	  ],
	  filterPrimitive: [
	    'feBlend',
	    'feColorMatrix',
	    'feComponentTransfer',
	    'feComposite',
	    'feConvolveMatrix',
	    'feDiffuseLighting',
	    'feDisplacementMap',
	    'feDropShadow',
	    'feFlood',
	    'feFuncA',
	    'feFuncB',
	    'feFuncG',
	    'feFuncR',
	    'feGaussianBlur',
	    'feImage',
	    'feMerge',
	    'feMergeNode',
	    'feMorphology',
	    'feOffset',
	    'feSpecularLighting',
	    'feTile',
	    'feTurbulence',
	  ],
	};

	exports.textElems = exports.elemsGroups.textContent.concat('title');

	exports.pathElems = ['path', 'glyph', 'missing-glyph'];

	// https://www.w3.org/TR/SVG11/intro.html#Definitions
	/**
	 * @type {Record<string, Array<string>>}
	 */
	exports.attrsGroups = {
	  animationAddition: ['additive', 'accumulate'],
	  animationAttributeTarget: ['attributeType', 'attributeName'],
	  animationEvent: ['onbegin', 'onend', 'onrepeat', 'onload'],
	  animationTiming: [
	    'begin',
	    'dur',
	    'end',
	    'min',
	    'max',
	    'restart',
	    'repeatCount',
	    'repeatDur',
	    'fill',
	  ],
	  animationValue: [
	    'calcMode',
	    'values',
	    'keyTimes',
	    'keySplines',
	    'from',
	    'to',
	    'by',
	  ],
	  conditionalProcessing: [
	    'requiredFeatures',
	    'requiredExtensions',
	    'systemLanguage',
	  ],
	  core: ['id', 'tabindex', 'xml:base', 'xml:lang', 'xml:space'],
	  graphicalEvent: [
	    'onfocusin',
	    'onfocusout',
	    'onactivate',
	    'onclick',
	    'onmousedown',
	    'onmouseup',
	    'onmouseover',
	    'onmousemove',
	    'onmouseout',
	    'onload',
	  ],
	  presentation: [
	    'alignment-baseline',
	    'baseline-shift',
	    'clip',
	    'clip-path',
	    'clip-rule',
	    'color',
	    'color-interpolation',
	    'color-interpolation-filters',
	    'color-profile',
	    'color-rendering',
	    'cursor',
	    'direction',
	    'display',
	    'dominant-baseline',
	    'enable-background',
	    'fill',
	    'fill-opacity',
	    'fill-rule',
	    'filter',
	    'flood-color',
	    'flood-opacity',
	    'font-family',
	    'font-size',
	    'font-size-adjust',
	    'font-stretch',
	    'font-style',
	    'font-variant',
	    'font-weight',
	    'glyph-orientation-horizontal',
	    'glyph-orientation-vertical',
	    'image-rendering',
	    'letter-spacing',
	    'lighting-color',
	    'marker-end',
	    'marker-mid',
	    'marker-start',
	    'mask',
	    'opacity',
	    'overflow',
	    'paint-order',
	    'pointer-events',
	    'shape-rendering',
	    'stop-color',
	    'stop-opacity',
	    'stroke',
	    'stroke-dasharray',
	    'stroke-dashoffset',
	    'stroke-linecap',
	    'stroke-linejoin',
	    'stroke-miterlimit',
	    'stroke-opacity',
	    'stroke-width',
	    'text-anchor',
	    'text-decoration',
	    'text-overflow',
	    'text-rendering',
	    'transform',
	    'transform-origin',
	    'unicode-bidi',
	    'vector-effect',
	    'visibility',
	    'word-spacing',
	    'writing-mode',
	  ],
	  xlink: [
	    'xlink:href',
	    'xlink:show',
	    'xlink:actuate',
	    'xlink:type',
	    'xlink:role',
	    'xlink:arcrole',
	    'xlink:title',
	  ],
	  documentEvent: [
	    'onunload',
	    'onabort',
	    'onerror',
	    'onresize',
	    'onscroll',
	    'onzoom',
	  ],
	  filterPrimitive: ['x', 'y', 'width', 'height', 'result'],
	  transferFunction: [
	    'type',
	    'tableValues',
	    'slope',
	    'intercept',
	    'amplitude',
	    'exponent',
	    'offset',
	  ],
	};

	/**
	 * @type {Record<string, Record<string, string>>}
	 */
	exports.attrsGroupsDefaults = {
	  core: { 'xml:space': 'default' },
	  presentation: {
	    clip: 'auto',
	    'clip-path': 'none',
	    'clip-rule': 'nonzero',
	    mask: 'none',
	    opacity: '1',
	    'stop-color': '#000',
	    'stop-opacity': '1',
	    'fill-opacity': '1',
	    'fill-rule': 'nonzero',
	    fill: '#000',
	    stroke: 'none',
	    'stroke-width': '1',
	    'stroke-linecap': 'butt',
	    'stroke-linejoin': 'miter',
	    'stroke-miterlimit': '4',
	    'stroke-dasharray': 'none',
	    'stroke-dashoffset': '0',
	    'stroke-opacity': '1',
	    'paint-order': 'normal',
	    'vector-effect': 'none',
	    display: 'inline',
	    visibility: 'visible',
	    'marker-start': 'none',
	    'marker-mid': 'none',
	    'marker-end': 'none',
	    'color-interpolation': 'sRGB',
	    'color-interpolation-filters': 'linearRGB',
	    'color-rendering': 'auto',
	    'shape-rendering': 'auto',
	    'text-rendering': 'auto',
	    'image-rendering': 'auto',
	    'font-style': 'normal',
	    'font-variant': 'normal',
	    'font-weight': 'normal',
	    'font-stretch': 'normal',
	    'font-size': 'medium',
	    'font-size-adjust': 'none',
	    kerning: 'auto',
	    'letter-spacing': 'normal',
	    'word-spacing': 'normal',
	    'text-decoration': 'none',
	    'text-anchor': 'start',
	    'text-overflow': 'clip',
	    'writing-mode': 'lr-tb',
	    'glyph-orientation-vertical': 'auto',
	    'glyph-orientation-horizontal': '0deg',
	    direction: 'ltr',
	    'unicode-bidi': 'normal',
	    'dominant-baseline': 'auto',
	    'alignment-baseline': 'baseline',
	    'baseline-shift': 'baseline',
	  },
	  transferFunction: {
	    slope: '1',
	    intercept: '0',
	    amplitude: '1',
	    exponent: '1',
	    offset: '0',
	  },
	};

	// https://www.w3.org/TR/SVG11/eltindex.html
	/**
	 * @type {Record<string, {
	 *   attrsGroups: Array<string>,
	 *   attrs?: Array<string>,
	 *   defaults?: Record<string, string>,
	 *   contentGroups?: Array<string>,
	 *   content?: Array<string>,
	 * }>}
	 */
	exports.elems = {
	  a: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	      'xlink',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'target',
	    ],
	    defaults: {
	      target: '_self',
	    },
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	      // not spec compliant
	      'tspan',
	    ],
	  },
	  altGlyph: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	      'xlink',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'x',
	      'y',
	      'dx',
	      'dy',
	      'glyphRef',
	      'format',
	      'rotate',
	    ],
	  },
	  altGlyphDef: {
	    attrsGroups: ['core'],
	    content: ['glyphRef'],
	  },
	  altGlyphItem: {
	    attrsGroups: ['core'],
	    content: ['glyphRef', 'altGlyphItem'],
	  },
	  animate: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'animationAddition',
	      'animationAttributeTarget',
	      'animationEvent',
	      'animationTiming',
	      'animationValue',
	      'presentation',
	      'xlink',
	    ],
	    attrs: ['externalResourcesRequired'],
	    contentGroups: ['descriptive'],
	  },
	  animateColor: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'animationEvent',
	      'xlink',
	      'animationAttributeTarget',
	      'animationTiming',
	      'animationValue',
	      'animationAddition',
	      'presentation',
	    ],
	    attrs: ['externalResourcesRequired'],
	    contentGroups: ['descriptive'],
	  },
	  animateMotion: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'animationEvent',
	      'xlink',
	      'animationTiming',
	      'animationValue',
	      'animationAddition',
	    ],
	    attrs: [
	      'externalResourcesRequired',
	      'path',
	      'keyPoints',
	      'rotate',
	      'origin',
	    ],
	    defaults: {
	      rotate: '0',
	    },
	    contentGroups: ['descriptive'],
	    content: ['mpath'],
	  },
	  animateTransform: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'animationEvent',
	      'xlink',
	      'animationAttributeTarget',
	      'animationTiming',
	      'animationValue',
	      'animationAddition',
	    ],
	    attrs: ['externalResourcesRequired', 'type'],
	    contentGroups: ['descriptive'],
	  },
	  circle: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'cx',
	      'cy',
	      'r',
	    ],
	    defaults: {
	      cx: '0',
	      cy: '0',
	    },
	    contentGroups: ['animation', 'descriptive'],
	  },
	  clipPath: {
	    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'clipPathUnits',
	    ],
	    defaults: {
	      clipPathUnits: 'userSpaceOnUse',
	    },
	    contentGroups: ['animation', 'descriptive', 'shape'],
	    content: ['text', 'use'],
	  },
	  'color-profile': {
	    attrsGroups: ['core', 'xlink'],
	    attrs: ['local', 'name', 'rendering-intent'],
	    defaults: {
	      name: 'sRGB',
	      'rendering-intent': 'auto',
	    },
	    contentGroups: ['descriptive'],
	  },
	  cursor: {
	    attrsGroups: ['core', 'conditionalProcessing', 'xlink'],
	    attrs: ['externalResourcesRequired', 'x', 'y'],
	    defaults: {
	      x: '0',
	      y: '0',
	    },
	    contentGroups: ['descriptive'],
	  },
	  defs: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  desc: {
	    attrsGroups: ['core'],
	    attrs: ['class', 'style'],
	  },
	  ellipse: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'cx',
	      'cy',
	      'rx',
	      'ry',
	    ],
	    defaults: {
	      cx: '0',
	      cy: '0',
	    },
	    contentGroups: ['animation', 'descriptive'],
	  },
	  feBlend: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: [
	      'class',
	      'style',
	      // TODO: in - 'If no value is provided and this is the first filter primitive,
	      // then this filter primitive will use SourceGraphic as its input'
	      'in',
	      'in2',
	      'mode',
	    ],
	    defaults: {
	      mode: 'normal',
	    },
	    content: ['animate', 'set'],
	  },
	  feColorMatrix: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style', 'in', 'type', 'values'],
	    defaults: {
	      type: 'matrix',
	    },
	    content: ['animate', 'set'],
	  },
	  feComponentTransfer: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style', 'in'],
	    content: ['feFuncA', 'feFuncB', 'feFuncG', 'feFuncR'],
	  },
	  feComposite: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style', 'in', 'in2', 'operator', 'k1', 'k2', 'k3', 'k4'],
	    defaults: {
	      operator: 'over',
	      k1: '0',
	      k2: '0',
	      k3: '0',
	      k4: '0',
	    },
	    content: ['animate', 'set'],
	  },
	  feConvolveMatrix: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: [
	      'class',
	      'style',
	      'in',
	      'order',
	      'kernelMatrix',
	      // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
	      // with the exception that if the sum is zero, then the divisor is set to 1'
	      'divisor',
	      'bias',
	      // TODO: targetX - 'By default, the convolution matrix is centered in X over each
	      // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
	      'targetX',
	      'targetY',
	      'edgeMode',
	      // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
	      // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
	      'kernelUnitLength',
	      'preserveAlpha',
	    ],
	    defaults: {
	      order: '3',
	      bias: '0',
	      edgeMode: 'duplicate',
	      preserveAlpha: 'false',
	    },
	    content: ['animate', 'set'],
	  },
	  feDiffuseLighting: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: [
	      'class',
	      'style',
	      'in',
	      'surfaceScale',
	      'diffuseConstant',
	      'kernelUnitLength',
	    ],
	    defaults: {
	      surfaceScale: '1',
	      diffuseConstant: '1',
	    },
	    contentGroups: ['descriptive'],
	    content: [
	      // TODO: 'exactly one light source element, in any order'
	      'feDistantLight',
	      'fePointLight',
	      'feSpotLight',
	    ],
	  },
	  feDisplacementMap: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: [
	      'class',
	      'style',
	      'in',
	      'in2',
	      'scale',
	      'xChannelSelector',
	      'yChannelSelector',
	    ],
	    defaults: {
	      scale: '0',
	      xChannelSelector: 'A',
	      yChannelSelector: 'A',
	    },
	    content: ['animate', 'set'],
	  },
	  feDistantLight: {
	    attrsGroups: ['core'],
	    attrs: ['azimuth', 'elevation'],
	    defaults: {
	      azimuth: '0',
	      elevation: '0',
	    },
	    content: ['animate', 'set'],
	  },
	  feFlood: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style'],
	    content: ['animate', 'animateColor', 'set'],
	  },
	  feFuncA: {
	    attrsGroups: ['core', 'transferFunction'],
	    content: ['set', 'animate'],
	  },
	  feFuncB: {
	    attrsGroups: ['core', 'transferFunction'],
	    content: ['set', 'animate'],
	  },
	  feFuncG: {
	    attrsGroups: ['core', 'transferFunction'],
	    content: ['set', 'animate'],
	  },
	  feFuncR: {
	    attrsGroups: ['core', 'transferFunction'],
	    content: ['set', 'animate'],
	  },
	  feGaussianBlur: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style', 'in', 'stdDeviation'],
	    defaults: {
	      stdDeviation: '0',
	    },
	    content: ['set', 'animate'],
	  },
	  feImage: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive', 'xlink'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'preserveAspectRatio',
	      'href',
	      'xlink:href',
	    ],
	    defaults: {
	      preserveAspectRatio: 'xMidYMid meet',
	    },
	    content: ['animate', 'animateTransform', 'set'],
	  },
	  feMerge: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style'],
	    content: ['feMergeNode'],
	  },
	  feMergeNode: {
	    attrsGroups: ['core'],
	    attrs: ['in'],
	    content: ['animate', 'set'],
	  },
	  feMorphology: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style', 'in', 'operator', 'radius'],
	    defaults: {
	      operator: 'erode',
	      radius: '0',
	    },
	    content: ['animate', 'set'],
	  },
	  feOffset: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style', 'in', 'dx', 'dy'],
	    defaults: {
	      dx: '0',
	      dy: '0',
	    },
	    content: ['animate', 'set'],
	  },
	  fePointLight: {
	    attrsGroups: ['core'],
	    attrs: ['x', 'y', 'z'],
	    defaults: {
	      x: '0',
	      y: '0',
	      z: '0',
	    },
	    content: ['animate', 'set'],
	  },
	  feSpecularLighting: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: [
	      'class',
	      'style',
	      'in',
	      'surfaceScale',
	      'specularConstant',
	      'specularExponent',
	      'kernelUnitLength',
	    ],
	    defaults: {
	      surfaceScale: '1',
	      specularConstant: '1',
	      specularExponent: '1',
	    },
	    contentGroups: [
	      'descriptive',
	      // TODO: exactly one 'light source element'
	      'lightSource',
	    ],
	  },
	  feSpotLight: {
	    attrsGroups: ['core'],
	    attrs: [
	      'x',
	      'y',
	      'z',
	      'pointsAtX',
	      'pointsAtY',
	      'pointsAtZ',
	      'specularExponent',
	      'limitingConeAngle',
	    ],
	    defaults: {
	      x: '0',
	      y: '0',
	      z: '0',
	      pointsAtX: '0',
	      pointsAtY: '0',
	      pointsAtZ: '0',
	      specularExponent: '1',
	    },
	    content: ['animate', 'set'],
	  },
	  feTile: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: ['class', 'style', 'in'],
	    content: ['animate', 'set'],
	  },
	  feTurbulence: {
	    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
	    attrs: [
	      'class',
	      'style',
	      'baseFrequency',
	      'numOctaves',
	      'seed',
	      'stitchTiles',
	      'type',
	    ],
	    defaults: {
	      baseFrequency: '0',
	      numOctaves: '1',
	      seed: '0',
	      stitchTiles: 'noStitch',
	      type: 'turbulence',
	    },
	    content: ['animate', 'set'],
	  },
	  filter: {
	    attrsGroups: ['core', 'presentation', 'xlink'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'x',
	      'y',
	      'width',
	      'height',
	      'filterRes',
	      'filterUnits',
	      'primitiveUnits',
	      'href',
	      'xlink:href',
	    ],
	    defaults: {
	      primitiveUnits: 'userSpaceOnUse',
	      x: '-10%',
	      y: '-10%',
	      width: '120%',
	      height: '120%',
	    },
	    contentGroups: ['descriptive', 'filterPrimitive'],
	    content: ['animate', 'set'],
	  },
	  font: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'horiz-origin-x',
	      'horiz-origin-y',
	      'horiz-adv-x',
	      'vert-origin-x',
	      'vert-origin-y',
	      'vert-adv-y',
	    ],
	    defaults: {
	      'horiz-origin-x': '0',
	      'horiz-origin-y': '0',
	    },
	    contentGroups: ['descriptive'],
	    content: ['font-face', 'glyph', 'hkern', 'missing-glyph', 'vkern'],
	  },
	  'font-face': {
	    attrsGroups: ['core'],
	    attrs: [
	      'font-family',
	      'font-style',
	      'font-variant',
	      'font-weight',
	      'font-stretch',
	      'font-size',
	      'unicode-range',
	      'units-per-em',
	      'panose-1',
	      'stemv',
	      'stemh',
	      'slope',
	      'cap-height',
	      'x-height',
	      'accent-height',
	      'ascent',
	      'descent',
	      'widths',
	      'bbox',
	      'ideographic',
	      'alphabetic',
	      'mathematical',
	      'hanging',
	      'v-ideographic',
	      'v-alphabetic',
	      'v-mathematical',
	      'v-hanging',
	      'underline-position',
	      'underline-thickness',
	      'strikethrough-position',
	      'strikethrough-thickness',
	      'overline-position',
	      'overline-thickness',
	    ],
	    defaults: {
	      'font-style': 'all',
	      'font-variant': 'normal',
	      'font-weight': 'all',
	      'font-stretch': 'normal',
	      'unicode-range': 'U+0-10FFFF',
	      'units-per-em': '1000',
	      'panose-1': '0 0 0 0 0 0 0 0 0 0',
	      slope: '0',
	    },
	    contentGroups: ['descriptive'],
	    content: [
	      // TODO: "at most one 'font-face-src' element"
	      'font-face-src',
	    ],
	  },
	  // TODO: empty content
	  'font-face-format': {
	    attrsGroups: ['core'],
	    attrs: ['string'],
	  },
	  'font-face-name': {
	    attrsGroups: ['core'],
	    attrs: ['name'],
	  },
	  'font-face-src': {
	    attrsGroups: ['core'],
	    content: ['font-face-name', 'font-face-uri'],
	  },
	  'font-face-uri': {
	    attrsGroups: ['core', 'xlink'],
	    attrs: ['href', 'xlink:href'],
	    content: ['font-face-format'],
	  },
	  foreignObject: {
	    attrsGroups: [
	      'core',
	      'conditionalProcessing',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'x',
	      'y',
	      'width',
	      'height',
	    ],
	    defaults: {
	      x: '0',
	      y: '0',
	    },
	  },
	  g: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  glyph: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'd',
	      'horiz-adv-x',
	      'vert-origin-x',
	      'vert-origin-y',
	      'vert-adv-y',
	      'unicode',
	      'glyph-name',
	      'orientation',
	      'arabic-form',
	      'lang',
	    ],
	    defaults: {
	      'arabic-form': 'initial',
	    },
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  glyphRef: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'd',
	      'horiz-adv-x',
	      'vert-origin-x',
	      'vert-origin-y',
	      'vert-adv-y',
	    ],
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  hatch: {
	    attrsGroups: ['core', 'presentation', 'xlink'],
	    attrs: [
	      'class',
	      'style',
	      'x',
	      'y',
	      'pitch',
	      'rotate',
	      'hatchUnits',
	      'hatchContentUnits',
	      'transform',
	    ],
	    defaults: {
	      hatchUnits: 'objectBoundingBox',
	      hatchContentUnits: 'userSpaceOnUse',
	      x: '0',
	      y: '0',
	      pitch: '0',
	      rotate: '0',
	    },
	    contentGroups: ['animation', 'descriptive'],
	    content: ['hatchPath'],
	  },
	  hatchPath: {
	    attrsGroups: ['core', 'presentation', 'xlink'],
	    attrs: ['class', 'style', 'd', 'offset'],
	    defaults: {
	      offset: '0',
	    },
	    contentGroups: ['animation', 'descriptive'],
	  },
	  hkern: {
	    attrsGroups: ['core'],
	    attrs: ['u1', 'g1', 'u2', 'g2', 'k'],
	  },
	  image: {
	    attrsGroups: [
	      'core',
	      'conditionalProcessing',
	      'graphicalEvent',
	      'xlink',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'preserveAspectRatio',
	      'transform',
	      'x',
	      'y',
	      'width',
	      'height',
	      'href',
	      'xlink:href',
	    ],
	    defaults: {
	      x: '0',
	      y: '0',
	      preserveAspectRatio: 'xMidYMid meet',
	    },
	    contentGroups: ['animation', 'descriptive'],
	  },
	  line: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'x1',
	      'y1',
	      'x2',
	      'y2',
	    ],
	    defaults: {
	      x1: '0',
	      y1: '0',
	      x2: '0',
	      y2: '0',
	    },
	    contentGroups: ['animation', 'descriptive'],
	  },
	  linearGradient: {
	    attrsGroups: ['core', 'presentation', 'xlink'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'x1',
	      'y1',
	      'x2',
	      'y2',
	      'gradientUnits',
	      'gradientTransform',
	      'spreadMethod',
	      'href',
	      'xlink:href',
	    ],
	    defaults: {
	      x1: '0',
	      y1: '0',
	      x2: '100%',
	      y2: '0',
	      spreadMethod: 'pad',
	    },
	    contentGroups: ['descriptive'],
	    content: ['animate', 'animateTransform', 'set', 'stop'],
	  },
	  marker: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'viewBox',
	      'preserveAspectRatio',
	      'refX',
	      'refY',
	      'markerUnits',
	      'markerWidth',
	      'markerHeight',
	      'orient',
	    ],
	    defaults: {
	      markerUnits: 'strokeWidth',
	      refX: '0',
	      refY: '0',
	      markerWidth: '3',
	      markerHeight: '3',
	    },
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  mask: {
	    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'x',
	      'y',
	      'width',
	      'height',
	      'mask-type',
	      'maskUnits',
	      'maskContentUnits',
	    ],
	    defaults: {
	      maskUnits: 'objectBoundingBox',
	      maskContentUnits: 'userSpaceOnUse',
	      x: '-10%',
	      y: '-10%',
	      width: '120%',
	      height: '120%',
	    },
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  metadata: {
	    attrsGroups: ['core'],
	  },
	  'missing-glyph': {
	    attrsGroups: ['core', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'd',
	      'horiz-adv-x',
	      'vert-origin-x',
	      'vert-origin-y',
	      'vert-adv-y',
	    ],
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  mpath: {
	    attrsGroups: ['core', 'xlink'],
	    attrs: ['externalResourcesRequired', 'href', 'xlink:href'],
	    contentGroups: ['descriptive'],
	  },
	  path: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'd',
	      'pathLength',
	    ],
	    contentGroups: ['animation', 'descriptive'],
	  },
	  pattern: {
	    attrsGroups: ['conditionalProcessing', 'core', 'presentation', 'xlink'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'viewBox',
	      'preserveAspectRatio',
	      'x',
	      'y',
	      'width',
	      'height',
	      'patternUnits',
	      'patternContentUnits',
	      'patternTransform',
	      'href',
	      'xlink:href',
	    ],
	    defaults: {
	      patternUnits: 'objectBoundingBox',
	      patternContentUnits: 'userSpaceOnUse',
	      x: '0',
	      y: '0',
	      width: '0',
	      height: '0',
	      preserveAspectRatio: 'xMidYMid meet',
	    },
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'paintServer',
	      'shape',
	      'structural',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  polygon: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'points',
	    ],
	    contentGroups: ['animation', 'descriptive'],
	  },
	  polyline: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'points',
	    ],
	    contentGroups: ['animation', 'descriptive'],
	  },
	  radialGradient: {
	    attrsGroups: ['core', 'presentation', 'xlink'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'cx',
	      'cy',
	      'r',
	      'fx',
	      'fy',
	      'fr',
	      'gradientUnits',
	      'gradientTransform',
	      'spreadMethod',
	      'href',
	      'xlink:href',
	    ],
	    defaults: {
	      gradientUnits: 'objectBoundingBox',
	      cx: '50%',
	      cy: '50%',
	      r: '50%',
	    },
	    contentGroups: ['descriptive'],
	    content: ['animate', 'animateTransform', 'set', 'stop'],
	  },
	  meshGradient: {
	    attrsGroups: ['core', 'presentation', 'xlink'],
	    attrs: ['class', 'style', 'x', 'y', 'gradientUnits', 'transform'],
	    contentGroups: ['descriptive', 'paintServer', 'animation'],
	    content: ['meshRow'],
	  },
	  meshRow: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: ['class', 'style'],
	    contentGroups: ['descriptive'],
	    content: ['meshPatch'],
	  },
	  meshPatch: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: ['class', 'style'],
	    contentGroups: ['descriptive'],
	    content: ['stop'],
	  },
	  rect: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'x',
	      'y',
	      'width',
	      'height',
	      'rx',
	      'ry',
	    ],
	    defaults: {
	      x: '0',
	      y: '0',
	    },
	    contentGroups: ['animation', 'descriptive'],
	  },
	  script: {
	    attrsGroups: ['core', 'xlink'],
	    attrs: ['externalResourcesRequired', 'type', 'href', 'xlink:href'],
	  },
	  set: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'animation',
	      'xlink',
	      'animationAttributeTarget',
	      'animationTiming',
	    ],
	    attrs: ['externalResourcesRequired', 'to'],
	    contentGroups: ['descriptive'],
	  },
	  solidColor: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: ['class', 'style'],
	    contentGroups: ['paintServer'],
	  },
	  stop: {
	    attrsGroups: ['core', 'presentation'],
	    attrs: ['class', 'style', 'offset', 'path'],
	    content: ['animate', 'animateColor', 'set'],
	  },
	  style: {
	    attrsGroups: ['core'],
	    attrs: ['type', 'media', 'title'],
	    defaults: {
	      type: 'text/css',
	    },
	  },
	  svg: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'documentEvent',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'x',
	      'y',
	      'width',
	      'height',
	      'viewBox',
	      'preserveAspectRatio',
	      'zoomAndPan',
	      'version',
	      'baseProfile',
	      'contentScriptType',
	      'contentStyleType',
	    ],
	    defaults: {
	      x: '0',
	      y: '0',
	      width: '100%',
	      height: '100%',
	      preserveAspectRatio: 'xMidYMid meet',
	      zoomAndPan: 'magnify',
	      version: '1.1',
	      baseProfile: 'none',
	      contentScriptType: 'application/ecmascript',
	      contentStyleType: 'text/css',
	    },
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  switch: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
	    contentGroups: ['animation', 'descriptive', 'shape'],
	    content: [
	      'a',
	      'foreignObject',
	      'g',
	      'image',
	      'svg',
	      'switch',
	      'text',
	      'use',
	    ],
	  },
	  symbol: {
	    attrsGroups: ['core', 'graphicalEvent', 'presentation'],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'preserveAspectRatio',
	      'viewBox',
	      'refX',
	      'refY',
	    ],
	    defaults: {
	      refX: '0',
	      refY: '0',
	    },
	    contentGroups: [
	      'animation',
	      'descriptive',
	      'shape',
	      'structural',
	      'paintServer',
	    ],
	    content: [
	      'a',
	      'altGlyphDef',
	      'clipPath',
	      'color-profile',
	      'cursor',
	      'filter',
	      'font',
	      'font-face',
	      'foreignObject',
	      'image',
	      'marker',
	      'mask',
	      'pattern',
	      'script',
	      'style',
	      'switch',
	      'text',
	      'view',
	    ],
	  },
	  text: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'lengthAdjust',
	      'x',
	      'y',
	      'dx',
	      'dy',
	      'rotate',
	      'textLength',
	    ],
	    defaults: {
	      x: '0',
	      y: '0',
	      lengthAdjust: 'spacing',
	    },
	    contentGroups: ['animation', 'descriptive', 'textContentChild'],
	    content: ['a'],
	  },
	  textPath: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	      'xlink',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'href',
	      'xlink:href',
	      'startOffset',
	      'method',
	      'spacing',
	      'd',
	    ],
	    defaults: {
	      startOffset: '0',
	      method: 'align',
	      spacing: 'exact',
	    },
	    contentGroups: ['descriptive'],
	    content: [
	      'a',
	      'altGlyph',
	      'animate',
	      'animateColor',
	      'set',
	      'tref',
	      'tspan',
	    ],
	  },
	  title: {
	    attrsGroups: ['core'],
	    attrs: ['class', 'style'],
	  },
	  tref: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	      'xlink',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'href',
	      'xlink:href',
	    ],
	    contentGroups: ['descriptive'],
	    content: ['animate', 'animateColor', 'set'],
	  },
	  tspan: {
	    attrsGroups: [
	      'conditionalProcessing',
	      'core',
	      'graphicalEvent',
	      'presentation',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'x',
	      'y',
	      'dx',
	      'dy',
	      'rotate',
	      'textLength',
	      'lengthAdjust',
	    ],
	    contentGroups: ['descriptive'],
	    content: [
	      'a',
	      'altGlyph',
	      'animate',
	      'animateColor',
	      'set',
	      'tref',
	      'tspan',
	    ],
	  },
	  use: {
	    attrsGroups: [
	      'core',
	      'conditionalProcessing',
	      'graphicalEvent',
	      'presentation',
	      'xlink',
	    ],
	    attrs: [
	      'class',
	      'style',
	      'externalResourcesRequired',
	      'transform',
	      'x',
	      'y',
	      'width',
	      'height',
	      'href',
	      'xlink:href',
	    ],
	    defaults: {
	      x: '0',
	      y: '0',
	    },
	    contentGroups: ['animation', 'descriptive'],
	  },
	  view: {
	    attrsGroups: ['core'],
	    attrs: [
	      'externalResourcesRequired',
	      'viewBox',
	      'preserveAspectRatio',
	      'zoomAndPan',
	      'viewTarget',
	    ],
	    contentGroups: ['descriptive'],
	  },
	  vkern: {
	    attrsGroups: ['core'],
	    attrs: ['u1', 'g1', 'u2', 'g2', 'k'],
	  },
	};

	// https://wiki.inkscape.org/wiki/index.php/Inkscape-specific_XML_attributes
	exports.editorNamespaces = [
	  'http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd',
	  'http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd',
	  'http://www.inkscape.org/namespaces/inkscape',
	  'http://www.bohemiancoding.com/sketch/ns',
	  'http://ns.adobe.com/AdobeIllustrator/10.0/',
	  'http://ns.adobe.com/Graphs/1.0/',
	  'http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/',
	  'http://ns.adobe.com/Variables/1.0/',
	  'http://ns.adobe.com/SaveForWeb/1.0/',
	  'http://ns.adobe.com/Extensibility/1.0/',
	  'http://ns.adobe.com/Flows/1.0/',
	  'http://ns.adobe.com/ImageReplacement/1.0/',
	  'http://ns.adobe.com/GenericCustomNamespace/1.0/',
	  'http://ns.adobe.com/XPath/1.0/',
	  'http://schemas.microsoft.com/visio/2003/SVGExtensions/',
	  'http://taptrix.com/vectorillustrator/svg_extensions',
	  'http://www.figma.com/figma/ns',
	  'http://purl.org/dc/elements/1.1/',
	  'http://creativecommons.org/ns#',
	  'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
	  'http://www.serif.com/',
	  'http://www.vector.evaxdesign.sk',
	];

	// https://www.w3.org/TR/SVG11/linking.html#processingIRI
	exports.referencesProps = [
	  'clip-path',
	  'color-profile',
	  'fill',
	  'filter',
	  'marker-start',
	  'marker-mid',
	  'marker-end',
	  'mask',
	  'stroke',
	  'style',
	];

	// https://www.w3.org/TR/SVG11/propidx.html
	exports.inheritableAttrs = [
	  'clip-rule',
	  'color',
	  'color-interpolation',
	  'color-interpolation-filters',
	  'color-profile',
	  'color-rendering',
	  'cursor',
	  'direction',
	  'dominant-baseline',
	  'fill',
	  'fill-opacity',
	  'fill-rule',
	  'font',
	  'font-family',
	  'font-size',
	  'font-size-adjust',
	  'font-stretch',
	  'font-style',
	  'font-variant',
	  'font-weight',
	  'glyph-orientation-horizontal',
	  'glyph-orientation-vertical',
	  'image-rendering',
	  'letter-spacing',
	  'marker',
	  'marker-end',
	  'marker-mid',
	  'marker-start',
	  'paint-order',
	  'pointer-events',
	  'shape-rendering',
	  'stroke',
	  'stroke-dasharray',
	  'stroke-dashoffset',
	  'stroke-linecap',
	  'stroke-linejoin',
	  'stroke-miterlimit',
	  'stroke-opacity',
	  'stroke-width',
	  'text-anchor',
	  'text-rendering',
	  'transform',
	  'visibility',
	  'word-spacing',
	  'writing-mode',
	];

	exports.presentationNonInheritableGroupAttrs = [
	  'display',
	  'clip-path',
	  'filter',
	  'mask',
	  'opacity',
	  'text-decoration',
	  'transform',
	  'unicode-bidi',
	];

	/**
	 * https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
	 *
	 * @type {Record<string, string>}
	 */
	exports.colorsNames = {
	  aliceblue: '#f0f8ff',
	  antiquewhite: '#faebd7',
	  aqua: '#0ff',
	  aquamarine: '#7fffd4',
	  azure: '#f0ffff',
	  beige: '#f5f5dc',
	  bisque: '#ffe4c4',
	  black: '#000',
	  blanchedalmond: '#ffebcd',
	  blue: '#00f',
	  blueviolet: '#8a2be2',
	  brown: '#a52a2a',
	  burlywood: '#deb887',
	  cadetblue: '#5f9ea0',
	  chartreuse: '#7fff00',
	  chocolate: '#d2691e',
	  coral: '#ff7f50',
	  cornflowerblue: '#6495ed',
	  cornsilk: '#fff8dc',
	  crimson: '#dc143c',
	  cyan: '#0ff',
	  darkblue: '#00008b',
	  darkcyan: '#008b8b',
	  darkgoldenrod: '#b8860b',
	  darkgray: '#a9a9a9',
	  darkgreen: '#006400',
	  darkgrey: '#a9a9a9',
	  darkkhaki: '#bdb76b',
	  darkmagenta: '#8b008b',
	  darkolivegreen: '#556b2f',
	  darkorange: '#ff8c00',
	  darkorchid: '#9932cc',
	  darkred: '#8b0000',
	  darksalmon: '#e9967a',
	  darkseagreen: '#8fbc8f',
	  darkslateblue: '#483d8b',
	  darkslategray: '#2f4f4f',
	  darkslategrey: '#2f4f4f',
	  darkturquoise: '#00ced1',
	  darkviolet: '#9400d3',
	  deeppink: '#ff1493',
	  deepskyblue: '#00bfff',
	  dimgray: '#696969',
	  dimgrey: '#696969',
	  dodgerblue: '#1e90ff',
	  firebrick: '#b22222',
	  floralwhite: '#fffaf0',
	  forestgreen: '#228b22',
	  fuchsia: '#f0f',
	  gainsboro: '#dcdcdc',
	  ghostwhite: '#f8f8ff',
	  gold: '#ffd700',
	  goldenrod: '#daa520',
	  gray: '#808080',
	  green: '#008000',
	  greenyellow: '#adff2f',
	  grey: '#808080',
	  honeydew: '#f0fff0',
	  hotpink: '#ff69b4',
	  indianred: '#cd5c5c',
	  indigo: '#4b0082',
	  ivory: '#fffff0',
	  khaki: '#f0e68c',
	  lavender: '#e6e6fa',
	  lavenderblush: '#fff0f5',
	  lawngreen: '#7cfc00',
	  lemonchiffon: '#fffacd',
	  lightblue: '#add8e6',
	  lightcoral: '#f08080',
	  lightcyan: '#e0ffff',
	  lightgoldenrodyellow: '#fafad2',
	  lightgray: '#d3d3d3',
	  lightgreen: '#90ee90',
	  lightgrey: '#d3d3d3',
	  lightpink: '#ffb6c1',
	  lightsalmon: '#ffa07a',
	  lightseagreen: '#20b2aa',
	  lightskyblue: '#87cefa',
	  lightslategray: '#789',
	  lightslategrey: '#789',
	  lightsteelblue: '#b0c4de',
	  lightyellow: '#ffffe0',
	  lime: '#0f0',
	  limegreen: '#32cd32',
	  linen: '#faf0e6',
	  magenta: '#f0f',
	  maroon: '#800000',
	  mediumaquamarine: '#66cdaa',
	  mediumblue: '#0000cd',
	  mediumorchid: '#ba55d3',
	  mediumpurple: '#9370db',
	  mediumseagreen: '#3cb371',
	  mediumslateblue: '#7b68ee',
	  mediumspringgreen: '#00fa9a',
	  mediumturquoise: '#48d1cc',
	  mediumvioletred: '#c71585',
	  midnightblue: '#191970',
	  mintcream: '#f5fffa',
	  mistyrose: '#ffe4e1',
	  moccasin: '#ffe4b5',
	  navajowhite: '#ffdead',
	  navy: '#000080',
	  oldlace: '#fdf5e6',
	  olive: '#808000',
	  olivedrab: '#6b8e23',
	  orange: '#ffa500',
	  orangered: '#ff4500',
	  orchid: '#da70d6',
	  palegoldenrod: '#eee8aa',
	  palegreen: '#98fb98',
	  paleturquoise: '#afeeee',
	  palevioletred: '#db7093',
	  papayawhip: '#ffefd5',
	  peachpuff: '#ffdab9',
	  peru: '#cd853f',
	  pink: '#ffc0cb',
	  plum: '#dda0dd',
	  powderblue: '#b0e0e6',
	  purple: '#800080',
	  rebeccapurple: '#639',
	  red: '#f00',
	  rosybrown: '#bc8f8f',
	  royalblue: '#4169e1',
	  saddlebrown: '#8b4513',
	  salmon: '#fa8072',
	  sandybrown: '#f4a460',
	  seagreen: '#2e8b57',
	  seashell: '#fff5ee',
	  sienna: '#a0522d',
	  silver: '#c0c0c0',
	  skyblue: '#87ceeb',
	  slateblue: '#6a5acd',
	  slategray: '#708090',
	  slategrey: '#708090',
	  snow: '#fffafa',
	  springgreen: '#00ff7f',
	  steelblue: '#4682b4',
	  tan: '#d2b48c',
	  teal: '#008080',
	  thistle: '#d8bfd8',
	  tomato: '#ff6347',
	  turquoise: '#40e0d0',
	  violet: '#ee82ee',
	  wheat: '#f5deb3',
	  white: '#fff',
	  whitesmoke: '#f5f5f5',
	  yellow: '#ff0',
	  yellowgreen: '#9acd32',
	};

	/**
	 * @type {Record<string, string>}
	 */
	exports.colorsShortNames = {
	  '#f0ffff': 'azure',
	  '#f5f5dc': 'beige',
	  '#ffe4c4': 'bisque',
	  '#a52a2a': 'brown',
	  '#ff7f50': 'coral',
	  '#ffd700': 'gold',
	  '#808080': 'gray',
	  '#008000': 'green',
	  '#4b0082': 'indigo',
	  '#fffff0': 'ivory',
	  '#f0e68c': 'khaki',
	  '#faf0e6': 'linen',
	  '#800000': 'maroon',
	  '#000080': 'navy',
	  '#808000': 'olive',
	  '#ffa500': 'orange',
	  '#da70d6': 'orchid',
	  '#cd853f': 'peru',
	  '#ffc0cb': 'pink',
	  '#dda0dd': 'plum',
	  '#800080': 'purple',
	  '#f00': 'red',
	  '#ff0000': 'red',
	  '#fa8072': 'salmon',
	  '#a0522d': 'sienna',
	  '#c0c0c0': 'silver',
	  '#fffafa': 'snow',
	  '#d2b48c': 'tan',
	  '#008080': 'teal',
	  '#ff6347': 'tomato',
	  '#ee82ee': 'violet',
	  '#f5deb3': 'wheat',
	};

	// https://www.w3.org/TR/SVG11/single-page.html#types-DataTypeColor
	exports.colorsProps = [
	  'color',
	  'fill',
	  'stroke',
	  'stop-color',
	  'flood-color',
	  'lighting-color',
	];
} (_collections));

const { detachNodeFromParent: detachNodeFromParent$h } = xast;
const { editorNamespaces } = _collections;

removeEditorsNSData$1.type = 'visitor';
removeEditorsNSData$1.name = 'removeEditorsNSData';
removeEditorsNSData$1.active = true;
removeEditorsNSData$1.description = 'removes editors namespaces, elements and attributes';

/**
 * Remove editors namespaces, elements and attributes.
 *
 * @example
 * <svg xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd">
 * <sodipodi:namedview/>
 * <path sodipodi:nodetypes="cccc"/>
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   additionalNamespaces?: Array<string>
 * }>}
 */
removeEditorsNSData$1.fn = (_root, params) => {
  let namespaces = editorNamespaces;
  if (Array.isArray(params.additionalNamespaces)) {
    namespaces = [...editorNamespaces, ...params.additionalNamespaces];
  }
  /**
   * @type {Array<string>}
   */
  const prefixes = [];
  return {
    element: {
      enter: (node, parentNode) => {
        // collect namespace aliases from svg element
        if (node.name === 'svg') {
          for (const [name, value] of Object.entries(node.attributes)) {
            if (name.startsWith('xmlns:') && namespaces.includes(value)) {
              prefixes.push(name.slice('xmlns:'.length));
              // <svg xmlns:sodipodi="">
              delete node.attributes[name];
            }
          }
        }
        // remove editor attributes, for example
        // <* sodipodi:*="">
        for (const name of Object.keys(node.attributes)) {
          if (name.includes(':')) {
            const [prefix] = name.split(':');
            if (prefixes.includes(prefix)) {
              delete node.attributes[name];
            }
          }
        }
        // remove editor elements, for example
        // <sodipodi:*>
        if (node.name.includes(':')) {
          const [prefix] = node.name.split(':');
          if (prefixes.includes(prefix)) {
            detachNodeFromParent$h(node, parentNode);
          }
        }
      },
    },
  };
};

var cleanupAttrs$1 = {};

cleanupAttrs$1.name = 'cleanupAttrs';
cleanupAttrs$1.type = 'visitor';
cleanupAttrs$1.active = true;
cleanupAttrs$1.description =
  'cleanups attributes from newlines, trailing and repeating spaces';

const regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
const regNewlines = /\r?\n/g;
const regSpaces = /\s{2,}/g;

/**
 * Cleanup attributes values from newlines, trailing and repeating spaces.
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   newlines?: boolean,
 *   trim?: boolean,
 *   spaces?: boolean
 * }>}
 */
cleanupAttrs$1.fn = (root, params) => {
  const { newlines = true, trim = true, spaces = true } = params;
  return {
    element: {
      enter: (node) => {
        for (const name of Object.keys(node.attributes)) {
          if (newlines) {
            // new line which requires a space instead of themselve
            node.attributes[name] = node.attributes[name].replace(
              regNewlinesNeedSpace,
              (match, p1, p2) => p1 + ' ' + p2
            );
            // simple new line
            node.attributes[name] = node.attributes[name].replace(
              regNewlines,
              ''
            );
          }
          if (trim) {
            node.attributes[name] = node.attributes[name].trim();
          }
          if (spaces) {
            node.attributes[name] = node.attributes[name].replace(
              regSpaces,
              ' '
            );
          }
        }
      },
    },
  };
};

var mergeStyles$1 = {};

var CSSClassList$1 = function (node) {
  this.parentNode = node;
  this.classNames = new Set();
  const value = node.attributes.class;
  if (value != null) {
    this.addClassValueHandler();
    this.setClassValue(value);
  }
};

// attr.class.value

CSSClassList$1.prototype.addClassValueHandler = function () {
  Object.defineProperty(this.parentNode.attributes, 'class', {
    get: this.getClassValue.bind(this),
    set: this.setClassValue.bind(this),
    enumerable: true,
    configurable: true,
  });
};

CSSClassList$1.prototype.getClassValue = function () {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames.join(' ');
};

CSSClassList$1.prototype.setClassValue = function (newValue) {
  if (typeof newValue === 'undefined') {
    this.classNames.clear();
    return;
  }
  var arrClassNames = newValue.split(' ');
  this.classNames = new Set(arrClassNames);
};

CSSClassList$1.prototype.add = function (/* variadic */) {
  this.addClassValueHandler();
  Object.values(arguments).forEach(this._addSingle.bind(this));
};

CSSClassList$1.prototype._addSingle = function (className) {
  this.classNames.add(className);
};

CSSClassList$1.prototype.remove = function (/* variadic */) {
  this.addClassValueHandler();
  Object.values(arguments).forEach(this._removeSingle.bind(this));
};

CSSClassList$1.prototype._removeSingle = function (className) {
  this.classNames.delete(className);
};

CSSClassList$1.prototype.item = function (index) {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames[index];
};

CSSClassList$1.prototype.toggle = function (className, force) {
  if (this.contains(className) || force === false) {
    this.classNames.delete(className);
  }
  this.classNames.add(className);
};

CSSClassList$1.prototype.contains = function (className) {
  return this.classNames.has(className);
};

var cssClassList = CSSClassList$1;

var libExports = {};
var lib$1 = {
  get exports(){ return libExports; },
  set exports(v){ libExports = v; },
};

var syntaxExports = {};
var syntax = {
  get exports(){ return syntaxExports; },
  set exports(v){ syntaxExports = v; },
};

var create$4 = {};

//
//                              list
//                            â”Œâ”€â”€â”€â”€â”€â”€â”
//             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€head â”‚
//             â”‚              â”‚ tailâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//             â”‚              â””â”€â”€â”€â”€â”€â”€â”˜              â”‚
//             â–¼                                    â–¼
//            item        item        item        item
//          â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”
//  null â—€â”€â”€â”¼â”€prev â”‚â—€â”€â”€â”€â”¼â”€prev â”‚â—€â”€â”€â”€â”¼â”€prev â”‚â—€â”€â”€â”€â”¼â”€prev â”‚
//          â”‚ nextâ”€â”¼â”€â”€â”€â–¶â”‚ nextâ”€â”¼â”€â”€â”€â–¶â”‚ nextâ”€â”¼â”€â”€â”€â–¶â”‚ nextâ”€â”¼â”€â”€â–¶ null
//          â”œâ”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”¤
//          â”‚ data â”‚    â”‚ data â”‚    â”‚ data â”‚    â”‚ data â”‚
//          â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

var cursors = null;
var List$d = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List$d.createItem = createItem;
List$d.prototype.createItem = createItem;

List$d.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List$d.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List$d.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List$d.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.toJSON = List$d.prototype.toArray;

List$d.prototype.isEmpty = function() {
    return this.head === null;
};

List$d.prototype.first = function() {
    return this.head && this.head.data;
};

List$d.prototype.last = function() {
    return this.tail && this.tail.data;
};

List$d.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.forEach = List$d.prototype.each;

List$d.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.forEachRight = List$d.prototype.eachRight;

List$d.prototype.reduce = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);
    var acc = initialValue;

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List$d.prototype.reduceRight = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);
    var acc = initialValue;

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List$d.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List$d.prototype.map = function(fn, context) {
    var result = new List$d();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.filter = function(fn, context) {
    var result = new List$d();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
        }
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List$d.prototype.copy = function() {
    var result = new List$d();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.prepend = function(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
        // new item <- first item
        this.head.prev = item;

        // new item -> first item
        item.next = this.head;
    } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
    }

    // head always points to new item
    this.head = item;

    return this;
};

List$d.prototype.prependData = function(data) {
    return this.prepend(createItem(data));
};

List$d.prototype.append = function(item) {
    return this.insert(item);
};

List$d.prototype.appendData = function(data) {
    return this.insert(createItem(data));
};

List$d.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t belong to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        // tail
        //      ^
        //      item
        this.updateCursors(this.tail, item, null, item);

        // insert to the ending of the list
        if (this.tail !== null) {
            // last item -> new item
            this.tail.next = item;

            // last item <- new item
            item.prev = this.tail;
        } else {
            // if list has no tail, then it also has no head
            // in this case head points to new item
            this.head = item;
        }

        // tail always points to new item
        this.tail = item;
    }

    return this;
};

List$d.prototype.insertData = function(data, before) {
    return this.insert(createItem(data), before);
};

List$d.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List$d.prototype.push = function(data) {
    this.insert(createItem(data));
};

List$d.prototype.pop = function() {
    if (this.tail !== null) {
        return this.remove(this.tail);
    }
};

List$d.prototype.unshift = function(data) {
    this.prepend(createItem(data));
};

List$d.prototype.shift = function() {
    if (this.head !== null) {
        return this.remove(this.head);
    }
};

List$d.prototype.prependList = function(list) {
    return this.insertList(list, this.head);
};

List$d.prototype.appendList = function(list) {
    return this.insertList(list);
};

List$d.prototype.insertList = function(list, before) {
    // ignore empty lists
    if (list.head === null) {
        return this;
    }

    if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);

        // insert in the middle of dist list
        if (before.prev !== null) {
            // before.prev <-> list.head
            before.prev.next = list.head;
            list.head.prev = before.prev;
        } else {
            this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;
    } else {
        this.updateCursors(this.tail, list.tail, null, list.head);

        // insert to end of the list
        if (this.tail !== null) {
            // if destination list has a tail, then it also has a head,
            // but head doesn't change

            // dest tail -> source head
            this.tail.next = list.head;

            // dest tail <- source head
            list.head.prev = this.tail;
        } else {
            // if list has no a tail, then it also has no a head
            // in this case points head to new item
            this.head = list.head;
        }

        // tail always start point to new item
        this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;

    return this;
};

List$d.prototype.replace = function(oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
    } else {
        this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
};

var List_1 = List$d;

var createCustomError$3 = function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    var error = Object.create(SyntaxError.prototype);
    var errorStack = new Error();

    error.name = name;
    error.message = message;

    Object.defineProperty(error, 'stack', {
        get: function() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
        }
    });

    return error;
};

var createCustomError$2 = createCustomError$3;
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\r\n?|\n|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

var SyntaxError$4 = function(message, source, offset, line, column) {
    var error = createCustomError$2('SyntaxError', message);

    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

var _SyntaxError$1 = SyntaxError$4;

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
var TYPE$H = {
    EOF: 0,                 // <EOF-token>
    Ident: 1,               // <ident-token>
    Function: 2,            // <function-token>
    AtKeyword: 3,           // <at-keyword-token>
    Hash: 4,                // <hash-token>
    String: 5,              // <string-token>
    BadString: 6,           // <bad-string-token>
    Url: 7,                 // <url-token>
    BadUrl: 8,              // <bad-url-token>
    Delim: 9,               // <delim-token>
    Number: 10,             // <number-token>
    Percentage: 11,         // <percentage-token>
    Dimension: 12,          // <dimension-token>
    WhiteSpace: 13,         // <whitespace-token>
    CDO: 14,                // <CDO-token>
    CDC: 15,                // <CDC-token>
    Colon: 16,              // <colon-token>     :
    Semicolon: 17,          // <semicolon-token> ;
    Comma: 18,              // <comma-token>     ,
    LeftSquareBracket: 19,  // <[-token>
    RightSquareBracket: 20, // <]-token>
    LeftParenthesis: 21,    // <(-token>
    RightParenthesis: 22,   // <)-token>
    LeftCurlyBracket: 23,   // <{-token>
    RightCurlyBracket: 24,  // <}-token>
    Comment: 25
};

var NAME$3 = Object.keys(TYPE$H).reduce(function(result, key) {
    result[TYPE$H[key]] = key;
    return result;
}, {});

var _const = {
    TYPE: TYPE$H,
    NAME: NAME$3
};

var EOF$1 = 0;

// https://drafts.csswg.org/css-syntax-3/
// Â§ 4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit$6(code) {
    return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit$4(code) {
    return (
        isDigit$6(code) || // 0 .. 9
        (code >= 0x0041 && code <= 0x0046) || // A .. F
        (code >= 0x0061 && code <= 0x0066)    // a .. f
    );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter$1(code) {
    return code >= 0x0041 && code <= 0x005A;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
    return code >= 0x0061 && code <= 0x007A;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
    return isUppercaseLetter$1(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
    return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 0x005F;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName$2(code) {
    return isNameStart(code) || isDigit$6(code) || code === 0x002D;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
    return (
        (code >= 0x0000 && code <= 0x0008) ||
        (code === 0x000B) ||
        (code >= 0x000E && code <= 0x001F) ||
        (code === 0x007F)
    );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline$1(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace$2(code) {
    return isNewline$1(code) || code === 0x0020 || code === 0x0009;
}

// Â§ 4.3.8. Check if two code points are a valid escape
function isValidEscape$2(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
        return false;
    }

    // Otherwise, if the second code point is a newline or EOF, return false.
    if (isNewline$1(second) || second === EOF$1) {
        return false;
    }

    // Otherwise, return true.
    return true;
}

// Â§ 4.3.9. Check if three code points would start an identifier
function isIdentifierStart$2(first, second, third) {
    // Look at the first code point:

    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return (
            isNameStart(second) ||
            second === 0x002D ||
            isValidEscape$2(second, third)
        );
    }

    // name-start code point
    if (isNameStart(first)) {
        // Return true.
        return true;
    }

    // U+005C REVERSE SOLIDUS (\)
    if (first === 0x005C) {
        // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return isValidEscape$2(first, second);
    }

    // anything else
    // Return false.
    return false;
}

// Â§ 4.3.10. Check if three code points would start a number
function isNumberStart$1(first, second, third) {
    // Look at the first code point:

    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
        // If the second code point is a digit, return true.
        if (isDigit$6(second)) {
            return 2;
        }

        // Otherwise, if the second code point is a U+002E FULL STOP (.)
        // and the third code point is a digit, return true.
        // Otherwise, return false.
        return second === 0x002E && isDigit$6(third) ? 3 : 0;
    }

    // U+002E FULL STOP (.)
    if (first === 0x002E) {
        // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit$6(second) ? 2 : 0;
    }

    // digit
    if (isDigit$6(first)) {
        // Return true.
        return 1;
    }

    // anything else
    // Return false.
    return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM$2(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
        return 1;
    }

    // UTF-16LE
    if (code === 0xFFFE) {
        return 1;
    }

    return 0;
}

// Fast code category
//
// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
var CATEGORY = new Array(0x80);
charCodeCategory$1.Eof = 0x80;
charCodeCategory$1.WhiteSpace = 0x82;
charCodeCategory$1.Digit = 0x83;
charCodeCategory$1.NameStart = 0x84;
charCodeCategory$1.NonPrintable = 0x85;

for (var i = 0; i < CATEGORY.length; i++) {
    switch (true) {
        case isWhiteSpace$2(i):
            CATEGORY[i] = charCodeCategory$1.WhiteSpace;
            break;

        case isDigit$6(i):
            CATEGORY[i] = charCodeCategory$1.Digit;
            break;

        case isNameStart(i):
            CATEGORY[i] = charCodeCategory$1.NameStart;
            break;

        case isNonPrintable(i):
            CATEGORY[i] = charCodeCategory$1.NonPrintable;
            break;

        default:
            CATEGORY[i] = i || charCodeCategory$1.Eof;
    }
}

function charCodeCategory$1(code) {
    return code < 0x80 ? CATEGORY[code] : charCodeCategory$1.NameStart;
}
var charCodeDefinitions$1 = {
    isDigit: isDigit$6,
    isHexDigit: isHexDigit$4,
    isUppercaseLetter: isUppercaseLetter$1,
    isLowercaseLetter: isLowercaseLetter,
    isLetter: isLetter,
    isNonAscii: isNonAscii,
    isNameStart: isNameStart,
    isName: isName$2,
    isNonPrintable: isNonPrintable,
    isNewline: isNewline$1,
    isWhiteSpace: isWhiteSpace$2,
    isValidEscape: isValidEscape$2,
    isIdentifierStart: isIdentifierStart$2,
    isNumberStart: isNumberStart$1,

    isBOM: isBOM$2,
    charCodeCategory: charCodeCategory$1
};

var charCodeDef = charCodeDefinitions$1;
var isDigit$5 = charCodeDef.isDigit;
var isHexDigit$3 = charCodeDef.isHexDigit;
var isUppercaseLetter = charCodeDef.isUppercaseLetter;
var isName$1 = charCodeDef.isName;
var isWhiteSpace$1 = charCodeDef.isWhiteSpace;
var isValidEscape$1 = charCodeDef.isValidEscape;

function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength$1(source, offset, code) {
    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
        return 2;
    }

    return 1;
}

function cmpChar$5(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (isUppercaseLetter(code)) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr$6(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i - start);

        // testCode.toLowerCase() for A..Z
        if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart$1(source, offset) {
    for (; offset >= 0; offset--) {
        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset + 1;
}

function findWhiteSpaceEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isDigit$5(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

// Â§ 4.3.7. Consume an escaped code point
function consumeEscaped$1(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2;

    // hex digit
    if (isHexDigit$3(getCharCode(source, offset - 1))) {
        // Consume as many hex digits as possible, but no more than 5.
        // Note that this means 1-6 hex digits have been consumed in total.
        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit$3(getCharCode(source, offset))) {
                break;
            }
        }

        // If the next input code point is whitespace, consume it as well.
        var code = getCharCode(source, offset);
        if (isWhiteSpace$1(code)) {
            offset += getNewlineLength$1(source, offset, code);
        }
    }

    return offset;
}

// Â§4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName$1(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // name code point
        if (isName$1(code)) {
            // Append the code point to result.
            continue;
        }

        // the stream starts with a valid escape
        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point. Append the returned code point to result.
            offset = consumeEscaped$1(source, offset) - 1;
            continue;
        }

        // anything else
        // Reconsume the current input code point. Return result.
        break;
    }

    return offset;
}

// Â§4.3.12. Consume a number
function consumeNumber$5(source, offset) {
    var code = source.charCodeAt(offset);

    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.
    if (code === 0x002B || code === 0x002D) {
        code = source.charCodeAt(offset += 1);
    }

    // 3. While the next input code point is a digit, consume it and append it to repr.
    if (isDigit$5(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
    }

    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    if (code === 0x002E && isDigit$5(source.charCodeAt(offset + 1))) {
        // 4.1 Consume them.
        // 4.2 Append them to repr.
        code = source.charCodeAt(offset += 2);

        // 4.3 Set type to "number".
        // TODO

        // 4.4 While the next input code point is a digit, consume it and append it to repr.

        offset = findDecimalNumberEnd(source, offset);
    }

    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    if (cmpChar$5(source, offset, 101 /* e */)) {
        var sign = 0;
        code = source.charCodeAt(offset + 1);

        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
        if (code === 0x002D || code === 0x002B) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
        }

        // ... followed by a digit
        if (isDigit$5(code)) {
            // 5.1 Consume them.
            // 5.2 Append them to repr.

            // 5.3 Set type to "number".
            // TODO

            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
    }

    return offset;
}

// Â§ 4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants$1(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // U+0029 RIGHT PARENTHESIS ())
        // EOF
        if (code === 0x0029) {
            // Return.
            offset++;
            break;
        }

        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = consumeEscaped$1(source, offset);
        }
    }

    return offset;
}

var utils$7 = {
    consumeEscaped: consumeEscaped$1,
    consumeName: consumeName$1,
    consumeNumber: consumeNumber$5,
    consumeBadUrlRemnants: consumeBadUrlRemnants$1,

    cmpChar: cmpChar$5,
    cmpStr: cmpStr$6,

    getNewlineLength: getNewlineLength$1,
    findWhiteSpaceStart: findWhiteSpaceStart$1,
    findWhiteSpaceEnd: findWhiteSpaceEnd$1
};

var constants$2 = _const;
var TYPE$G = constants$2.TYPE;
var NAME$2 = constants$2.NAME;

var utils$6 = utils$7;
var cmpStr$5 = utils$6.cmpStr;

var EOF = TYPE$G.EOF;
var WHITESPACE$c = TYPE$G.WhiteSpace;
var COMMENT$a = TYPE$G.Comment;

var OFFSET_MASK$1 = 0x00FFFFFF;
var TYPE_SHIFT$1 = 24;

var TokenStream$4 = function() {
    this.offsetAndType = null;
    this.balance = null;

    this.reset();
};

TokenStream$4.prototype = {
    reset: function() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
    },

    lookupType: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT$1;
        }

        return EOF;
    },
    lookupOffset: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK$1;
        }

        return this.source.length;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return cmpStr$5(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK$1,
                this.offsetAndType[offset] & OFFSET_MASK$1,
                referenceStr
            );
        }

        return false;
    },
    getTokenStart: function(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
        }

        if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK$1
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK$1;
        }

        return this.firstCharOffset;
    },

    // TODO: -> skipUntilBalanced
    getRawLength: function(startToken, mode) {
        var cursor = startToken;
        var balanceEnd;
        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK$1;
        var type;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // stop scanning on balance edge that points to offset before start token
            if (balanceEnd < startToken) {
                break loop;
            }

            type = this.offsetAndType[cursor] >> TYPE_SHIFT$1;

            // check token is stop type
            switch (mode(type, this.source, offset)) {
                case 1:
                    break loop;

                case 2:
                    cursor++;
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }

                    offset = this.offsetAndType[cursor] & OFFSET_MASK$1;
            }
        }

        return cursor - this.tokenIndex;
    },
    isBalanceEdge: function(pos) {
        return this.balance[this.tokenIndex] < pos;
    },
    isDelim: function(code, offset) {
        if (offset) {
            return (
                this.lookupType(offset) === TYPE$G.Delim &&
                this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
        }

        return (
            this.tokenType === TYPE$G.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
        );
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    getTokenLength: function() {
        return this.tokenEnd - this.tokenStart;
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_SHIFT$1) !== WHITESPACE$c) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skipSC: function() {
        while (this.tokenType === WHITESPACE$c || this.tokenType === COMMENT$a) {
            this.next();
        }
    },
    skip: function(tokenCount) {
        var next = this.tokenIndex + tokenCount;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK$1;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT$1;
            this.tokenEnd = next & OFFSET_MASK$1;
        } else {
            this.tokenIndex = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.tokenIndex + 1;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT$1;
            this.tokenEnd = next & OFFSET_MASK$1;
        } else {
            this.tokenIndex = this.tokenCount;
            this.eof = true;
            this.tokenType = EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    forEachToken(fn) {
        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            var start = offset;
            var item = this.offsetAndType[i];
            var end = item & OFFSET_MASK$1;
            var type = item >> TYPE_SHIFT$1;

            offset = end;

            fn(type, start, end, i);
        }
    },

    dump() {
        var tokens = new Array(this.tokenCount);

        this.forEachToken((type, start, end, index) => {
            tokens[index] = {
                idx: index,
                type: NAME$2[type],
                chunk: this.source.substring(start, end),
                balance: this.balance[index]
            };
        });

        return tokens;
    }
};

var TokenStream_1 = TokenStream$4;

function noop$3(value) {
    return value;
}

function generateMultiplier(multiplier) {
    if (multiplier.min === 0 && multiplier.max === 0) {
        return '*';
    }

    if (multiplier.min === 0 && multiplier.max === 1) {
        return '?';
    }

    if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? '#' : '+';
    }

    if (multiplier.min === 1 && multiplier.max === 1) {
        return '';
    }

    return (
        (multiplier.comma ? '#' : '') +
        (multiplier.min === multiplier.max
            ? '{' + multiplier.min + '}'
            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
        )
    );
}

function generateTypeOpts(node) {
    switch (node.type) {
        case 'Range':
            return (
                ' [' +
                (node.min === null ? '-âˆž' : node.min) +
                ',' +
                (node.max === null ? 'âˆž' : node.max) +
                ']'
            );

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }
}

function generateSequence(node, decorate, forceBraces, compact) {
    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    var result = node.terms.map(function(term) {
        return generate$8(term, decorate, forceBraces, compact);
    }).join(combinator);

    if (node.explicit || forceBraces) {
        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
}

function generate$8(node, decorate, forceBraces, compact) {
    var result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, decorate, forceBraces, compact) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                generate$8(node.term, decorate, forceBraces, compact) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

var generate_1 = function(node, options) {
    var decorate = noop$3;
    var forceBraces = false;
    var compact = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return generate$8(node, decorate, forceBraces, compact);
};

const createCustomError$1 = createCustomError$3;
const generate$7 = generate_1;
const defaultLoc = { offset: 0, line: 1, column: 1 };

function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = '';
    let start;
    let end;

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;

        if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
        }

        if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += token;
    }

    if (longestMatch === tokens.length || entries > 1) { // last
        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
        end = buildLoc(start);
    } else {
        start = fromLoc(badNode, 'start') ||
            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, 'end') ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }

    return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    };
}

function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];

    if (value) {
        return 'line' in value ? buildLoc(value) : value;
    }

    return null;
}

function buildLoc({ offset, line, column }, extra) {
    const loc = {
        offset,
        line,
        column
    };

    if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);

        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }

    return loc;
}

const SyntaxReferenceError$1 = function(type, referenceName) {
    const error = createCustomError$1(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

const SyntaxMatchError$1 = function(message, syntax, node, matchResult) {
    const error = createCustomError$1('SyntaxMatchError', message);
    const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    } = locateMismatch(matchResult, node);

    error.rawMessage = message;
    error.syntax = syntax ? generate$7(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    Object.assign(error, start);
    error.loc = {
        source: (node && node.loc && node.loc.source) || '<unknown>',
        start,
        end
    };

    return error;
};

var error$1 = {
    SyntaxReferenceError: SyntaxReferenceError$1,
    SyntaxMatchError: SyntaxMatchError$1
};

var hasOwnProperty$a = Object.prototype.hasOwnProperty;
var keywords$2 = Object.create(null);
var properties$1 = Object.create(null);
var HYPHENMINUS$5 = 45; // '-'.charCodeAt()

function isCustomProperty$1(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS$5 &&
           str.charCodeAt(offset + 1) === HYPHENMINUS$5;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS$5 &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
            // vendor prefix should contain a hyper minus at the ending
            var secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (hasOwnProperty$a.call(keywords$2, keyword)) {
        return keywords$2[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty$a.call(keywords$2, name)) {
        return keywords$2[keyword] = keywords$2[name];
    }

    var custom = isCustomProperty$1(name, 0);
    var vendor = !custom ? getVendorPrefix(name, 0) : '';

    return keywords$2[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name: name,
        vendor: vendor,
        prefix: vendor,
        custom: custom
    });
}

function getPropertyDescriptor(property) {
    if (hasOwnProperty$a.call(properties$1, property)) {
        return properties$1[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+' &&
               hack !== '&') {
        hack = '';
    }

    var custom = isCustomProperty$1(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty$a.call(properties$1, name)) {
            return properties$1[property] = properties$1[name];
        }
    }

    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    var prefix = name.substr(0, hack.length + vendor.length);

    return properties$1[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack: hack,
        vendor: vendor,
        prefix: prefix,
        custom: custom
    });
}

var names$2 = {
    keyword: getKeywordDescriptor,
    property: getPropertyDescriptor,
    isCustomProperty: isCustomProperty$1,
    vendorPrefix: getVendorPrefix
};

var MIN_SIZE = 16 * 1024;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

var adoptBuffer$2 = function adoptBuffer(buffer, size) {
    if (buffer === null || buffer.length < size) {
        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
};

var TokenStream$3 = TokenStream_1;
var adoptBuffer$1 = adoptBuffer$2;

var constants$1 = _const;
var TYPE$F = constants$1.TYPE;

var charCodeDefinitions = charCodeDefinitions$1;
var isNewline = charCodeDefinitions.isNewline;
var isName = charCodeDefinitions.isName;
var isValidEscape = charCodeDefinitions.isValidEscape;
var isNumberStart = charCodeDefinitions.isNumberStart;
var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
var charCodeCategory = charCodeDefinitions.charCodeCategory;
var isBOM$1 = charCodeDefinitions.isBOM;

var utils$5 = utils$7;
var cmpStr$4 = utils$5.cmpStr;
var getNewlineLength = utils$5.getNewlineLength;
var findWhiteSpaceEnd = utils$5.findWhiteSpaceEnd;
var consumeEscaped = utils$5.consumeEscaped;
var consumeName = utils$5.consumeName;
var consumeNumber$4 = utils$5.consumeNumber;
var consumeBadUrlRemnants = utils$5.consumeBadUrlRemnants;

var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

function tokenize$3(source, stream) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    // Â§ 4.3.3. Consume a numeric token
    function consumeNumericToken() {
        // Consume a number and let number be the result.
        offset = consumeNumber$4(source, offset);

        // If the next 3 input code points would start an identifier, then:
        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
            // Consume a name. Set the <dimension-token>â€™s unit to the returned value.
            // Return the <dimension-token>.
            type = TYPE$F.Dimension;
            offset = consumeName(source, offset);
            return;
        }

        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
        if (getCharCode(offset) === 0x0025) {
            // Create a <percentage-token> with the same value as number, and return it.
            type = TYPE$F.Percentage;
            offset++;
            return;
        }

        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
        type = TYPE$F.Number;
    }

    // Â§ 4.3.4. Consume an ident-like token
    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        // Consume a name, and let string be the result.
        offset = consumeName(source, offset);

        // If stringâ€™s value is an ASCII case-insensitive match for "url",
        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        if (cmpStr$4(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            // While the next two input code points are whitespace, consume the next input code point.
            offset = findWhiteSpaceEnd(source, offset + 1);

            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
            // then create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = TYPE$F.Function;
                offset = nameStartOffset + 4;
                return;
            }

            // Otherwise, consume a url token, and return it.
            consumeUrlToken();
            return;
        }

        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        // Create a <function-token> with its value set to string and return it.
        if (getCharCode(offset) === 0x0028) {
            type = TYPE$F.Function;
            offset++;
            return;
        }

        // Otherwise, create an <ident-token> with its value set to string and return it.
        type = TYPE$F.Ident;
    }

    // Â§ 4.3.5. Consume a string token
    function consumeStringToken(endingCodePoint) {
        // This algorithm may be called with an ending code point, which denotes the code point
        // that ends the string. If an ending code point is not specified,
        // the current input code point is used.
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        // Initially create a <string-token> with its value set to the empty string.
        type = TYPE$F.String;

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // ending code point
                case endingCodePoint:
                    // Return the <string-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <string-token>.
                    return;

                // newline
                case charCodeCategory.WhiteSpace:
                    if (isNewline(code)) {
                        // This is a parse error. Reconsume the current input code point,
                        // create a <bad-string-token>, and return it.
                        offset += getNewlineLength(source, offset, code);
                        type = TYPE$F.BadString;
                        return;
                    }
                    break;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the next input code point is EOF, do nothing.
                    if (offset === source.length - 1) {
                        break;
                    }

                    var nextCode = getCharCode(offset + 1);

                    // Otherwise, if the next input code point is a newline, consume it.
                    if (isNewline(nextCode)) {
                        offset += getNewlineLength(source, offset + 1, nextCode);
                    } else if (isValidEscape(code, nextCode)) {
                        // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>â€™s value.
                        offset = consumeEscaped(source, offset) - 1;
                    }
                    break;

                // anything else
                // Append the current input code point to the <string-token>â€™s value.
            }
        }
    }

    // Â§ 4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that itâ€™s being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldnâ€™t be called directly otherwise.
    function consumeUrlToken() {
        // Initially create a <url-token> with its value set to the empty string.
        type = TYPE$F.Url;

        // Consume as much whitespace as possible.
        offset = findWhiteSpaceEnd(source, offset);

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return the <url-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <url-token>.
                    return;

                // whitespace
                case charCodeCategory.WhiteSpace:
                    // Consume as much whitespace as possible.
                    offset = findWhiteSpaceEnd(source, offset);

                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                    // consume it and return the <url-token>
                    // (if EOF was encountered, this is a parse error);
                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                    // and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE$F.BadUrl;
                    return;

                // U+0022 QUOTATION MARK (")
                // U+0027 APOSTROPHE (')
                // U+0028 LEFT PARENTHESIS (()
                // non-printable code point
                case 0x0022:
                case 0x0027:
                case 0x0028:
                case charCodeCategory.NonPrintable:
                    // This is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE$F.BadUrl;
                    return;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the stream starts with a valid escape, consume an escaped code point and
                    // append the returned code point to the <url-token>â€™s value.
                    if (isValidEscape(code, getCharCode(offset + 1))) {
                        offset = consumeEscaped(source, offset) - 1;
                        break;
                    }

                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE$F.BadUrl;
                    return;

                // anything else
                // Append the current input code point to the <url-token>â€™s value.
            }
        }
    }

    if (!stream) {
        stream = new TokenStream$3();
    }

    // ensure source is a string
    source = String(source || '');

    var sourceLength = source.length;
    var offsetAndType = adoptBuffer$1(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
    var balance = adoptBuffer$1(stream.balance, sourceLength + 1);
    var tokenCount = 0;
    var start = isBOM$1(getCharCode(0));
    var offset = start;
    var balanceCloseType = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    // https://drafts.csswg.org/css-syntax-3/#consume-token
    // Â§ 4.3.1. Consume a token
    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = 0;

        balance[tokenCount] = sourceLength;

        switch (charCodeCategory(code)) {
            // whitespace
            case charCodeCategory.WhiteSpace:
                // Consume as much whitespace as possible. Return a <whitespace-token>.
                type = TYPE$F.WhiteSpace;
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            // U+0022 QUOTATION MARK (")
            case 0x0022:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0023 NUMBER SIGN (#)
            case 0x0023:
                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // Create a <hash-token>.
                    type = TYPE$F.Hash;

                    // If the next 3 input code points would start an identifier, set the <hash-token>â€™s type flag to "id".
                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    //     // TODO: set id flag
                    // }

                    // Consume a name, and set the <hash-token>â€™s value to the returned string.
                    offset = consumeName(source, offset + 1);

                    // Return the <hash-token>.
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+0027 APOSTROPHE (')
            case 0x0027:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0028 LEFT PARENTHESIS (()
            case 0x0028:
                // Return a <(-token>.
                type = TYPE$F.LeftParenthesis;
                offset++;
                break;

            // U+0029 RIGHT PARENTHESIS ())
            case 0x0029:
                // Return a <)-token>.
                type = TYPE$F.RightParenthesis;
                offset++;
                break;

            // U+002B PLUS SIGN (+)
            case 0x002B:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }
                break;

            // U+002C COMMA (,)
            case 0x002C:
                // Return a <comma-token>.
                type = TYPE$F.Comma;
                offset++;
                break;

            // U+002D HYPHEN-MINUS (-)
            case 0x002D:
                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = TYPE$F.CDC;
                        offset = offset + 3;
                    } else {
                        // Otherwise, if the input stream starts with an identifier, ...
                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            // ... reconsume the current input code point, consume an ident-like token, and return it.
                            consumeIdentLikeToken();
                        } else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = TYPE$F.Delim;
                            offset++;
                        }
                    }
                }
                break;

            // U+002E FULL STOP (.)
            case 0x002E:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+002F SOLIDUS (/)
            case 0x002F:
                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                if (getCharCode(offset + 1) === 0x002A) {
                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                    type = TYPE$F.Comment;
                    offset = source.indexOf('*/', offset + 2) + 2;
                    if (offset === 1) {
                        offset = source.length;
                    }
                } else {
                    type = TYPE$F.Delim;
                    offset++;
                }
                break;

            // U+003A COLON (:)
            case 0x003A:
                // Return a <colon-token>.
                type = TYPE$F.Colon;
                offset++;
                break;

            // U+003B SEMICOLON (;)
            case 0x003B:
                // Return a <semicolon-token>.
                type = TYPE$F.Semicolon;
                offset++;
                break;

            // U+003C LESS-THAN SIGN (<)
            case 0x003C:
                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    // ... consume them and return a <CDO-token>.
                    type = TYPE$F.CDO;
                    offset = offset + 4;
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+0040 COMMERCIAL AT (@)
            case 0x0040:
                // If the next 3 input code points would start an identifier, ...
                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                    type = TYPE$F.AtKeyword;
                    offset = consumeName(source, offset + 1);
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+005B LEFT SQUARE BRACKET ([)
            case 0x005B:
                // Return a <[-token>.
                type = TYPE$F.LeftSquareBracket;
                offset++;
                break;

            // U+005C REVERSE SOLIDUS (\)
            case 0x005C:
                // If the input stream starts with a valid escape, ...
                if (isValidEscape(code, getCharCode(offset + 1))) {
                    // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                } else {
                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }
                break;

            // U+005D RIGHT SQUARE BRACKET (])
            case 0x005D:
                // Return a <]-token>.
                type = TYPE$F.RightSquareBracket;
                offset++;
                break;

            // U+007B LEFT CURLY BRACKET ({)
            case 0x007B:
                // Return a <{-token>.
                type = TYPE$F.LeftCurlyBracket;
                offset++;
                break;

            // U+007D RIGHT CURLY BRACKET (})
            case 0x007D:
                // Return a <}-token>.
                type = TYPE$F.RightCurlyBracket;
                offset++;
                break;

            // digit
            case charCodeCategory.Digit:
                // Reconsume the current input code point, consume a numeric token, and return it.
                consumeNumericToken();
                break;

            // name-start code point
            case charCodeCategory.NameStart:
                // Reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
                break;

            // EOF
            case charCodeCategory.Eof:
                // Return an <EOF-token>.
                break;

            // anything else
            default:
                // Return a <delim-token> with its value set to the current input code point.
                type = TYPE$F.Delim;
                offset++;
        }

        switch (type) {
            case balanceCloseType:
                balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balanceCloseType = balanceStart >> TYPE_SHIFT;
                balance[tokenCount] = balancePrev;
                balance[balancePrev++] = tokenCount;
                for (; balancePrev < tokenCount; balancePrev++) {
                    if (balance[balancePrev] === sourceLength) {
                        balance[balancePrev] = tokenCount;
                    }
                }
                break;

            case TYPE$F.LeftParenthesis:
            case TYPE$F.Function:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE$F.RightParenthesis;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE$F.LeftSquareBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE$F.RightSquareBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE$F.LeftCurlyBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE$F.RightCurlyBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
    }

    // finalize buffers
    offsetAndType[tokenCount] = (TYPE$F.EOF << TYPE_SHIFT) | offset; // <EOF-token>
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    // update stream
    stream.source = source;
    stream.firstCharOffset = start;
    stream.offsetAndType = offsetAndType;
    stream.tokenCount = tokenCount;
    stream.balance = balance;
    stream.reset();
    stream.next();

    return stream;
}

// extend tokenizer with constants
Object.keys(constants$1).forEach(function(key) {
    tokenize$3[key] = constants$1[key];
});

// extend tokenizer with static methods from utils
Object.keys(charCodeDefinitions).forEach(function(key) {
    tokenize$3[key] = charCodeDefinitions[key];
});
Object.keys(utils$5).forEach(function(key) {
    tokenize$3[key] = utils$5[key];
});

var tokenizer$3 = tokenize$3;

var isDigit$4 = tokenizer$3.isDigit;
var cmpChar$4 = tokenizer$3.cmpChar;
var TYPE$E = tokenizer$3.TYPE;

var DELIM$6 = TYPE$E.Delim;
var WHITESPACE$b = TYPE$E.WhiteSpace;
var COMMENT$9 = TYPE$E.Comment;
var IDENT$i = TYPE$E.Ident;
var NUMBER$9 = TYPE$E.Number;
var DIMENSION$7 = TYPE$E.Dimension;
var PLUSSIGN$8 = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS$4 = 0x002D; // U+002D HYPHEN-MINUS (-)
var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN$1 = true;
var ALLOW_SIGN$1 = false;

function isDelim$1(token, code) {
    return token !== null && token.type === DELIM$6 && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WHITESPACE$b || token.type === COMMENT$9)) {
        token = getNextToken(++offset);
    }

    return offset;
}

function checkInteger$1(token, valueOffset, disallowSign, offset) {
    if (!token) {
        return 0;
    }

    var code = token.value.charCodeAt(valueOffset);

    if (code === PLUSSIGN$8 || code === HYPHENMINUS$4) {
        if (disallowSign) {
            // Number sign is not allowed
            return 0;
        }
        valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit$4(token.value.charCodeAt(valueOffset))) {
            // Integer is expected
            return 0;
        }
    }

    return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB$1(token, offset_, getNextToken) {
    var sign = false;
    var offset = skipSC(token, offset_, getNextToken);

    token = getNextToken(offset);

    if (token === null) {
        return offset_;
    }

    if (token.type !== NUMBER$9) {
        if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);

            if (token === null && token.type !== NUMBER$9) {
                return 0;
            }
        } else {
            return offset_;
        }
    }

    if (!sign) {
        var code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN$8 && code !== HYPHENMINUS$4) {
            // Number sign is expected
            return 0;
        }
    }

    return checkInteger$1(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
var genericAnPlusB = function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    var offset = 0;

    if (!token) {
        return 0;
    }

    // <integer>
    if (token.type === NUMBER$9) {
        return checkInteger$1(token, 0, ALLOW_SIGN$1, offset); // b
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === IDENT$i && token.value.charCodeAt(0) === HYPHENMINUS$4) {
        // expect 1st char is N
        if (!cmpChar$4(token.value, 1, N$4)) {
            return 0;
        }

        switch (token.value.length) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // -n- <signless-integer>
            case 3:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // <dashndashdigit-ident>
            default:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === IDENT$i || (isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === IDENT$i)) {
        // just ignore a plus
        if (token.type !== IDENT$i) {
            token = getNextToken(++offset);
        }

        if (token === null || !cmpChar$4(token.value, 0, N$4)) {
            return 0;
        }

        switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // '+'? n- <signless-integer>
            case 2:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // '+'? <ndashdigit-ident>
            default:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (token.type === DIMENSION$7) {
        var code = token.value.charCodeAt(0);
        var sign = code === PLUSSIGN$8 || code === HYPHENMINUS$4 ? 1 : 0;

        for (var i = sign; i < token.value.length; i++) {
            if (!isDigit$4(token.value.charCodeAt(i))) {
                break;
            }
        }

        if (i === sign) {
            // Integer is expected
            return 0;
        }

        if (!cmpChar$4(token.value, i, N$4)) {
            return 0;
        }

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === token.value.length) {
            return consumeB$1(getNextToken(++offset), offset, getNextToken);
        } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$4) {
                return 0;
            }

            // <ndash-dimension> <signless-integer>
            if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
            }
            // <ndashdigit-dimension>
            else {
                return checkInteger$1(token, i + 2, DISALLOW_SIGN$1, offset);
            }
        }
    }

    return 0;
};

var isHexDigit$2 = tokenizer$3.isHexDigit;
var cmpChar$3 = tokenizer$3.cmpChar;
var TYPE$D = tokenizer$3.TYPE;

var IDENT$h = TYPE$D.Ident;
var DELIM$5 = TYPE$D.Delim;
var NUMBER$8 = TYPE$D.Number;
var DIMENSION$6 = TYPE$D.Dimension;
var PLUSSIGN$7 = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS$3 = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
var U$2 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
    return token !== null && token.type === DELIM$5 && token.value.charCodeAt(0) === code;
}

function startsWith$1(token, code) {
    return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
        var code = token.value.charCodeAt(pos);

        if (code === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
                return 6; // dissallow following question marks
            }

            return 0; // dash at the ending of a hex sequence is not allowed
        }

        if (!isHexDigit$2(code)) {
            return 0; // not a hex digit
        }

        if (++hexlen > 6) {
            return 0; // too many hex digits
        }    }

    return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
        return 0; // nothing consumed
    }

    while (isDelim(getNextToken(length), QUESTIONMARK$2)) {
        if (++consumed > 6) {
            return 0; // too many question marks
        }

        length++;
    }

    return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
var genericUrange = function urange(token, getNextToken) {
    var length = 0;

    // should start with `u` or `U`
    if (token === null || token.type !== IDENT$h || !cmpChar$3(token.value, 0, U$2)) {
        return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
        return 0;
    }

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (isDelim(token, PLUSSIGN$7)) {
        token = getNextToken(++length);
        if (token === null) {
            return 0;
        }

        if (token.type === IDENT$h) {
            // u '+' <ident-token> '?'*
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }

        if (isDelim(token, QUESTIONMARK$2)) {
            // u '+' '?'+
            return withQuestionMarkSequence(1, ++length, getNextToken);
        }

        // Hex digit or question mark is expected
        return 0;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (token.type === NUMBER$8) {
        if (!startsWith$1(token, PLUSSIGN$7)) {
            return 0;
        }

        var consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
            return 0;
        }

        token = getNextToken(++length);
        if (token === null) {
            // u <number-token> <eof>
            return length;
        }

        if (token.type === DIMENSION$6 || token.type === NUMBER$8) {
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
                return 0;
            }

            return length + 1;
        }

        // u <number-token> '?'*
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }

    // u <dimension-token> '?'*
    if (token.type === DIMENSION$6) {
        if (!startsWith$1(token, PLUSSIGN$7)) {
            return 0;
        }

        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
};

var tokenizer$2 = tokenizer$3;
var isIdentifierStart = tokenizer$2.isIdentifierStart;
var isHexDigit$1 = tokenizer$2.isHexDigit;
var isDigit$3 = tokenizer$2.isDigit;
var cmpStr$3 = tokenizer$2.cmpStr;
var consumeNumber$3 = tokenizer$2.consumeNumber;
var TYPE$C = tokenizer$2.TYPE;
var anPlusB = genericAnPlusB;
var urange = genericUrange;

var cssWideKeywords$1 = ['unset', 'initial', 'inherit'];
var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

// https://www.w3.org/TR/css-values-3/#lengths
var LENGTH = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,
    'q': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var ANGLE = {
    'deg': true,
    'grad': true,
    'rad': true,
    'turn': true
};

var TIME = {
    's': true,
    'ms': true
};

var FREQUENCY = {
    'hz': true,
    'khz': true
};

// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
var RESOLUTION = {
    'dpi': true,
    'dpcm': true,
    'dppx': true,
    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
};

// https://drafts.csswg.org/css-grid/#fr-unit
var FLEX = {
    'fr': true
};

// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
var DECIBEL = {
    'db': true
};

// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
var SEMITONES = {
    'st': true
};

// safe char code getter
function charCode(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
    return cmpStr$3(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
    for (var i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
            return true;
        }
    }

    return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
        return false;
    }

    return (
        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
        isDigit$3(str.charCodeAt(offset + 1))
    );
}

function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
        var num = Number(
            numEnd !== undefined && numEnd !== value.length
                ? value.substr(0, numEnd)
                : value
        );

        if (isNaN(num)) {
            return true;
        }

        if (opts.min !== null && num < opts.min) {
            return true;
        }

        if (opts.max !== null && num > opts.max) {
            return true;
        }
    }

    return false;
}

function consumeFunction(token, getNextToken) {
    var startIdx = token.index;
    var length = 0;

    // balanced token consuming
    do {
        length++;

        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
    return function(token, getNextToken, opts) {
        if (token === null) {
            return 0;
        }

        if (token.type === TYPE$C.Function && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
        }

        return next(token, getNextToken, opts);
    };
}

function tokenType(expectedTokenType) {
    return function(token) {
        if (token === null || token.type !== expectedTokenType) {
            return 0;
        }

        return 1;
    };
}

function func(name) {
    name = name + '(';

    return function(token, getNextToken) {
        if (token !== null && eqStr(token.value, name)) {
            return consumeFunction(token, getNextToken);
        }

        return 0;
    };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that propertyâ€™s value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
    if (token === null || token.type !== TYPE$C.Ident) {
        return 0;
    }

    var name = token.value.toLowerCase();

    // The CSS-wide keywords are not valid <custom-ident>s
    if (eqStrAny(name, cssWideKeywords$1)) {
        return 0;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (eqStr(name, 'default')) {
        return 0;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if anyâ€”for example by saying that any pre-defined keywords
    // in that propertyâ€™s value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.

    return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: itâ€™s defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== TYPE$C.Ident) {
        return 0;
    }

    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesnâ€™t matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
    if (token === null || token.type !== TYPE$C.Hash) {
        return 0;
    }

    var length = token.value.length;

    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
    }

    for (var i = 1; i < length; i++) {
        if (!isHexDigit$1(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    return 1;
}

function idSelector(token) {
    if (token === null || token.type !== TYPE$C.Hash) {
        return 0;
    }

    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var length = 0;
    var level = 0;
    var startIdx = token.index;

    // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE$C.BadString:
            case TYPE$C.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE$C.RightCurlyBracket:
            case TYPE$C.RightParenthesis:
            case TYPE$C.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                level--;
                break;

            // ... or top-level <semicolon-token> tokens
            case TYPE$C.Semicolon:
                if (level === 0) {
                    break scan;
                }

                break;

            // ... or <delim-token> tokens with a value of "!"
            case TYPE$C.Delim:
                if (token.value === '!' && level === 0) {
                    break scan;
                }

                break;

            case TYPE$C.Function:
            case TYPE$C.LeftParenthesis:
            case TYPE$C.LeftSquareBracket:
            case TYPE$C.LeftCurlyBracket:
                level++;
                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var startIdx = token.index;
    var length = 0;

    // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE$C.BadString:
            case TYPE$C.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE$C.RightCurlyBracket:
            case TYPE$C.RightParenthesis:
            case TYPE$C.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// =========================
// Dimensions
//

function dimension(type) {
    return function(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE$C.Dimension) {
            return 0;
        }

        var numberEnd = consumeNumber$3(token.value, 0);

        // check unit
        if (type !== null) {
            // check for IE postfix hack, i.e. 123px\0 or 123px\9
            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);

            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
                return 0;
            }
        }

        // check range if specified
        if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Percentage
//

// Â§5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== TYPE$C.Percentage) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
    }

    return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
    if (typeof next !== 'function') {
        next = function() {
            return 0;
        };
    }

    return function(token, getNextToken, opts) {
        if (token !== null && token.type === TYPE$C.Number) {
            if (Number(token.value) === 0) {
                return 1;
            }
        }

        return next(token, getNextToken, opts);
    };
}

// Â§ 5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number(token, getNextToken, opts) {
    if (token === null) {
        return 0;
    }

    var numberEnd = consumeNumber$3(token.value, 0);
    var isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
    }

    return 1;
}

// Â§5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== TYPE$C.Number) {
        return 0;
    }

    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integerâ€™s sign.
    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    for (; i < token.value.length; i++) {
        if (!isDigit$3(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    // check range if specified
    if (outOfRange(opts, token.value, i)) {
        return 0;
    }

    return 1;
}

var generic$1 = {
    // token types
    'ident-token': tokenType(TYPE$C.Ident),
    'function-token': tokenType(TYPE$C.Function),
    'at-keyword-token': tokenType(TYPE$C.AtKeyword),
    'hash-token': tokenType(TYPE$C.Hash),
    'string-token': tokenType(TYPE$C.String),
    'bad-string-token': tokenType(TYPE$C.BadString),
    'url-token': tokenType(TYPE$C.Url),
    'bad-url-token': tokenType(TYPE$C.BadUrl),
    'delim-token': tokenType(TYPE$C.Delim),
    'number-token': tokenType(TYPE$C.Number),
    'percentage-token': tokenType(TYPE$C.Percentage),
    'dimension-token': tokenType(TYPE$C.Dimension),
    'whitespace-token': tokenType(TYPE$C.WhiteSpace),
    'CDO-token': tokenType(TYPE$C.CDO),
    'CDC-token': tokenType(TYPE$C.CDC),
    'colon-token': tokenType(TYPE$C.Colon),
    'semicolon-token': tokenType(TYPE$C.Semicolon),
    'comma-token': tokenType(TYPE$C.Comma),
    '[-token': tokenType(TYPE$C.LeftSquareBracket),
    ']-token': tokenType(TYPE$C.RightSquareBracket),
    '(-token': tokenType(TYPE$C.LeftParenthesis),
    ')-token': tokenType(TYPE$C.RightParenthesis),
    '{-token': tokenType(TYPE$C.LeftCurlyBracket),
    '}-token': tokenType(TYPE$C.RightCurlyBracket),

    // token type aliases
    'string': tokenType(TYPE$C.String),
    'ident': tokenType(TYPE$C.Ident),

    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'an-plus-b': anPlusB,
    'urange': urange,
    'declaration-value': declarationValue,
    'any-value': anyValue,

    // dimensions
    'dimension': calc(dimension(null)),
    'angle': calc(dimension(ANGLE)),
    'decibel': calc(dimension(DECIBEL)),
    'frequency': calc(dimension(FREQUENCY)),
    'flex': calc(dimension(FLEX)),
    'length': calc(zero(dimension(LENGTH))),
    'resolution': calc(dimension(RESOLUTION)),
    'semitones': calc(dimension(SEMITONES)),
    'time': calc(dimension(TIME)),

    // percentage
    'percentage': calc(percentage),

    // numeric
    'zero': zero(),
    'number': calc(number),
    'integer': calc(integer),

    // old IE stuff
    '-ms-legacy-expression': func('expression')
};

var createCustomError = createCustomError$3;

var _SyntaxError = function SyntaxError(message, input, offset) {
    var error = createCustomError('SyntaxError', message);

    error.input = input;
    error.offset = offset;
    error.rawMessage = message;
    error.message = error.rawMessage + '\n' +
        '  ' + error.input + '\n' +
        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

    return error;
};

var SyntaxError$3 = _SyntaxError;

var TAB$1 = 9;
var N$3 = 10;
var F$2 = 12;
var R$2 = 13;
var SPACE$2 = 32;

var Tokenizer$1 = function(str) {
    this.str = str;
    this.pos = 0;
};

Tokenizer$1.prototype = {
    charCodeAt: function(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    },
    charCode: function() {
        return this.charCodeAt(this.pos);
    },
    nextCharCode: function() {
        return this.charCodeAt(this.pos + 1);
    },
    nextNonWsCode: function(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    },
    findWsEnd: function(pos) {
        for (; pos < this.str.length; pos++) {
            var code = this.str.charCodeAt(pos);
            if (code !== R$2 && code !== N$3 && code !== F$2 && code !== SPACE$2 && code !== TAB$1) {
                break;
            }
        }

        return pos;
    },
    substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
    },
    eat: function(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    },
    peek: function() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    },
    error: function(message) {
        throw new SyntaxError$3(message, this.str, this.pos);
    }
};

var tokenizer$1 = Tokenizer$1;

var Tokenizer = tokenizer$1;
var TAB = 9;
var N$2 = 10;
var F$1 = 12;
var R$1 = 13;
var SPACE$1 = 32;
var EXCLAMATIONMARK$3 = 33;    // !
var NUMBERSIGN$4 = 35;         // #
var AMPERSAND$1 = 38;          // &
var APOSTROPHE = 39;         // '
var LEFTPARENTHESIS$7 = 40;    // (
var RIGHTPARENTHESIS$7 = 41;   // )
var ASTERISK$6 = 42;           // *
var PLUSSIGN$6 = 43;           // +
var COMMA$4 = 44;              // ,
var HYPERMINUS = 45;         // -
var LESSTHANSIGN = 60;       // <
var GREATERTHANSIGN$2 = 62;    // >
var QUESTIONMARK$1 = 63;       // ?
var COMMERCIALAT = 64;       // @
var LEFTSQUAREBRACKET$4 = 91;  // [
var RIGHTSQUAREBRACKET$2 = 93; // ]
var LEFTCURLYBRACKET$4 = 123;  // {
var VERTICALLINE$3 = 124;      // |
var RIGHTCURLYBRACKET$2 = 125; // }
var INFINITY = 8734;         // âˆž
var NAME_CHAR = createCharMap(function(ch) {
    return /[a-zA-Z0-9\-]/.test(ch);
});
var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function createCharMap(fn) {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    for (var i = 0; i < 128; i++) {
        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
    }
    return array;
}

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
    );
}

function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    var min = null;
    var max = null;

    tokenizer.eat(LEFTCURLYBRACKET$4);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA$4) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET$2) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET$2);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    var range = null;
    var comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK$6:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case PLUSSIGN$6:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case QUESTIONMARK$1:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case NUMBERSIGN$4:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === LEFTCURLYBRACKET$4) {
                range = readMultiplierRange(tokenizer);
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case LEFTCURLYBRACKET$4:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma: comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    var multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;
        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    var ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty$1(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name: name
    });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notationâ€”[min,max]â€”within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    var min = null; // -Infinity
    var max = null; // Infinity
    var sign = 1;

    tokenizer.eat(LEFTSQUAREBRACKET$4);

    if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        min = sign * Number(scanNumber(tokenizer));
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA$4);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        sign = 1;

        if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
        }

        max = sign * Number(scanNumber(tokenizer));
    }

    tokenizer.eat(RIGHTSQUAREBRACKET$2);

    // If no range is indicated, either by using the bracketed range notation
    // or in the property description, then [âˆ’âˆž,âˆž] is assumed.
    if (min === null && max === null) {
        return null;
    }

    return {
        type: 'Range',
        min: min,
        max: max
    };
}

function readType(tokenizer) {
    var name;
    var opts = null;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$7 &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS$7) {
        tokenizer.pos += 2;
        name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET$4) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name: name,
        opts: opts
    });
}

function readKeywordOrFunction(tokenizer) {
    var name;

    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$7) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name: name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name: name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms: terms,
            combinator: combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms: terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    var result;

    tokenizer.eat(LEFTSQUAREBRACKET$4);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET$2);

    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK$3) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET$2:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET$4:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
                ? readProperty$1(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE$3:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.nextCharCode() === VERTICALLINE$3
                        ? tokenizer.pos + 2
                        : tokenizer.pos + 1
                )
            };

        case AMPERSAND$1:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND$1);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA$4:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case SPACE$1:
        case TAB:
        case N$2:
        case R$1:
        case F$1:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK$6:
        case PLUSSIGN$6:
        case QUESTIONMARK$1:
        case NUMBERSIGN$4:
        case EXCLAMATIONMARK$3:
            // prohibited tokens (used as a multiplier start)
            break;

        case LEFTCURLYBRACKET$4:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse$3(source) {
    var tokenizer = new Tokenizer(source);
    var result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== source.length) {
        tokenizer.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        result = result.terms[0];
    }

    return result;
}

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
parse$3('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

var parse_1 = parse$3;

var noop$2 = function() {};

function ensureFunction$1(value) {
    return typeof value === 'function' ? value : noop$2;
}

var walk$d = function(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    var enter = noop$2;
    var leave = noop$2;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = ensureFunction$1(options.enter);
        leave = ensureFunction$1(options.leave);
    }

    if (enter === noop$2 && leave === noop$2) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node);
};

var tokenize$2 = tokenizer$3;
var TokenStream$2 = TokenStream_1;
var tokenStream = new TokenStream$2();
var astToTokens = {
    decorator: function(handlers) {
        var curNode = null;
        var prev = { len: 0, node: null };
        var nodes = [prev];
        var buffer = '';

        return {
            children: handlers.children,
            node: function(node) {
                var tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            chunk: function(chunk) {
                buffer += chunk;
                if (prev.node !== curNode) {
                    nodes.push({
                        len: chunk.length,
                        node: curNode
                    });
                } else {
                    prev.len += chunk.length;
                }
            },
            result: function() {
                return prepareTokens$1(buffer, nodes);
            }
        };
    }
};

function prepareTokens$1(str, nodes) {
    var tokens = [];
    var nodesOffset = 0;
    var nodesIndex = 0;
    var currentNode = nodes ? nodes[nodesIndex].node : null;

    tokenize$2(str, tokenStream);

    while (!tokenStream.eof) {
        if (nodes) {
            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
                nodesOffset += nodes[nodesIndex++].len;
                currentNode = nodes[nodesIndex].node;
            }
        }

        tokens.push({
            type: tokenStream.tokenType,
            value: tokenStream.getTokenValue(),
            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
            node: currentNode
        });
        tokenStream.next();
        // console.log({ ...tokens[tokens.length - 1], node: undefined });
    }

    return tokens;
}

var prepareTokens_1 = function(value, syntax) {
    if (typeof value === 'string') {
        return prepareTokens$1(value, null);
    }

    return syntax.generate(value, astToTokens);
};

var parse$2 = parse_1;

var MATCH$1 = { type: 'Match' };
var MISMATCH$1 = { type: 'Mismatch' };
var DISALLOW_EMPTY$1 = { type: 'DisallowEmpty' };
var LEFTPARENTHESIS$6 = 40;  // (
var RIGHTPARENTHESIS$6 = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH$1 && elseBranch === MISMATCH$1) {
        return match;
    }

    if (match === MATCH$1 && thenBranch === MATCH$1 && elseBranch === MATCH$1) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH$1 && thenBranch === MATCH$1) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match: match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$6 &&
        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$6
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ':
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            var result = MATCH$1;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH$1
                );
            }
            return result;

        case '|':
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            var result = MISMATCH$1;
            var map = null;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map: map
                            },
                            MATCH$1,
                            result
                        );
                    }

                    if (map !== null) {
                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH$1,
                    result
                );
            }
            return result;

        case '&&':
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            var result = MISMATCH$1;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH$1;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;

        case '||':
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: false
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            var result = atLeastOneTermMatched ? MATCH$1 : MISMATCH$1;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH$1;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;
    }
}

function buildMultiplierMatchGraph(node) {
    var result = MATCH$1;
    var matchTerm = buildMatchGraph$1(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY$1,
            MISMATCH$1
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH$1
        );

        result.then = createCondition(
            MATCH$1,
            MATCH$1,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH$1
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (var i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH$1) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH$1
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH$1,
                    MATCH$1,
                    result
                ),
                MISMATCH$1
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH$1,
            MATCH$1,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (var i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH$1) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH$1
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH$1
            );
        }
    }

    return result;
}

function buildMatchGraph$1(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group':
            var result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraph$1),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY$1,
                    MISMATCH$1
                );
            }

            return result;

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

var matchGraph$1 = {
    MATCH: MATCH$1,
    MISMATCH: MISMATCH$1,
    DISALLOW_EMPTY: DISALLOW_EMPTY$1,
    buildMatchGraph: function(syntaxTree, ref) {
        if (typeof syntaxTree === 'string') {
            syntaxTree = parse$2(syntaxTree);
        }

        return {
            type: 'MatchGraph',
            match: buildMatchGraph$1(syntaxTree),
            syntax: ref || null,
            source: syntaxTree
        };
    }
};

var hasOwnProperty$9 = Object.prototype.hasOwnProperty;
var matchGraph = matchGraph$1;
var MATCH = matchGraph.MATCH;
var MISMATCH = matchGraph.MISMATCH;
var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
var TYPE$B = _const.TYPE;

var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;

var EXIT_REASON_MATCH = 'Match';
var EXIT_REASON_MISMATCH = 'Mismatch';
var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

var ITERATION_LIMIT = 15000;
var totalIterationCount = 0;

function reverseList(list) {
    var prev = null;
    var next = null;
    var item = list;

    while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
    }

    return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
        return false;
    }

    for (var i = 0; i < testStr.length; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i);

        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
        if (testCode >= 0x0041 && testCode <= 0x005A) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function isContextEdgeDelim(token) {
    if (token.type !== TYPE$B.Delim) {
        return false;
    }

    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead
    return token.value !== '?';
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE$B.Comma ||
        token.type === TYPE$B.Function ||
        token.type === TYPE$B.LeftParenthesis ||
        token.type === TYPE$B.LeftSquareBracket ||
        token.type === TYPE$B.LeftCurlyBracket ||
        isContextEdgeDelim(token)
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE$B.RightParenthesis ||
        token.type === TYPE$B.RightSquareBracket ||
        token.type === TYPE$B.RightCurlyBracket ||
        token.type === TYPE$B.Delim
    );
}

function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
        do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === TYPE$B.WhiteSpace || token.type === TYPE$B.Comment));
    }

    function getNextToken(offset) {
        var nextIndex = tokenIndex + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
        return {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            thenStack: thenStack,
            tokenIndex: tokenIndex,
            prev: prev
        };
    }

    function pushThenStack(nextState) {
        thenStack = {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token: token,
            prev: matchStack
        };

        moveToNextToken();
        syntaxStash = null;

        if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
        }
    }

    function openSyntax() {
        syntaxStack = {
            syntax: state.syntax,
            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    var syntaxStack = null;
    var thenStack = null;
    var elseStack = null;

    // null â€“ stashing allowed, nothing stashed
    // false â€“ stashing disabled, nothing stashed
    // anithing else â€“ fail stashable syntaxes, some syntax stashed
    var syntaxStash = null;

    var iterationCount = 0; // count iterations and prevent infinite loop
    var exitReason = null;

    var token = null;
    var tokenIndex = -1;
    var longestMatch = 0;
    var matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
    };

    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        // function mapList(list, fn) {
        //     var result = [];
        //     while (list) {
        //         result.unshift(fn(list));
        //         list = list.prev;
        //     }
        //     return result;
        // }
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
        //         token: token && token.value,
        //         tokenIndex,
        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
        //     }, { depth: null })
        // );
        switch (state.type) {
            case 'Match':
                if (thenStack === null) {
                    // turn to MISMATCH when some tokens left unmatched
                    if (token !== null) {
                        // doesn't mismatch if just one token left and it's an IE hack
                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                            state = MISMATCH;
                            break;
                        }
                    }

                    // break the main loop, return a result - MATCH
                    exitReason = EXIT_REASON_MATCH;
                    break;
                }

                // go to next syntax (`then` branch)
                state = thenStack.nextState;

                // check match is not empty
                if (state === DISALLOW_EMPTY) {
                    if (thenStack.matchStack === matchStack) {
                        state = MISMATCH;
                        break;
                    } else {
                        state = MATCH;
                    }
                }

                // close syntax if needed
                while (thenStack.syntaxStack !== syntaxStack) {
                    closeSyntax();
                }

                // pop stack
                thenStack = thenStack.prev;
                break;

            case 'Mismatch':
                // when some syntax is stashed
                if (syntaxStash !== null && syntaxStash !== false) {
                    // there is no else branches or a branch reduce match stack
                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                        // restore state from the stash
                        elseStack = syntaxStash;
                        syntaxStash = false; // disable stashing
                    }
                } else if (elseStack === null) {
                    // no else branches -> break the main loop
                    // return a result - MISMATCH
                    exitReason = EXIT_REASON_MISMATCH;
                    break;
                }

                // go to next syntax (`else` branch)
                state = elseStack.nextState;

                // restore all the rest stack states
                thenStack = elseStack.thenStack;
                syntaxStack = elseStack.syntaxStack;
                matchStack = elseStack.matchStack;
                tokenIndex = elseStack.tokenIndex;
                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

                // pop stack
                elseStack = elseStack.prev;
                break;

            case 'MatchGraph':
                state = state.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (state.else !== MISMATCH) {
                    pushElseStack(state.else);
                }

                if (state.then !== MATCH) {
                    pushThenStack(state.then);
                }

                state = state.match;
                break;

            case 'MatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer':
                var terms = state.syntax.terms;

                if (state.index === terms.length) {
                    // no matches at all or it's required all terms to be matched
                    if (state.mask === 0 || state.syntax.all) {
                        state = MISMATCH;
                        break;
                    }

                    // a partial match is ok
                    state = MATCH;
                    break;
                }

                // all terms are matched
                if (state.mask === (1 << terms.length) - 1) {
                    state = MATCH;
                    break;
                }

                for (; state.index < terms.length; state.index++) {
                    var matchFlag = 1 << state.index;

                    if ((state.mask & matchFlag) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(state);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            syntax: state.syntax,
                            mask: state.mask | matchFlag
                        });

                        // match
                        state = terms[state.index++];
                        break;
                    }
                }
                break;

            case 'AddMatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state.syntax,
                    index: 0,
                    mask: state.mask
                };
                break;

            case 'Enum':
                if (token !== null) {
                    var name = token.value.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (name.indexOf('\\') !== -1) {
                        name = name.replace(/\\[09].*$/, '');
                    }

                    if (hasOwnProperty$9.call(state.map, name)) {
                        state = state.map[name];
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'Generic':
                var opts = syntaxStack !== null ? syntaxStack.opts : null;
                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            case 'Type':
            case 'Property':
                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
                var dictSyntax = hasOwnProperty$9.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

                if (!dictSyntax || !dictSyntax.match) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (state.type === 'Type'
                            ? '<' + state.name + '>'
                            : '<\'' + state.name + '\'>')
                    );
                }

                // stash a syntax for types with low priority
                if (syntaxStash !== false && token !== null && state.type === 'Type') {
                    var lowPriorityMatching =
                        // https://drafts.csswg.org/css-values-4/#custom-idents
                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                        // can only claim the keyword if no other unfulfilled production can claim it.
                        (state.name === 'custom-ident' && token.type === TYPE$B.Ident) ||

                        // https://drafts.csswg.org/css-values-4/#lengths
                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                        // it must parse as a <number>
                        (state.name === 'length' && token.value === '0');

                    if (lowPriorityMatching) {
                        if (syntaxStash === null) {
                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                        }

                        state = MISMATCH;
                        break;
                    }
                }

                openSyntax();
                state = dictSyntax.match;
                break;

            case 'Keyword':
                var name = state.name;

                if (token !== null) {
                    var keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
                        addTokenToMatch();
                        state = MATCH;
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'AtKeyword':
            case 'Function':
                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === state.value) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.type === TYPE$B.Comma) {
                    if (isCommaContextStart(matchStack.token)) {
                        state = MISMATCH;
                    } else {
                        addTokenToMatch();
                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
                    }
                } else {
                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
                }

                break;

            case 'String':
                var string = '';

                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
                    string += tokens[lastTokenIndex].value;
                }

                if (areStringsEqualCaseInsensitive(string, state.value)) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            default:
                throw new Error('Unknown node type: ' + state.type);
        }
    }

    totalIterationCount += iterationCount;

    switch (exitReason) {
        case null:
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;

        case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
                closeSyntax();
            }
            break;

        default:
            matchStack = null;
    }

    return {
        tokens: tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch: longestMatch
    };
}

function matchAsList(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
        var item = reverseList(matchResult.match).prev;

        matchResult.match = [];

        while (item !== null) {
            switch (item.type) {
                case STUB:
                    break;

                case OPEN_SYNTAX:
                case CLOSE_SYNTAX:
                    matchResult.match.push({
                        type: item.type,
                        syntax: item.syntax
                    });
                    break;

                default:
                    matchResult.match.push({
                        token: item.token.value,
                        node: item.token.node
                    });
                    break;
            }

            item = item.prev;
        }
    }

    return matchResult;
}

function matchAsTree$1(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    var item = matchResult.match;
    var host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    var hostStack = [host];

    // revert a list and start with 2nd item since 1st is a stub item
    item = reverseList(item).prev;

    // build a tree
    while (item !== null) {
        switch (item.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: item.syntax,
                    match: []
                });
                hostStack.push(host);
                break;

            case CLOSE_SYNTAX:
                hostStack.pop();
                host = hostStack[hostStack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: item.syntax || null,
                    token: item.token.value,
                    node: item.token.node
                });
        }

        item = item.prev;
    }

    return matchResult;
}

var match = {
    matchAsList: matchAsList,
    matchAsTree: matchAsTree$1,
    getTotalIterationCount: function() {
        return totalIterationCount;
    }
};

function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (var i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    var result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function testNode(match, node, fn) {
    var trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

function isType(node, type) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Type' && matchNode.name === type;
    });
}

function isProperty(node, property) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Property' && matchNode.name === property;
    });
}

function isKeyword(node) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Keyword';
    });
}

var trace$1 = {
    getTrace: getTrace,
    isType: isType,
    isProperty: isProperty,
    isKeyword: isKeyword
};

var List$c = List_1;

function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    var nodes = new List$c();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes: nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    var fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

var search$1 = {
    matchFragments: matchFragments
};

var List$b = List_1;
var hasOwnProperty$8 = Object.prototype.hasOwnProperty;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (var key in node) {
            var valid = true;

            if (hasOwnProperty$8.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
                    var fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List$b;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (var key in fields) {
            if (hasOwnProperty$8.call(fields, key) &&
                hasOwnProperty$8.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    var structure = nodeType.structure;
    var fields = {
        type: String,
        loc: true
    };
    var docs = {
        type: '"' + name + '"'
    };

    for (var key in structure) {
        if (hasOwnProperty$8.call(structure, key) === false) {
            continue;
        }

        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs: docs,
        check: createNodeStructureChecker(name, fields)
    };
}

var structure = {
    getStructureFromConfig: function(config) {
        var structure = {};

        if (config.node) {
            for (var name in config.node) {
                if (hasOwnProperty$8.call(config.node, name)) {
                    var nodeType = config.node[name];

                    if (nodeType.structure) {
                        structure[name] = processStructure(name, nodeType);
                    } else {
                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
                    }
                }
            }
        }

        return structure;
    }
};

var SyntaxReferenceError = error$1.SyntaxReferenceError;
var SyntaxMatchError = error$1.SyntaxMatchError;
var names$1 = names$2;
var generic = generic$1;
var parse$1 = parse_1;
var generate$6 = generate_1;
var walk$c = walk$d;
var prepareTokens = prepareTokens_1;
var buildMatchGraph = matchGraph$1.buildMatchGraph;
var matchAsTree = match.matchAsTree;
var trace = trace$1;
var search = search$1;
var getStructureFromConfig = structure.getStructureFromConfig;
var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

function dumpMapSyntax(map, compact, syntaxAsAst) {
    var result = {};

    for (var name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst
                ? map[name].syntax
                : generate$6(map[name].syntax, { compact: compact });
        }
    }

    return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
            prelude: atrule.prelude && (
                syntaxAsAst
                    ? atrule.prelude.syntax
                    : generate$6(atrule.prelude.syntax, { compact })
            ),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
    }

    return result;
}

function valueHasVar(tokens) {
    for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === 'var(') {
            return true;
        }
    }

    return false;
}

function buildMatchResult(match, error, iterations) {
    return {
        matched: match,
        iterations: iterations,
        error: error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
    };
}

function matchSyntax(lexer, syntax, value, useCommon) {
    var tokens = prepareTokens(value, lexer.syntax);
    var result;

    if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCommon) {
        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
    }

    if (!useCommon || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new SyntaxMatchError(result.reason, syntax.syntax, value, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

var Lexer$1 = function(config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.atrules = {};
    this.properties = {};
    this.types = {};
    this.structure = structure || getStructureFromConfig(config);

    if (config) {
        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.atrules) {
            for (var name in config.atrules) {
                this.addAtrule_(name, config.atrules[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
};

Lexer$1.prototype = {
    structure: {},
    checkStructure: function(ast) {
        function collectWarning(node, message) {
            warns.push({
                node: node,
                message: message
            });
        }

        var structure = this.structure;
        var warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    },

    createDescriptor: function(syntax, type, name, parent = null) {
        var ref = {
            type: type,
            name: name
        };
        var descriptor = {
            type: type,
            name: name,
            parent: parent,
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get: function() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse$1(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            // lazy graph build on first access
            Object.defineProperty(descriptor, 'match', {
                get: function() {
                    Object.defineProperty(descriptor, 'match', {
                        value: buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    },
    addAtrule_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.atrules[name] = {
            type: 'Atrule',
            name: name,
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
            descriptors: syntax.descriptors
                ? Object.keys(syntax.descriptors).reduce((res, descName) => {
                    res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
                    return res;
                }, {})
                : null
        };
    },
    addProperty_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    },
    addType_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.types[name] = this.createDescriptor(syntax, 'Type', name);

        if (syntax === generic['-ms-legacy-expression']) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
    },

    checkAtruleName: function(atruleName) {
        if (!this.getAtrule(atruleName)) {
            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
        }
    },
    checkAtrulePrelude: function(atruleName, prelude) {
        let error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        var atrule = this.getAtrule(atruleName);

        if (!atrule.prelude && prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
        }

        if (atrule.prelude && !prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
        }
    },
    checkAtruleDescriptorName: function(atruleName, descriptorName) {
        let error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        var atrule = this.getAtrule(atruleName);
        var descriptor = names$1.keyword(descriptorName);

        if (!atrule.descriptors) {
            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
        }

        if (!atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]) {
            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
        }
    },
    checkPropertyName: function(propertyName) {
        var property = names$1.property(propertyName);

        // don't match syntax for a custom property
        if (property.custom) {
            return new Error('Lexer matching doesn\'t applicable for custom properties');
        }

        if (!this.getProperty(propertyName)) {
            return new SyntaxReferenceError('Unknown property', propertyName);
        }
    },

    matchAtrulePrelude: function(atruleName, prelude) {
        var error = this.checkAtrulePrelude(atruleName, prelude);

        if (error) {
            return buildMatchResult(null, error);
        }

        if (!prelude) {
            return buildMatchResult(null, null);
        }

        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
    },
    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);

        if (error) {
            return buildMatchResult(null, error);
        }

        var atrule = this.getAtrule(atruleName);
        var descriptor = names$1.keyword(descriptorName);

        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    },
    matchDeclaration: function(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    },
    matchProperty: function(propertyName, value) {
        var error = this.checkPropertyName(propertyName);

        if (error) {
            return buildMatchResult(null, error);
        }

        return matchSyntax(this, this.getProperty(propertyName), value, true);
    },
    matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    },
    match: function(syntax, value) {
        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (typeof syntax === 'string' || !syntax.match) {
            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
        }

        return matchSyntax(this, syntax, value, false);
    },

    findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    },
    findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    },
    findAllFragments: function(ast, type, name) {
        var result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: function(declaration) {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }.bind(this)
        });

        return result;
    },

    getAtrule: function(atruleName, fallbackBasename = true) {
        var atrule = names$1.keyword(atruleName);
        var atruleEntry = atrule.vendor && fallbackBasename
            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
            : this.atrules[atrule.name];

        return atruleEntry || null;
    },
    getAtrulePrelude: function(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);

        return atrule && atrule.prelude || null;
    },
    getAtruleDescriptor: function(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
    },
    getProperty: function(propertyName, fallbackBasename = true) {
        var property = names$1.property(propertyName);
        var propertyEntry = property.vendor && fallbackBasename
            ? this.properties[property.name] || this.properties[property.basename]
            : this.properties[property.name];

        return propertyEntry || null;
    },
    getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
    },

    validate: function() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
                return broken[name];
            }

            broken[name] = false;
            if (descriptor.syntax !== null) {
                walk$c(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken[name] = true;
                    }
                }, this);
            }
        }

        var brokenTypes = {};
        var brokenProperties = {};

        for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
            return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
            return brokenProperties[name];
        });

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    },
    dump: function(syntaxAsAst, pretty) {
        return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
    },
    toString: function() {
        return JSON.stringify(this.dump());
    }
};

var Lexer_1 = Lexer$1;

var definitionSyntax$1 = {
    SyntaxError: _SyntaxError,
    parse: parse_1,
    generate: generate_1,
    walk: walk$d
};

var adoptBuffer = adoptBuffer$2;
var isBOM = tokenizer$3.isBOM;

var N$1 = 10;
var F = 12;
var R = 13;

function computeLinesAndColumns(host, source) {
    var sourceLength = source.length;
    var lines = adoptBuffer(host.lines, sourceLength); // +1
    var line = host.startLine;
    var columns = adoptBuffer(host.columns, sourceLength);
    var column = host.startColumn;
    var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;

    for (var i = startOffset; i < sourceLength; i++) { // -1
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N$1 || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$1) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    host.lines = lines;
    host.columns = columns;
}

var OffsetToLocation$1 = function() {
    this.lines = null;
    this.columns = null;
    this.linesAndColumnsComputed = false;
};

OffsetToLocation$1.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        this.source = source;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAndColumnsComputed = false;
    },

    ensureLinesAndColumnsComputed: function() {
        if (!this.linesAndColumnsComputed) {
            computeLinesAndColumns(this, this.source);
            this.linesAndColumnsComputed = true;
        }
    },
    getLocation: function(offset, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },
    getLocationRange: function(start, end, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    }
};

var OffsetToLocation_1 = OffsetToLocation$1;

var TYPE$A = tokenizer$3.TYPE;
var WHITESPACE$a = TYPE$A.WhiteSpace;
var COMMENT$8 = TYPE$A.Comment;

var sequence$1 = function readSequence(recognizer) {
    var children = this.createList();
    var child = null;
    var context = {
        recognizer: recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
    };

    this.scanner.skipSC();

    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT$8:
                this.scanner.next();
                continue;

            case WHITESPACE$a:
                if (context.ignoreWS) {
                    this.scanner.next();
                } else {
                    context.space = this.WhiteSpace();
                }
                continue;
        }

        child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (context.space !== null) {
            children.push(context.space);
            context.space = null;
        }

        children.push(child);

        if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
        } else {
            context.ignoreWS = false;
        }
    }

    return children;
};

var OffsetToLocation = OffsetToLocation_1;
var SyntaxError$2 = _SyntaxError$1;
var TokenStream$1 = TokenStream_1;
var List$a = List_1;
var tokenize$1 = tokenizer$3;
var constants = _const;
var { findWhiteSpaceStart, cmpStr: cmpStr$2 } = utils$7;
var sequence = sequence$1;
var noop$1 = function() {};

var TYPE$z = constants.TYPE;
var NAME$1 = constants.NAME;
var WHITESPACE$9 = TYPE$z.WhiteSpace;
var COMMENT$7 = TYPE$z.Comment;
var IDENT$g = TYPE$z.Ident;
var FUNCTION$6 = TYPE$z.Function;
var URL$4 = TYPE$z.Url;
var HASH$5 = TYPE$z.Hash;
var PERCENTAGE$3 = TYPE$z.Percentage;
var NUMBER$7 = TYPE$z.Number;
var NUMBERSIGN$3 = 0x0023; // U+0023 NUMBER SIGN (#)
var NULL = 0;

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function processConfig(config) {
    var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
    };

    if (config.parseContext) {
        for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
                case 'function':
                    parserConfig.context[name] = config.parseContext[name];
                    break;

                case 'string':
                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
                    break;
            }
        }
    }

    if (config.scope) {
        for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
        }
    }

    if (config.atrule) {
        for (var name in config.atrule) {
            var atrule = config.atrule[name];

            if (atrule.parse) {
                parserConfig.atrule[name] = atrule.parse;
            }
        }
    }

    if (config.pseudo) {
        for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];

            if (pseudo.parse) {
                parserConfig.pseudo[name] = pseudo.parse;
            }
        }
    }

    if (config.node) {
        for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
        }
    }

    return parserConfig;
}

var create$3 = function createParser(config) {
    var parser = {
        scanner: new TokenStream$1(),
        locationMap: new OffsetToLocation(),

        filename: '<unknown>',
        needPositions: false,
        onParseError: noop$1,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence,

        createList: function() {
            return new List$a();
        },
        createSingleNodeList: function(node) {
            return new List$a().appendData(node);
        },
        getFirstListNode: function(list) {
            return list && list.first();
        },
        getLastListNode: function(list) {
            return list.last();
        },

        parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.tokenIndex;

            try {
                return consumer.call(this);
            } catch (e) {
                if (this.onParseErrorThrow) {
                    throw e;
                }

                var fallbackNode = fallback.call(this, startToken);

                this.onParseErrorThrow = true;
                this.onParseError(e, fallbackNode);
                this.onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        lookupNonWSType: function(offset) {
            do {
                var type = this.scanner.lookupType(offset++);
                if (type !== WHITESPACE$9) {
                    return type;
                }
            } while (type !== NULL);

            return NULL;
        },

        eat: function(tokenType) {
            if (this.scanner.tokenType !== tokenType) {
                var offset = this.scanner.tokenStart;
                var message = NAME$1[tokenType] + ' is expected';

                // tweak message and offset
                switch (tokenType) {
                    case IDENT$g:
                        // when identifier is expected but there is a function or url
                        if (this.scanner.tokenType === FUNCTION$6 || this.scanner.tokenType === URL$4) {
                            offset = this.scanner.tokenEnd - 1;
                            message = 'Identifier is expected but function found';
                        } else {
                            message = 'Identifier is expected';
                        }
                        break;

                    case HASH$5:
                        if (this.scanner.isDelim(NUMBERSIGN$3)) {
                            this.scanner.next();
                            offset++;
                            message = 'Name is expected';
                        }
                        break;

                    case PERCENTAGE$3:
                        if (this.scanner.tokenType === NUMBER$7) {
                            offset = this.scanner.tokenEnd;
                            message = 'Percent sign is expected';
                        }
                        break;

                    default:
                        // when test type is part of another token show error for current position + 1
                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                            offset = offset + 1;
                        }
                }

                this.error(message, offset);
            }

            this.scanner.next();
        },

        consume: function(tokenType) {
            var value = this.scanner.getTokenValue();

            this.eat(tokenType);

            return value;
        },
        consumeFunctionName: function() {
            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

            this.eat(FUNCTION$6);

            return name;
        },

        getLocation: function(start, end) {
            if (this.needPositions) {
                return this.locationMap.getLocationRange(
                    start,
                    end,
                    this.filename
                );
            }

            return null;
        },
        getLocationFromList: function(list) {
            if (this.needPositions) {
                var head = this.getFirstListNode(list);
                var tail = this.getLastListNode(list);
                return this.locationMap.getLocationRange(
                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    this.filename
                );
            }

            return null;
        },

        error: function(message, offset) {
            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
                ? this.locationMap.getLocation(offset)
                : this.scanner.eof
                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))
                    : this.locationMap.getLocation(this.scanner.tokenStart);

            throw new SyntaxError$2(
                message || 'Unexpected input',
                this.scanner.source,
                location.offset,
                location.line,
                location.column
            );
        }
    };

    config = processConfig(config || {});
    for (var key in config) {
        parser[key] = config[key];
    }

    return function(source, options) {
        options = options || {};

        var context = options.context || 'default';
        var onComment = options.onComment;
        var ast;

        tokenize$1(source, parser.scanner);
        parser.locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
        );

        parser.filename = options.filename || '<unknown>';
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$1;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        if (!parser.context.hasOwnProperty(context)) {
            throw new Error('Unknown context `' + context + '`');
        }

        if (typeof onComment === 'function') {
            parser.scanner.forEachToken((type, start, end) => {
                if (type === COMMENT$7) {
                    const loc = parser.getLocation(start, end);
                    const value = cmpStr$2(source, end - 2, end, '*/')
                        ? source.slice(start + 2, end - 2)
                        : source.slice(start + 2, end);

                    onComment(value, loc);
                }
            });
        }

        ast = parser.context[context].call(parser, options);

        if (!parser.scanner.eof) {
            parser.error();
        }

        return ast;
    };
};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
base64$1.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
base64$1.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = base64$1;

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
base64Vlq.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var util$3 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

(function (exports) {
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   â€œsourcesâ€ entry.  This value is prepended to the individual
	    //   entries in the â€œsourceâ€ field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   â€œsourceRootâ€, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
} (util$3));

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$2 = util$3;
var has$1 = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet$1() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$1();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet$1.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util$2.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has$1.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet$1.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util$2.toSetString(aStr);
    return has$1.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util$2.toSetString(aStr);
    if (has$1.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet$1.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

arraySet.ArraySet = ArraySet$1;

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$1 = util$3;

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList$1() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList$1.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList$1.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList$1.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util$1.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

mappingList.MappingList = MappingList$1;

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = base64Vlq;
var util = util$3;
var ArraySet = arraySet.ArraySet;
var MappingList = mappingList.MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator$1(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator$1.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator$1.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator$1({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator$1.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator$1.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator$1.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator$1.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator$1.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator$1.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator$1.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator$1.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

sourceMapGenerator.SourceMapGenerator = SourceMapGenerator$1;

var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
var trackNodes = {
    Atrule: true,
    Selector: true,
    Declaration: true
};

var sourceMap$1 = function generateSourceMap(handlers) {
    var map = new SourceMapGenerator();
    var line = 1;
    var column = 0;
    var generated = {
        line: 1,
        column: 0
    };
    var original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    var sourceMappingActive = false;
    var activatedGenerated = {
        line: 1,
        column: 0
    };
    var activatedMapping = {
        generated: activatedGenerated
    };

    var handlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original: original,
                    generated: generated
                });
            }
        }

        handlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    var handlersChunk = handlers.chunk;
    handlers.chunk = function(chunk) {
        for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        handlersChunk(chunk);
    };

    var handlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: handlersResult(),
            map: map
        };
    };

    return handlers;
};

var sourceMap = sourceMap$1;
var hasOwnProperty$7 = Object.prototype.hasOwnProperty;

function processChildren(node, delimeter) {
    var list = node.children;
    var prev = null;

    if (typeof delimeter !== 'function') {
        list.forEach(this.node, this);
    } else {
        list.forEach(function(node) {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        }, this);
    }
}

var create$2 = function createGenerator(config) {
    function processNode(node) {
        if (hasOwnProperty$7.call(types, node.type)) {
            types[node.type].call(this, node);
        } else {
            throw new Error('Unknown node type: ' + node.type);
        }
    }

    var types = {};

    if (config.node) {
        for (var name in config.node) {
            types[name] = config.node[name].generate;
        }
    }

    return function(node, options) {
        var buffer = '';
        var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function(chunk) {
                buffer += chunk;
            },
            result: function() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = sourceMap(handlers);
            }
        }

        handlers.node(node);

        return handlers.result();
    };
};

var List$9 = List_1;

var create$1 = function createConvertors(walk) {
    return {
        fromPlainObject: function(ast) {
            walk(ast, {
                enter: function(node) {
                    if (node.children && node.children instanceof List$9 === false) {
                        node.children = new List$9().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject: function(ast) {
            walk(ast, {
                leave: function(node) {
                    if (node.children && node.children instanceof List$9) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
};

var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
        if (hasOwnProperty$6.call(structure, key) === false) {
            continue;
        }

        var fieldTypes = structure[key];
        var walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
        }

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    var types = {};

    for (var name in config.node) {
        if (hasOwnProperty$6.call(config.node, name)) {
            var nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    var fields = config.fields.slice();
    var contextName = config.context;
    var useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    }

    return function(node, context, walk, walkReducer) {
        var prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        }

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    var breakWalk = reverse
                        ? ref.reduceRight(walkReducer, false)
                        : ref.reduce(walkReducer, false);

                    if (breakWalk) {
                        return true;
                    }
                } else if (walk(ref)) {
                    return true;
                }
            }
        }

        if (useContext) {
            context[contextName] = prevContextValue;
        }
    };
}

function createFastTraveralMap(iterators) {
    return {
        Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
            DeclarationList: iterators.DeclarationList
        }
    };
}

var create = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {};
    var iteratorsReverse = {};
    var breakWalk = Symbol('break-walk');
    var skipNode = Symbol('skip-node');

    for (var name in types) {
        if (hasOwnProperty$6.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    var walk = function(root, options) {
        function walkNode(node, item, list) {
            var enterRet = enter.call(context, node, item, list);

            if (enterRet === breakWalk) {
                debugger;
                return true;
            }

            if (enterRet === skipNode) {
                return false;
            }

            if (iterators.hasOwnProperty(node.type)) {
                if (iterators[node.type](node, context, walkNode, walkReducer)) {
                    return true;
                }
            }

            if (leave.call(context, node, item, list) === breakWalk) {
                return true;
            }

            return false;
        }

        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
            break: breakWalk,
            skip: skipNode,

            root: root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function(ast, fn) {
        var found = null;

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
            }
        });

        return found;
    };

    walk.findLast = function(ast, fn) {
        var found = null;

        walk(ast, {
            reverse: true,
            enter: function(node, item, list) {
                if (fn.call(this, node, item, list)) {
                    found = node;
                    return breakWalk;
                }
            }
        });

        return found;
    };

    walk.findAll = function(ast, fn) {
        var found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            }
        });

        return found;
    };

    return walk;
};

var List$8 = List_1;

var clone$2 = function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List$8) {
                value = value.map(clone);
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
};

const hasOwnProperty$5 = Object.prototype.hasOwnProperty;
const shape$1 = {
    generic: true,
    types: appendOrAssign,
    atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
    },
    properties: appendOrAssign,
    parseContext: assign,
    scope: deepAssign,
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function isObject(value) {
    return value && value.constructor === Object;
}

function copy$1(value) {
    return isObject(value)
        ? Object.assign({}, value)
        : value;
}

function assign(dest, src) {
    return Object.assign(dest, src);
}

function deepAssign(dest, src) {
    for (const key in src) {
        if (hasOwnProperty$5.call(src, key)) {
            if (isObject(dest[key])) {
                deepAssign(dest[key], copy$1(src[key]));
            } else {
                dest[key] = copy$1(src[key]);
            }
        }
    }

    return dest;
}

function append(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
        return typeof a === 'string'
            ? a + b
            : b.replace(/^\s*\|\s*/, '');
    }

    return b || null;
}

function appendOrAssign(a, b) {
    if (typeof b === 'string') {
        return append(a, b);
    }

    const result = Object.assign({}, a);
    for (let key in b) {
        if (hasOwnProperty$5.call(b, key)) {
            result[key] = append(hasOwnProperty$5.call(a, key) ? a[key] : undefined, b[key]);
        }
    }

    return result;
}

function appendOrAssignOrNull(a, b) {
    const result = appendOrAssign(a, b);

    return !isObject(result) || Object.keys(result).length
        ? result
        : null;
}

function mix$1(dest, src, shape) {
    for (const key in shape) {
        if (hasOwnProperty$5.call(shape, key) === false) {
            continue;
        }

        if (shape[key] === true) {
            if (key in src) {
                if (hasOwnProperty$5.call(src, key)) {
                    dest[key] = copy$1(src[key]);
                }
            }
        } else if (shape[key]) {
            if (typeof shape[key] === 'function') {
                const fn = shape[key];
                dest[key] = fn({}, dest[key]);
                dest[key] = fn(dest[key] || {}, src[key]);
            } else if (isObject(shape[key])) {
                const result = {};

                for (let name in dest[key]) {
                    result[name] = mix$1({}, dest[key][name], shape[key]);
                }

                for (let name in src[key]) {
                    result[name] = mix$1(result[name] || {}, src[key][name], shape[key]);
                }

                dest[key] = result;
            } else if (Array.isArray(shape[key])) {
                const res = {};
                const innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});

                for (const [name, value] of Object.entries(dest[key] || {})) {
                    res[name] = {};
                    if (value) {
                        mix$1(res[name], value, innerShape);
                    }
                }

                for (const name in src[key]) {
                    if (hasOwnProperty$5.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {};
                        }

                        if (src[key] && src[key][name]) {
                            mix$1(res[name], src[key][name], innerShape);
                        }
                    }
                }

                dest[key] = res;
            }
        }
    }
    return dest;
}

var mix_1 = (dest, src) => mix$1(dest, src, shape$1);

var List$7 = List_1;
var SyntaxError$1 = _SyntaxError$1;
var TokenStream = TokenStream_1;
var Lexer = Lexer_1;
var definitionSyntax = definitionSyntax$1;
var tokenize = tokenizer$3;
var createParser = create$3;
var createGenerator = create$2;
var createConvertor = create$1;
var createWalker = create;
var clone$1 = clone$2;
var names = names$2;
var mix = mix_1;

function createSyntax(config) {
    var parse = createParser(config);
    var walk = createWalker(config);
    var generate = createGenerator(config);
    var convert = createConvertor(walk);

    var syntax = {
        List: List$7,
        SyntaxError: SyntaxError$1,
        TokenStream: TokenStream,
        Lexer: Lexer,

        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,

        definitionSyntax: definitionSyntax,
        lexer: null,
        createLexer: function(config) {
            return new Lexer(config, syntax, syntax.lexer.structure);
        },

        tokenize: tokenize,
        parse: parse,
        walk: walk,
        generate: generate,

        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,

        clone: clone$1,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,

        createSyntax: function(config) {
            return createSyntax(mix({}, config));
        },
        fork: function(extension) {
            var base = mix({}, config); // copy of config
            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, Object.assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
}
create$4.create = function(config) {
    return createSyntax(mix({}, config));
};

const require$$0 = {
	"@charset": {
	syntax: "@charset \"<charset>\";",
	groups: [
		"CSS Charsets"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
},
	"@counter-style": {
	syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
	interfaces: [
		"CSSCounterStyleRule"
	],
	groups: [
		"CSS Counter Styles"
	],
	descriptors: {
		"additive-symbols": {
			syntax: "[ <integer> && <symbol> ]#",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		fallback: {
			syntax: "<counter-style-name>",
			media: "all",
			initial: "decimal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		negative: {
			syntax: "<symbol> <symbol>?",
			media: "all",
			initial: "\"-\" hyphen-minus",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		pad: {
			syntax: "<integer> && <symbol>",
			media: "all",
			initial: "0 \"\"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		prefix: {
			syntax: "<symbol>",
			media: "all",
			initial: "\"\"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		range: {
			syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
			media: "all",
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"speak-as": {
			syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
			media: "all",
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		suffix: {
			syntax: "<symbol>",
			media: "all",
			initial: "\". \"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		symbols: {
			syntax: "<symbol>+",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		system: {
			syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
			media: "all",
			initial: "symbolic",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
},
	"@document": {
	syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule"
	],
	groups: [
		"CSS Conditional Rules"
	],
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
},
	"@font-face": {
	syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
	interfaces: [
		"CSSFontFaceRule"
	],
	groups: [
		"CSS Fonts"
	],
	descriptors: {
		"font-display": {
			syntax: "[ auto | block | swap | fallback | optional ]",
			media: "visual",
			percentages: "no",
			initial: "auto",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		"font-family": {
			syntax: "<family-name>",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-feature-settings": {
			syntax: "normal | <feature-tag-value>#",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"font-variation-settings": {
			syntax: "normal | [ <string> <number> ]#",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"font-stretch": {
			syntax: "<font-stretch-absolute>{1,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-style": {
			syntax: "normal | italic | oblique <angle>{0,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-weight": {
			syntax: "<font-weight-absolute>{1,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-variant": {
			syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		src: {
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"unicode-range": {
			syntax: "<unicode-range>#",
			media: "all",
			initial: "U+0-10FFFF",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
},
	"@font-feature-values": {
	syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
	interfaces: [
		"CSSFontFeatureValuesRule"
	],
	groups: [
		"CSS Fonts"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
},
	"@import": {
	syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
	groups: [
		"Media Queries"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
},
	"@keyframes": {
	syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
	interfaces: [
		"CSSKeyframeRule",
		"CSSKeyframesRule"
	],
	groups: [
		"CSS Animations"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
},
	"@media": {
	syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule",
		"CSSMediaRule",
		"CSSCustomMediaRule"
	],
	groups: [
		"CSS Conditional Rules",
		"Media Queries"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
},
	"@namespace": {
	syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
	groups: [
		"CSS Namespaces"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
},
	"@page": {
	syntax: "@page <page-selector-list> {\n  <page-body>\n}",
	interfaces: [
		"CSSPageRule"
	],
	groups: [
		"CSS Pages"
	],
	descriptors: {
		bleed: {
			syntax: "auto | <length>",
			media: [
				"visual",
				"paged"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		marks: {
			syntax: "none | [ crop || cross ]",
			media: [
				"visual",
				"paged"
			],
			initial: "none",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		size: {
			syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
			media: [
				"visual",
				"paged"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecifiedRelativeToAbsoluteLengths",
			order: "orderOfAppearance",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
},
	"@property": {
	syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
	interfaces: [
		"CSS",
		"CSSPropertyRule"
	],
	groups: [
		"CSS Houdini"
	],
	descriptors: {
		syntax: {
			syntax: "<string>",
			media: "all",
			percentages: "no",
			initial: "n/a (required)",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		inherits: {
			syntax: "true | false",
			media: "all",
			percentages: "no",
			initial: "auto",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		"initial-value": {
			syntax: "<string>",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		}
	},
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
},
	"@supports": {
	syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule",
		"CSSSupportsRule"
	],
	groups: [
		"CSS Conditional Rules"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
},
	"@viewport": {
	syntax: "@viewport {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSViewportRule"
	],
	groups: [
		"CSS Device Adaptation"
	],
	descriptors: {
		height: {
			syntax: "<viewport-length>{1,2}",
			media: [
				"visual",
				"continuous"
			],
			initial: [
				"min-height",
				"max-height"
			],
			percentages: [
				"min-height",
				"max-height"
			],
			computed: [
				"min-height",
				"max-height"
			],
			order: "orderOfAppearance",
			status: "standard"
		},
		"max-height": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToHeightOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"max-width": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToWidthOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"max-zoom": {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-height": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToHeightOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-width": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToWidthOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-zoom": {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		},
		orientation: {
			syntax: "auto | portrait | landscape",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToSizeOfBoundingBox",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"user-zoom": {
			syntax: "zoom | fixed",
			media: [
				"visual",
				"continuous"
			],
			initial: "zoom",
			percentages: "referToSizeOfBoundingBox",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"viewport-fit": {
			syntax: "auto | contain | cover",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		width: {
			syntax: "<viewport-length>{1,2}",
			media: [
				"visual",
				"continuous"
			],
			initial: [
				"min-width",
				"max-width"
			],
			percentages: [
				"min-width",
				"max-width"
			],
			computed: [
				"min-width",
				"max-width"
			],
			order: "orderOfAppearance",
			status: "standard"
		},
		zoom: {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
}
};

const all = {
	syntax: "initial | inherit | unset | revert",
	media: "noPracticalMedia",
	inherited: false,
	animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
	percentages: "no",
	groups: [
		"CSS Miscellaneous"
	],
	initial: "noPracticalInitialValue",
	appliesto: "allElements",
	computed: "asSpecifiedAppliesToEachProperty",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
};
const animation = {
	syntax: "<single-animation>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: [
		"animation-name",
		"animation-duration",
		"animation-timing-function",
		"animation-delay",
		"animation-iteration-count",
		"animation-direction",
		"animation-fill-mode",
		"animation-play-state"
	],
	appliesto: "allElementsAndPseudos",
	computed: [
		"animation-name",
		"animation-duration",
		"animation-timing-function",
		"animation-delay",
		"animation-direction",
		"animation-iteration-count",
		"animation-fill-mode",
		"animation-play-state"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
};
const appearance = {
	syntax: "none | auto | textfield | menulist-button | <compat-auto>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
};
const azimuth = {
	syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
	media: "aural",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Speech"
	],
	initial: "center",
	appliesto: "allElements",
	computed: "normalizedAngle",
	order: "orderOfAppearance",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
};
const background$1 = {
	syntax: "[ <bg-layer> , ]* <final-bg-layer>",
	media: "visual",
	inherited: false,
	animationType: [
		"background-color",
		"background-image",
		"background-clip",
		"background-position",
		"background-size",
		"background-repeat",
		"background-attachment"
	],
	percentages: [
		"background-position",
		"background-size"
	],
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"background-image",
		"background-position",
		"background-size",
		"background-repeat",
		"background-origin",
		"background-clip",
		"background-attachment",
		"background-color"
	],
	appliesto: "allElements",
	computed: [
		"background-image",
		"background-position",
		"background-size",
		"background-repeat",
		"background-origin",
		"background-clip",
		"background-attachment",
		"background-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
};
const border$1 = {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-color",
		"border-style",
		"border-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-width",
		"border-style",
		"border-color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
};
const bottom = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToContainingBlockHeight",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
};
const clear = {
	syntax: "none | left | right | both | inline-start | inline-end",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "none",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
};
const clip = {
	syntax: "<shape> | auto",
	media: "visual",
	inherited: false,
	animationType: "rectangle",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "absolutelyPositionedElements",
	computed: "autoOrRectangle",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
};
const color$2 = {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "variesFromBrowserToBrowser",
	appliesto: "allElements",
	computed: "translucentValuesRGBAOtherwiseRGB",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
};
const columns = {
	syntax: "<'column-width'> || <'column-count'>",
	media: "visual",
	inherited: false,
	animationType: [
		"column-width",
		"column-count"
	],
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: [
		"column-width",
		"column-count"
	],
	appliesto: "blockContainersExceptTableWrappers",
	computed: [
		"column-width",
		"column-count"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
};
const contain = {
	syntax: "none | strict | content | [ size || layout || style || paint ]",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
};
const content = {
	syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Generated Content"
	],
	initial: "normal",
	appliesto: "beforeAndAfterPseudos",
	computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
};
const cursor = {
	syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
	media: [
		"visual",
		"interactive"
	],
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
};
const direction = {
	syntax: "ltr | rtl",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "ltr",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
};
const display = {
	syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Display"
	],
	initial: "inline",
	appliesto: "allElements",
	computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
};
const filter = {
	syntax: "none | <filter-function-list>",
	media: "visual",
	inherited: false,
	animationType: "filterList",
	percentages: "no",
	groups: [
		"Filter Effects"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
};
const flex = {
	syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
	media: "visual",
	inherited: false,
	animationType: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	appliesto: "flexItemsAndInFlowPseudos",
	computed: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
};
const float = {
	syntax: "left | right | none | inline-start | inline-end",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "none",
	appliesto: "allElementsNoEffectIfDisplayNone",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
};
const font$1 = {
	syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
	media: "visual",
	inherited: true,
	animationType: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	percentages: [
		"font-size",
		"line-height"
	],
	groups: [
		"CSS Fonts"
	],
	initial: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	appliesto: "allElements",
	computed: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
};
const gap = {
	syntax: "<'row-gap'> <'column-gap'>?",
	media: "visual",
	inherited: false,
	animationType: [
		"row-gap",
		"column-gap"
	],
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"row-gap",
		"column-gap"
	],
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: [
		"row-gap",
		"column-gap"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
};
const grid = {
	syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-auto-rows",
		"grid-auto-columns"
	],
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-template-areas",
		"grid-auto-rows",
		"grid-auto-columns",
		"grid-auto-flow",
		"grid-column-gap",
		"grid-row-gap",
		"column-gap",
		"row-gap"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-template-areas",
		"grid-auto-rows",
		"grid-auto-columns",
		"grid-auto-flow",
		"grid-column-gap",
		"grid-row-gap",
		"column-gap",
		"row-gap"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
};
const height = {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAutoOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
};
const hyphens = {
	syntax: "none | manual | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "manual",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
};
const inset = {
	syntax: "<'top'>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
};
const isolation = {
	syntax: "auto | isolate",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
};
const left = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
};
const margin = {
	syntax: "[ <length> | <percentage> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: [
		"margin-bottom",
		"margin-left",
		"margin-right",
		"margin-top"
	],
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: [
		"margin-bottom",
		"margin-left",
		"margin-right",
		"margin-top"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
};
const mask = {
	syntax: "<mask-layer>#",
	media: "visual",
	inherited: false,
	animationType: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	percentages: [
		"mask-position"
	],
	groups: [
		"CSS Masking"
	],
	initial: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	appliesto: "allElementsSVGContainerElements",
	computed: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
};
const offset = {
	syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	percentages: [
		"offset-position",
		"offset-distance",
		"offset-anchor"
	],
	groups: [
		"CSS Motion Path"
	],
	initial: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	appliesto: "transformableElements",
	computed: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
};
const opacity = {
	syntax: "<alpha-value>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "1.0",
	appliesto: "allElements",
	computed: "specifiedValueClipped0To1",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
};
const order = {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "0",
	appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
};
const orphans = {
	syntax: "<integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "2",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
};
const outline = {
	syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: [
		"outline-color",
		"outline-width",
		"outline-style"
	],
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: [
		"outline-color",
		"outline-style",
		"outline-width"
	],
	appliesto: "allElements",
	computed: [
		"outline-color",
		"outline-width",
		"outline-style"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
};
const overflow = {
	syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: [
		"overflow-x",
		"overflow-y"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
};
const padding = {
	syntax: "[ <length> | <percentage> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: [
		"padding-bottom",
		"padding-left",
		"padding-right",
		"padding-top"
	],
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: [
		"padding-bottom",
		"padding-left",
		"padding-right",
		"padding-top"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
};
const perspective = {
	syntax: "none | <length>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "absoluteLengthOrNone",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
};
const position$1 = {
	syntax: "static | relative | absolute | sticky | fixed",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "static",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
};
const quotes = {
	syntax: "none | auto | [ <string> <string> ]+",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Generated Content"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
};
const resize = {
	syntax: "none | both | horizontal | vertical | block | inline",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "none",
	appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
};
const right = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
};
const rotate = {
	syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
};
const scale = {
	syntax: "none | <number>{1,3}",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
};
const top = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToContainingBlockHeight",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
};
const transform = {
	syntax: "none | <transform-list>",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
};
const transition = {
	syntax: "<single-transition>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: [
		"transition-delay",
		"transition-duration",
		"transition-property",
		"transition-timing-function"
	],
	appliesto: "allElementsAndPseudos",
	computed: [
		"transition-delay",
		"transition-duration",
		"transition-property",
		"transition-timing-function"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
};
const translate = {
	syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
};
const visibility = {
	syntax: "visible | hidden | collapse",
	media: "visual",
	inherited: true,
	animationType: "visibility",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "visible",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
};
const widows = {
	syntax: "<integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "2",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
};
const width = {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAutoOrAbsoluteLength",
	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
};
const zoom = {
	syntax: "normal | reset | <number> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
};
const require$$1 = {
	"--*": {
	syntax: "<declaration-value>",
	media: "all",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Variables"
	],
	initial: "seeProse",
	appliesto: "allElements",
	computed: "asSpecifiedWithVarsSubstituted",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
},
	"-ms-accelerator": {
	syntax: "false | true",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "false",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
},
	"-ms-block-progression": {
	syntax: "tb | rl | bt | lr",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "tb",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
},
	"-ms-content-zoom-chaining": {
	syntax: "none | chained",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
},
	"-ms-content-zooming": {
	syntax: "none | zoom",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "zoomForTheTopLevelNoneForTheRest",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
},
	"-ms-content-zoom-limit": {
	syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
},
	"-ms-content-zoom-limit-max": {
	syntax: "<percentage>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "maxZoomFactor",
	groups: [
		"Microsoft Extensions"
	],
	initial: "400%",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
},
	"-ms-content-zoom-limit-min": {
	syntax: "<percentage>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "minZoomFactor",
	groups: [
		"Microsoft Extensions"
	],
	initial: "100%",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
},
	"-ms-content-zoom-snap": {
	syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-content-zoom-snap-type",
		"-ms-content-zoom-snap-points"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-content-zoom-snap-type",
		"-ms-content-zoom-snap-points"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
},
	"-ms-content-zoom-snap-points": {
	syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0%, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
},
	"-ms-content-zoom-snap-type": {
	syntax: "none | proximity | mandatory",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
},
	"-ms-filter": {
	syntax: "<string>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "\"\"",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
},
	"-ms-flow-from": {
	syntax: "[ none | <custom-ident> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
},
	"-ms-flow-into": {
	syntax: "[ none | <custom-ident> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "iframeElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
},
	"-ms-grid-columns": {
	syntax: "none | <track-list> | <auto-track-list>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
},
	"-ms-grid-rows": {
	syntax: "none | <track-list> | <auto-track-list>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
},
	"-ms-high-contrast-adjust": {
	syntax: "auto | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
},
	"-ms-hyphenate-limit-chars": {
	syntax: "auto | <integer>{1,3}",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
},
	"-ms-hyphenate-limit-lines": {
	syntax: "no-limit | <integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "no-limit",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
},
	"-ms-hyphenate-limit-zone": {
	syntax: "<percentage> | <length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "referToLineBoxWidth",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
},
	"-ms-ime-align": {
	syntax: "auto | after",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
},
	"-ms-overflow-style": {
	syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
},
	"-ms-scrollbar-3dlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
},
	"-ms-scrollbar-arrow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ButtonText",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
},
	"-ms-scrollbar-base-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
},
	"-ms-scrollbar-darkshadow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDDarkShadow",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
},
	"-ms-scrollbar-face-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDFace",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
},
	"-ms-scrollbar-highlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDHighlight",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
},
	"-ms-scrollbar-shadow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDDarkShadow",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
},
	"-ms-scrollbar-track-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "Scrollbar",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
},
	"-ms-scroll-chaining": {
	syntax: "chained | none",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "chained",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
},
	"-ms-scroll-limit": {
	syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-limit-x-min",
		"-ms-scroll-limit-y-min",
		"-ms-scroll-limit-x-max",
		"-ms-scroll-limit-y-max"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-limit-x-min",
		"-ms-scroll-limit-y-min",
		"-ms-scroll-limit-x-max",
		"-ms-scroll-limit-y-max"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
},
	"-ms-scroll-limit-x-max": {
	syntax: "auto | <length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
},
	"-ms-scroll-limit-x-min": {
	syntax: "<length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
},
	"-ms-scroll-limit-y-max": {
	syntax: "auto | <length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
},
	"-ms-scroll-limit-y-min": {
	syntax: "<length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
},
	"-ms-scroll-rails": {
	syntax: "none | railed",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "railed",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
},
	"-ms-scroll-snap-points-x": {
	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0px, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
},
	"-ms-scroll-snap-points-y": {
	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0px, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
},
	"-ms-scroll-snap-type": {
	syntax: "none | proximity | mandatory",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
},
	"-ms-scroll-snap-x": {
	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-x"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-x"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
},
	"-ms-scroll-snap-y": {
	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-y"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-y"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
},
	"-ms-scroll-translation": {
	syntax: "none | vertical-to-horizontal",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
},
	"-ms-text-autospace": {
	syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
},
	"-ms-touch-select": {
	syntax: "grippers | none",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "grippers",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
},
	"-ms-user-select": {
	syntax: "none | element | text",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "text",
	appliesto: "nonReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
},
	"-ms-wrap-flow": {
	syntax: "auto | both | start | end | maximum | clear",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
},
	"-ms-wrap-margin": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "exclusionElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
},
	"-ms-wrap-through": {
	syntax: "wrap | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "wrap",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
},
	"-moz-appearance": {
	syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "noneButOverriddenInUserAgentCSS",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
},
	"-moz-binding": {
	syntax: "<url> | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
},
	"-moz-border-bottom-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
},
	"-moz-border-left-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
},
	"-moz-border-right-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
},
	"-moz-border-top-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
},
	"-moz-context-properties": {
	syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElementsThatCanReferenceImages",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
},
	"-moz-float-edge": {
	syntax: "border-box | content-box | margin-box | padding-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "content-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
},
	"-moz-force-broken-image-icon": {
	syntax: "<integer [0,1]>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "images",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
},
	"-moz-image-region": {
	syntax: "<shape> | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "auto",
	appliesto: "xulImageElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
},
	"-moz-orient": {
	syntax: "inline | block | horizontal | vertical",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "inline",
	appliesto: "anyElementEffectOnProgressAndMeter",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
},
	"-moz-outline-radius": {
	syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	percentages: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	groups: [
		"Mozilla Extensions"
	],
	initial: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	appliesto: "allElements",
	computed: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
},
	"-moz-outline-radius-bottomleft": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
},
	"-moz-outline-radius-bottomright": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
},
	"-moz-outline-radius-topleft": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
},
	"-moz-outline-radius-topright": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
},
	"-moz-stack-sizing": {
	syntax: "ignore | stretch-to-fit",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "stretch-to-fit",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
},
	"-moz-text-blink": {
	syntax: "none | blink",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
},
	"-moz-user-focus": {
	syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
},
	"-moz-user-input": {
	syntax: "auto | none | enabled | disabled",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
},
	"-moz-user-modify": {
	syntax: "read-only | read-write | write-only",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "read-only",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
},
	"-moz-window-dragging": {
	syntax: "drag | no-drag",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "drag",
	appliesto: "allElementsCreatingNativeWindows",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
},
	"-moz-window-shadow": {
	syntax: "default | menu | tooltip | sheet | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "default",
	appliesto: "allElementsCreatingNativeWindows",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
},
	"-webkit-appearance": {
	syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "noneButOverriddenInUserAgentCSS",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
},
	"-webkit-border-before": {
	syntax: "<'border-width'> || <'border-style'> || <'color'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: [
		"-webkit-border-before-width"
	],
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"color"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
},
	"-webkit-border-before-color": {
	syntax: "<'color'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-border-before-style": {
	syntax: "<'border-style'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-border-before-width": {
	syntax: "<'border-width'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"WebKit Extensions"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-box-reflect": {
	syntax: "[ above | below | right | left ]? <length>? <image>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
},
	"-webkit-line-clamp": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"WebKit Extensions",
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
},
	"-webkit-mask": {
	syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"-webkit-mask-image",
		"-webkit-mask-repeat",
		"-webkit-mask-attachment",
		"-webkit-mask-position",
		"-webkit-mask-origin",
		"-webkit-mask-clip"
	],
	appliesto: "allElements",
	computed: [
		"-webkit-mask-image",
		"-webkit-mask-repeat",
		"-webkit-mask-attachment",
		"-webkit-mask-position",
		"-webkit-mask-origin",
		"-webkit-mask-clip"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
},
	"-webkit-mask-attachment": {
	syntax: "<attachment>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "scroll",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
},
	"-webkit-mask-clip": {
	syntax: "[ <box> | border | padding | content | text ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "border",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
},
	"-webkit-mask-composite": {
	syntax: "<composite-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "source-over",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
},
	"-webkit-mask-image": {
	syntax: "<mask-reference>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "absoluteURIOrNone",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
},
	"-webkit-mask-origin": {
	syntax: "[ <box> | border | padding | content ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "padding",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
},
	"-webkit-mask-position": {
	syntax: "<position>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0% 0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
},
	"-webkit-mask-position-x": {
	syntax: "[ <length-percentage> | left | center | right ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
},
	"-webkit-mask-position-y": {
	syntax: "[ <length-percentage> | top | center | bottom ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
},
	"-webkit-mask-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
},
	"-webkit-mask-repeat-x": {
	syntax: "repeat | no-repeat | space | round",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
},
	"-webkit-mask-repeat-y": {
	syntax: "repeat | no-repeat | space | round",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
},
	"-webkit-mask-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToBackgroundPositioningArea",
	groups: [
		"WebKit Extensions"
	],
	initial: "auto auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
},
	"-webkit-overflow-scrolling": {
	syntax: "auto | touch",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
},
	"-webkit-tap-highlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "black",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
},
	"-webkit-text-fill-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
},
	"-webkit-text-stroke": {
	syntax: "<length> || <color>",
	media: "visual",
	inherited: true,
	animationType: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	appliesto: "allElements",
	computed: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	order: "canonicalOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
},
	"-webkit-text-stroke-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
},
	"-webkit-text-stroke-width": {
	syntax: "<length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "absoluteLength",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
},
	"-webkit-touch-callout": {
	syntax: "default | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "default",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
},
	"-webkit-user-modify": {
	syntax: "read-only | read-write | read-write-plaintext-only",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "read-only",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"align-content": {
	syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multilineFlexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
},
	"align-items": {
	syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
},
	"align-self": {
	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "auto",
	appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
	computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
},
	"align-tracks": {
	syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "normal",
	appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
},
	all: all,
	animation: animation,
	"animation-delay": {
	syntax: "<time>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
},
	"animation-direction": {
	syntax: "<single-animation-direction>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "normal",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
},
	"animation-duration": {
	syntax: "<time>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
},
	"animation-fill-mode": {
	syntax: "<single-animation-fill-mode>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "none",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
},
	"animation-iteration-count": {
	syntax: "<single-animation-iteration-count>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "1",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
},
	"animation-name": {
	syntax: "[ none | <keyframes-name> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "none",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
},
	"animation-play-state": {
	syntax: "<single-animation-play-state>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "running",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
},
	"animation-timing-function": {
	syntax: "<timing-function>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "ease",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
},
	appearance: appearance,
	"aspect-ratio": {
	syntax: "auto | <ratio>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
},
	azimuth: azimuth,
	"backdrop-filter": {
	syntax: "none | <filter-function-list>",
	media: "visual",
	inherited: false,
	animationType: "filterList",
	percentages: "no",
	groups: [
		"Filter Effects"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
},
	"backface-visibility": {
	syntax: "visible | hidden",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "visible",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
},
	background: background$1,
	"background-attachment": {
	syntax: "<attachment>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "scroll",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
},
	"background-blend-mode": {
	syntax: "<blend-mode>#",
	media: "none",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "normal",
	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
},
	"background-clip": {
	syntax: "<box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "border-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
},
	"background-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "transparent",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
},
	"background-image": {
	syntax: "<bg-image>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
},
	"background-origin": {
	syntax: "<box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "padding-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
},
	"background-position": {
	syntax: "<bg-position>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0% 0%",
	appliesto: "allElements",
	computed: "listEachItemTwoKeywordsOriginOffsets",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
},
	"background-position-x": {
	syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "left",
	appliesto: "allElements",
	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
},
	"background-position-y": {
	syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "top",
	appliesto: "allElements",
	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
},
	"background-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "listEachItemHasTwoKeywordsOnePerDimension",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
},
	"background-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "relativeToBackgroundPositioningArea",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "auto auto",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
},
	"block-overflow": {
	syntax: "clip | ellipsis | <string>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "clip",
	appliesto: "blockContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"block-size": {
	syntax: "<'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsWidthAndHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
},
	border: border$1,
	"border-block": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
},
	"border-block-color": {
	syntax: "<'border-top-color'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
},
	"border-block-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
},
	"border-block-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
},
	"border-block-end": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-block-end-color",
		"border-block-end-style",
		"border-block-end-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
},
	"border-block-end-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
},
	"border-block-end-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
},
	"border-block-end-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
},
	"border-block-start": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-block-start-color",
		"border-block-start-style",
		"border-block-start-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-block-start-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
},
	"border-block-start-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
},
	"border-block-start-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
},
	"border-block-start-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
},
	"border-bottom": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-color",
		"border-bottom-style",
		"border-bottom-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-bottom-width",
		"border-bottom-style",
		"border-bottom-color"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-width",
		"border-bottom-style",
		"border-bottom-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
},
	"border-bottom-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
},
	"border-bottom-left-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
},
	"border-bottom-right-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
},
	"border-bottom-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
},
	"border-bottom-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
},
	"border-collapse": {
	syntax: "collapse | separate",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "separate",
	appliesto: "tableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
},
	"border-color": {
	syntax: "<color>{1,4}",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-color",
		"border-left-color",
		"border-right-color",
		"border-top-color"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-color",
		"border-right-color",
		"border-bottom-color",
		"border-left-color"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-color",
		"border-left-color",
		"border-right-color",
		"border-top-color"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
},
	"border-end-end-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
},
	"border-end-start-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
},
	"border-image": {
	syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"border-image-slice",
		"border-image-width"
	],
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-image-source",
		"border-image-slice",
		"border-image-width",
		"border-image-outset",
		"border-image-repeat"
	],
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: [
		"border-image-outset",
		"border-image-repeat",
		"border-image-slice",
		"border-image-source",
		"border-image-width"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
},
	"border-image-outset": {
	syntax: "[ <length> | <number> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
},
	"border-image-repeat": {
	syntax: "[ stretch | repeat | round | space ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "stretch",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
},
	"border-image-slice": {
	syntax: "<number-percentage>{1,4} && fill?",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToSizeOfBorderImage",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "100%",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
	order: "percentagesOrLengthsFollowedByFill",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
},
	"border-image-source": {
	syntax: "none | <image>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "noneOrImageWithAbsoluteURI",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
},
	"border-image-width": {
	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToWidthOrHeightOfBorderImageArea",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "1",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
},
	"border-inline": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
},
	"border-inline-end": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-inline-end-color",
		"border-inline-end-style",
		"border-inline-end-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-inline-end-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
},
	"border-inline-color": {
	syntax: "<'border-top-color'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
},
	"border-inline-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
},
	"border-inline-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
},
	"border-inline-end-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
},
	"border-inline-end-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
},
	"border-inline-end-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
},
	"border-inline-start": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-inline-start-color",
		"border-inline-start-style",
		"border-inline-start-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-inline-start-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
},
	"border-inline-start-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
},
	"border-inline-start-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
},
	"border-inline-start-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
},
	"border-left": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-left-color",
		"border-left-style",
		"border-left-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-left-width",
		"border-left-style",
		"border-left-color"
	],
	appliesto: "allElements",
	computed: [
		"border-left-width",
		"border-left-style",
		"border-left-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
},
	"border-left-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
},
	"border-left-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
},
	"border-left-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
},
	"border-radius": {
	syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"border-top-left-radius",
		"border-top-right-radius",
		"border-bottom-right-radius",
		"border-bottom-left-radius"
	],
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-left-radius",
		"border-top-right-radius",
		"border-bottom-right-radius",
		"border-bottom-left-radius"
	],
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: [
		"border-bottom-left-radius",
		"border-bottom-right-radius",
		"border-top-left-radius",
		"border-top-right-radius"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
},
	"border-right": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-right-color",
		"border-right-style",
		"border-right-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-right-width",
		"border-right-style",
		"border-right-color"
	],
	appliesto: "allElements",
	computed: [
		"border-right-width",
		"border-right-style",
		"border-right-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
},
	"border-right-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
},
	"border-right-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
},
	"border-right-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
},
	"border-spacing": {
	syntax: "<length> <length>?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "0",
	appliesto: "tableElements",
	computed: "twoAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
},
	"border-start-end-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
},
	"border-start-start-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
},
	"border-style": {
	syntax: "<line-style>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-style",
		"border-right-style",
		"border-bottom-style",
		"border-left-style"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-style",
		"border-left-style",
		"border-right-style",
		"border-top-style"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
},
	"border-top": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-top-color",
		"border-top-style",
		"border-top-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
},
	"border-top-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
},
	"border-top-left-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
},
	"border-top-right-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
},
	"border-top-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
},
	"border-top-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
},
	"border-width": {
	syntax: "<line-width>{1,4}",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-width",
		"border-left-width",
		"border-right-width",
		"border-top-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-width",
		"border-right-width",
		"border-bottom-width",
		"border-left-width"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-width",
		"border-left-width",
		"border-right-width",
		"border-top-width"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
},
	bottom: bottom,
	"box-align": {
	syntax: "start | center | end | baseline | stretch",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "stretch",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
},
	"box-decoration-break": {
	syntax: "slice | clone",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "slice",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
},
	"box-direction": {
	syntax: "normal | reverse | inherit",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "normal",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
},
	"box-flex": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "0",
	appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
},
	"box-flex-group": {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "1",
	appliesto: "inFlowChildrenOfBoxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
},
	"box-lines": {
	syntax: "single | multiple",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "single",
	appliesto: "boxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
},
	"box-ordinal-group": {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "1",
	appliesto: "childrenOfBoxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
},
	"box-orient": {
	syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "inlineAxisHorizontalInXUL",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
},
	"box-pack": {
	syntax: "start | center | end | justify",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "start",
	appliesto: "elementsWithDisplayMozBoxMozInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
},
	"box-shadow": {
	syntax: "none | <shadow>#",
	media: "visual",
	inherited: false,
	animationType: "shadowList",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "absoluteLengthsSpecifiedColorAsSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
},
	"box-sizing": {
	syntax: "content-box | border-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "content-box",
	appliesto: "allElementsAcceptingWidthOrHeight",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
},
	"break-after": {
	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
},
	"break-before": {
	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
},
	"break-inside": {
	syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
},
	"caption-side": {
	syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "top",
	appliesto: "tableCaptionElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
},
	"caret-color": {
	syntax: "auto | <color>",
	media: "interactive",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asAutoOrColor",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
},
	clear: clear,
	clip: clip,
	"clip-path": {
	syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
	media: "visual",
	inherited: false,
	animationType: "basicShapeOtherwiseNo",
	percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
},
	color: color$2,
	"color-adjust": {
	syntax: "economy | exact",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "economy",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
},
	"column-count": {
	syntax: "<integer> | auto",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "auto",
	appliesto: "blockContainersExceptTableWrappers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
},
	"column-fill": {
	syntax: "auto | balance | balance-all",
	media: "visualInContinuousMediaNoEffectInOverflowColumns",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "balance",
	appliesto: "multicolElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
},
	"column-gap": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
},
	"column-rule": {
	syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"column-rule-color",
		"column-rule-style",
		"column-rule-width"
	],
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: [
		"column-rule-width",
		"column-rule-style",
		"column-rule-color"
	],
	appliesto: "multicolElements",
	computed: [
		"column-rule-color",
		"column-rule-style",
		"column-rule-width"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
},
	"column-rule-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "currentcolor",
	appliesto: "multicolElements",
	computed: "computedColor",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
},
	"column-rule-style": {
	syntax: "<'border-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "none",
	appliesto: "multicolElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
},
	"column-rule-width": {
	syntax: "<'border-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "medium",
	appliesto: "multicolElements",
	computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
},
	"column-span": {
	syntax: "none | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "none",
	appliesto: "inFlowBlockLevelElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
},
	"column-width": {
	syntax: "<length> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "auto",
	appliesto: "blockContainersExceptTableWrappers",
	computed: "absoluteLengthZeroOrLarger",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
},
	columns: columns,
	contain: contain,
	content: content,
	"counter-increment": {
	syntax: "[ <custom-ident> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
},
	"counter-reset": {
	syntax: "[ <custom-ident> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
},
	"counter-set": {
	syntax: "[ <custom-ident> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
},
	cursor: cursor,
	direction: direction,
	display: display,
	"empty-cells": {
	syntax: "show | hide",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "show",
	appliesto: "tableCellElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
},
	filter: filter,
	flex: flex,
	"flex-basis": {
	syntax: "content | <'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToFlexContainersInnerMainSize",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "auto",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
},
	"flex-direction": {
	syntax: "row | row-reverse | column | column-reverse",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "row",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
},
	"flex-flow": {
	syntax: "<'flex-direction'> || <'flex-wrap'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: [
		"flex-direction",
		"flex-wrap"
	],
	appliesto: "flexContainers",
	computed: [
		"flex-direction",
		"flex-wrap"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
},
	"flex-grow": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "0",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
},
	"flex-shrink": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "1",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
},
	"flex-wrap": {
	syntax: "nowrap | wrap | wrap-reverse",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "nowrap",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
},
	float: float,
	font: font$1,
	"font-family": {
	syntax: "[ <family-name> | <generic-family> ]#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
},
	"font-feature-settings": {
	syntax: "normal | <feature-tag-value>#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
},
	"font-kerning": {
	syntax: "auto | normal | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
},
	"font-language-override": {
	syntax: "normal | <string>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
},
	"font-optical-sizing": {
	syntax: "auto | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
},
	"font-variation-settings": {
	syntax: "normal | [ <string> <number> ]#",
	media: "visual",
	inherited: true,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
},
	"font-size": {
	syntax: "<absolute-size> | <relative-size> | <length-percentage>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "referToParentElementsFontSize",
	groups: [
		"CSS Fonts"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
},
	"font-size-adjust": {
	syntax: "none | <number>",
	media: "visual",
	inherited: true,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
},
	"font-smooth": {
	syntax: "auto | never | always | <absolute-size> | <length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
},
	"font-stretch": {
	syntax: "<font-stretch-absolute>",
	media: "visual",
	inherited: true,
	animationType: "fontStretch",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
},
	"font-style": {
	syntax: "normal | italic | oblique <angle>?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
},
	"font-synthesis": {
	syntax: "none | [ weight || style ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "weight style",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
},
	"font-variant": {
	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
},
	"font-variant-alternates": {
	syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
},
	"font-variant-caps": {
	syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
},
	"font-variant-east-asian": {
	syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
},
	"font-variant-ligatures": {
	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
},
	"font-variant-numeric": {
	syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
},
	"font-variant-position": {
	syntax: "normal | sub | super",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
},
	"font-weight": {
	syntax: "<font-weight-absolute> | bolder | lighter",
	media: "visual",
	inherited: true,
	animationType: "fontWeight",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
},
	gap: gap,
	grid: grid,
	"grid-area": {
	syntax: "<grid-line> [ / <grid-line> ]{0,3}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-start",
		"grid-column-start",
		"grid-row-end",
		"grid-column-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-row-start",
		"grid-column-start",
		"grid-row-end",
		"grid-column-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
},
	"grid-auto-columns": {
	syntax: "<track-size>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
},
	"grid-auto-flow": {
	syntax: "[ row | column ] || dense",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "row",
	appliesto: "gridContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
},
	"grid-auto-rows": {
	syntax: "<track-size>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
},
	"grid-column": {
	syntax: "<grid-line> [ / <grid-line> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-column-start",
		"grid-column-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-column-start",
		"grid-column-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
},
	"grid-column-end": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
},
	"grid-column-gap": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "0",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
},
	"grid-column-start": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
},
	"grid-gap": {
	syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
	media: "visual",
	inherited: false,
	animationType: [
		"grid-row-gap",
		"grid-column-gap"
	],
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-gap",
		"grid-column-gap"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-row-gap",
		"grid-column-gap"
	],
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
},
	"grid-row": {
	syntax: "<grid-line> [ / <grid-line> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-start",
		"grid-row-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-row-start",
		"grid-row-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
},
	"grid-row-end": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
},
	"grid-row-gap": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "0",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
},
	"grid-row-start": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
},
	"grid-template": {
	syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"grid-template-columns",
		"grid-template-rows"
	],
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-template-columns",
		"grid-template-rows",
		"grid-template-areas"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-template-columns",
		"grid-template-rows",
		"grid-template-areas"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
},
	"grid-template-areas": {
	syntax: "none | <string>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
},
	"grid-template-columns": {
	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
},
	"grid-template-rows": {
	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
},
	"hanging-punctuation": {
	syntax: "none | [ first || [ force-end | allow-end ] || last ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
},
	height: height,
	hyphens: hyphens,
	"image-orientation": {
	syntax: "from-image | <angle> | [ <angle>? flip ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "from-image",
	appliesto: "allElements",
	computed: "angleRoundedToNextQuarter",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
},
	"image-rendering": {
	syntax: "auto | crisp-edges | pixelated",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
},
	"image-resolution": {
	syntax: "[ from-image || <resolution> ] && snap?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "1dppx",
	appliesto: "allElements",
	computed: "asSpecifiedWithExceptionOfResolution",
	order: "uniqueOrder",
	status: "experimental"
},
	"ime-mode": {
	syntax: "auto | normal | active | inactive | disabled",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "textFields",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
},
	"initial-letter": {
	syntax: "normal | [ <number> <integer>? ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Inline"
	],
	initial: "normal",
	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
},
	"initial-letter-align": {
	syntax: "[ auto | alphabetic | hanging | ideographic ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Inline"
	],
	initial: "auto",
	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
},
	"inline-size": {
	syntax: "<'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsWidthAndHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
},
	inset: inset,
	"inset-block": {
	syntax: "<'top'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
},
	"inset-block-end": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
},
	"inset-block-start": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
},
	"inset-inline": {
	syntax: "<'top'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
},
	"inset-inline-end": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
},
	"inset-inline-start": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
},
	isolation: isolation,
	"justify-content": {
	syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
},
	"justify-items": {
	syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "legacy",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
},
	"justify-self": {
	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "auto",
	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
},
	"justify-tracks": {
	syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "normal",
	appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
},
	left: left,
	"letter-spacing": {
	syntax: "normal | <length>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "optimumValueOfAbsoluteLengthOrNormal",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
},
	"line-break": {
	syntax: "auto | loose | normal | strict | anywhere",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
},
	"line-clamp": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "blockContainersExceptMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"line-height": {
	syntax: "normal | <number> | <length> | <percentage>",
	media: "visual",
	inherited: true,
	animationType: "numberOrLength",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "absoluteLengthOrAsSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
},
	"line-height-step": {
	syntax: "<length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "0",
	appliesto: "blockContainers",
	computed: "absoluteLength",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
},
	"list-style": {
	syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: [
		"list-style-type",
		"list-style-position",
		"list-style-image"
	],
	appliesto: "listItems",
	computed: [
		"list-style-image",
		"list-style-position",
		"list-style-type"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
},
	"list-style-image": {
	syntax: "<url> | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "none",
	appliesto: "listItems",
	computed: "noneOrImageWithAbsoluteURI",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
},
	"list-style-position": {
	syntax: "inside | outside",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "outside",
	appliesto: "listItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
},
	"list-style-type": {
	syntax: "<counter-style> | <string> | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "disc",
	appliesto: "listItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
},
	margin: margin,
	"margin-block": {
	syntax: "<'margin-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
},
	"margin-block-end": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
},
	"margin-block-start": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
},
	"margin-bottom": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
},
	"margin-inline": {
	syntax: "<'margin-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
},
	"margin-inline-end": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
},
	"margin-inline-start": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
},
	"margin-left": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
},
	"margin-right": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
},
	"margin-top": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
},
	"margin-trim": {
	syntax: "none | in-flow | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "blockContainersAndMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
},
	mask: mask,
	"mask-border": {
	syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
	media: "visual",
	inherited: false,
	animationType: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	percentages: [
		"mask-border-slice",
		"mask-border-width"
	],
	groups: [
		"CSS Masking"
	],
	initial: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	appliesto: "allElementsSVGContainerElements",
	computed: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
},
	"mask-border-mode": {
	syntax: "luminance | alpha",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "alpha",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
},
	"mask-border-outset": {
	syntax: "[ <length> | <number> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "0",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
},
	"mask-border-repeat": {
	syntax: "[ stretch | repeat | round | space ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "stretch",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
},
	"mask-border-slice": {
	syntax: "<number-percentage>{1,4} fill?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfMaskBorderImage",
	groups: [
		"CSS Masking"
	],
	initial: "0",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
},
	"mask-border-source": {
	syntax: "none | <image>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
},
	"mask-border-width": {
	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToMaskBorderImageArea",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
},
	"mask-clip": {
	syntax: "[ <geometry-box> | no-clip ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "border-box",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
},
	"mask-composite": {
	syntax: "<compositing-operator>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "add",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
},
	"mask-image": {
	syntax: "<mask-reference>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
},
	"mask-mode": {
	syntax: "<masking-mode>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "match-source",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
},
	"mask-origin": {
	syntax: "<geometry-box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "border-box",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
},
	"mask-position": {
	syntax: "<position>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToSizeOfMaskPaintingArea",
	groups: [
		"CSS Masking"
	],
	initial: "center",
	appliesto: "allElementsSVGContainerElements",
	computed: "consistsOfTwoKeywordsForOriginAndOffsets",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
},
	"mask-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "no-repeat",
	appliesto: "allElementsSVGContainerElements",
	computed: "consistsOfTwoDimensionKeywords",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
},
	"mask-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
},
	"mask-type": {
	syntax: "luminance | alpha",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "luminance",
	appliesto: "maskElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
},
	"masonry-auto-flow": {
	syntax: "[ pack | next ] || [ definite-first | ordered ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "pack",
	appliesto: "gridContainersWithMasonryLayout",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
},
	"math-style": {
	syntax: "normal | compact",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"MathML"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
},
	"max-block-size": {
	syntax: "<'max-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMaxWidthAndMaxHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
},
	"max-height": {
	syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
},
	"max-inline-size": {
	syntax: "<'max-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMaxWidthAndMaxHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
},
	"max-lines": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "blockContainersExceptMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"max-width": {
	syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
},
	"min-block-size": {
	syntax: "<'min-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMinWidthAndMinHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
},
	"min-height": {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
},
	"min-inline-size": {
	syntax: "<'min-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMinWidthAndMinHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
},
	"min-width": {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
},
	"mix-blend-mode": {
	syntax: "<blend-mode>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
},
	"object-fit": {
	syntax: "fill | contain | cover | none | scale-down",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "fill",
	appliesto: "replacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
},
	"object-position": {
	syntax: "<position>",
	media: "visual",
	inherited: true,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToWidthAndHeightOfElement",
	groups: [
		"CSS Images"
	],
	initial: "50% 50%",
	appliesto: "replacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
},
	offset: offset,
	"offset-anchor": {
	syntax: "auto | <position>",
	media: "visual",
	inherited: false,
	animationType: "position",
	percentages: "relativeToWidthAndHeight",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "standard"
},
	"offset-distance": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToTotalPathLength",
	groups: [
		"CSS Motion Path"
	],
	initial: "0",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
},
	"offset-path": {
	syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
	media: "visual",
	inherited: false,
	animationType: "angleOrBasicShapeOrPath",
	percentages: "no",
	groups: [
		"CSS Motion Path"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
},
	"offset-position": {
	syntax: "auto | <position>",
	media: "visual",
	inherited: false,
	animationType: "position",
	percentages: "referToSizeOfContainingBlock",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "experimental"
},
	"offset-rotate": {
	syntax: "[ auto | reverse ] || <angle>",
	media: "visual",
	inherited: false,
	animationType: "angleOrBasicShapeOrPath",
	percentages: "no",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
},
	opacity: opacity,
	order: order,
	orphans: orphans,
	outline: outline,
	"outline-color": {
	syntax: "<color> | invert",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "invertOrCurrentColor",
	appliesto: "allElements",
	computed: "invertForTranslucentColorRGBAOtherwiseRGB",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
},
	"outline-offset": {
	syntax: "<length>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
},
	"outline-style": {
	syntax: "auto | <'border-style'>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
},
	"outline-width": {
	syntax: "<line-width>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLength0ForNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
},
	overflow: overflow,
	"overflow-anchor": {
	syntax: "auto | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Anchoring"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard"
},
	"overflow-block": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "perGrammar",
	status: "standard"
},
	"overflow-clip-box": {
	syntax: "padding-box | content-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "padding-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
},
	"overflow-inline": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "perGrammar",
	status: "standard"
},
	"overflow-wrap": {
	syntax: "normal | break-word | anywhere",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "nonReplacedInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
},
	"overflow-x": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
},
	"overflow-y": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
},
	"overscroll-behavior": {
	syntax: "[ contain | none | auto ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
},
	"overscroll-behavior-block": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
},
	"overscroll-behavior-inline": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
},
	"overscroll-behavior-x": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
},
	"overscroll-behavior-y": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
},
	padding: padding,
	"padding-block": {
	syntax: "<'padding-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
},
	"padding-block-end": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
},
	"padding-block-start": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
},
	"padding-bottom": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
},
	"padding-inline": {
	syntax: "<'padding-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
},
	"padding-inline-end": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
},
	"padding-inline-start": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
},
	"padding-left": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
},
	"padding-right": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
},
	"padding-top": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
},
	"page-break-after": {
	syntax: "auto | always | avoid | left | right | recto | verso",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
},
	"page-break-before": {
	syntax: "auto | always | avoid | left | right | recto | verso",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
},
	"page-break-inside": {
	syntax: "auto | avoid",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
},
	"paint-order": {
	syntax: "normal | [ fill || stroke || markers ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "textElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
},
	perspective: perspective,
	"perspective-origin": {
	syntax: "<position>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpc",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "50% 50%",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
},
	"place-content": {
	syntax: "<'align-content'> <'justify-content'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multilineFlexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
},
	"place-items": {
	syntax: "<'align-items'> <'justify-items'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"align-items",
		"justify-items"
	],
	appliesto: "allElements",
	computed: [
		"align-items",
		"justify-items"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
},
	"place-self": {
	syntax: "<'align-self'> <'justify-self'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"align-self",
		"justify-self"
	],
	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
	computed: [
		"align-self",
		"justify-self"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
},
	"pointer-events": {
	syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Pointer Events"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
},
	position: position$1,
	quotes: quotes,
	resize: resize,
	right: right,
	rotate: rotate,
	"row-gap": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
},
	"ruby-align": {
	syntax: "start | center | space-between | space-around",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "space-around",
	appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
},
	"ruby-merge": {
	syntax: "separate | collapse | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "separate",
	appliesto: "rubyAnnotationsContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental"
},
	"ruby-position": {
	syntax: "over | under | inter-character",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "over",
	appliesto: "rubyAnnotationsContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
},
	scale: scale,
	"scrollbar-color": {
	syntax: "auto | dark | light | <color>{2}",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Scrollbars"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
},
	"scrollbar-gutter": {
	syntax: "auto | [ stable | always ] && both? && force?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
},
	"scrollbar-width": {
	syntax: "auto | thin | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scrollbars"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
},
	"scroll-behavior": {
	syntax: "auto | smooth",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSSOM View"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
},
	"scroll-margin": {
	syntax: "<length>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
},
	"scroll-margin-block": {
	syntax: "<length>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
},
	"scroll-margin-block-start": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
},
	"scroll-margin-block-end": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
},
	"scroll-margin-bottom": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
},
	"scroll-margin-inline": {
	syntax: "<length>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
},
	"scroll-margin-inline-start": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
},
	"scroll-margin-inline-end": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
},
	"scroll-margin-left": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
},
	"scroll-margin-right": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
},
	"scroll-margin-top": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
},
	"scroll-padding": {
	syntax: "[ auto | <length-percentage> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
},
	"scroll-padding-block": {
	syntax: "[ auto | <length-percentage> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
},
	"scroll-padding-block-start": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
},
	"scroll-padding-block-end": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
},
	"scroll-padding-bottom": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
},
	"scroll-padding-inline": {
	syntax: "[ auto | <length-percentage> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
},
	"scroll-padding-inline-start": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
},
	"scroll-padding-inline-end": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
},
	"scroll-padding-left": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
},
	"scroll-padding-right": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
},
	"scroll-padding-top": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
},
	"scroll-snap-align": {
	syntax: "[ none | start | end | center ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
},
	"scroll-snap-coordinate": {
	syntax: "none | <position>#",
	media: "interactive",
	inherited: false,
	animationType: "position",
	percentages: "referToBorderBox",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
},
	"scroll-snap-destination": {
	syntax: "<position>",
	media: "interactive",
	inherited: false,
	animationType: "position",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0px 0px",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
},
	"scroll-snap-points-x": {
	syntax: "none | repeat( <length-percentage> )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
},
	"scroll-snap-points-y": {
	syntax: "none | repeat( <length-percentage> )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
},
	"scroll-snap-stop": {
	syntax: "normal | always",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
},
	"scroll-snap-type": {
	syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
},
	"scroll-snap-type-x": {
	syntax: "none | mandatory | proximity",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
},
	"scroll-snap-type-y": {
	syntax: "none | mandatory | proximity",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
},
	"shape-image-threshold": {
	syntax: "<alpha-value>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Shapes"
	],
	initial: "0.0",
	appliesto: "floats",
	computed: "specifiedValueNumberClipped0To1",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
},
	"shape-margin": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Shapes"
	],
	initial: "0",
	appliesto: "floats",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
},
	"shape-outside": {
	syntax: "none | <shape-box> || <basic-shape> | <image>",
	media: "visual",
	inherited: false,
	animationType: "basicShapeOtherwiseNo",
	percentages: "no",
	groups: [
		"CSS Shapes"
	],
	initial: "none",
	appliesto: "floats",
	computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
},
	"tab-size": {
	syntax: "<integer> | <length>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "8",
	appliesto: "blockContainers",
	computed: "specifiedIntegerOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
},
	"table-layout": {
	syntax: "auto | fixed",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "auto",
	appliesto: "tableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
},
	"text-align": {
	syntax: "start | end | left | right | center | justify | match-parent",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "startOrNamelessValueIfLTRRightIfRTL",
	appliesto: "blockContainers",
	computed: "asSpecifiedExceptMatchParent",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
},
	"text-align-last": {
	syntax: "auto | start | end | left | right | center | justify",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "blockContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
},
	"text-combine-upright": {
	syntax: "none | all | [ digits <integer>? ]",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "none",
	appliesto: "nonReplacedInlineElements",
	computed: "keywordPlusIntegerIfDigits",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
},
	"text-decoration": {
	syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
	media: "visual",
	inherited: false,
	animationType: [
		"text-decoration-color",
		"text-decoration-style",
		"text-decoration-line",
		"text-decoration-thickness"
	],
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: [
		"text-decoration-color",
		"text-decoration-style",
		"text-decoration-line"
	],
	appliesto: "allElements",
	computed: [
		"text-decoration-line",
		"text-decoration-style",
		"text-decoration-color",
		"text-decoration-thickness"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
},
	"text-decoration-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
},
	"text-decoration-line": {
	syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
},
	"text-decoration-skip": {
	syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "objects",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
},
	"text-decoration-skip-ink": {
	syntax: "auto | all | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
},
	"text-decoration-style": {
	syntax: "solid | double | dotted | dashed | wavy",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "solid",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
},
	"text-decoration-thickness": {
	syntax: "auto | from-font | <length> | <percentage> ",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
},
	"text-emphasis": {
	syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"text-emphasis-color",
		"text-emphasis-style"
	],
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: [
		"text-emphasis-style",
		"text-emphasis-color"
	],
	appliesto: "allElements",
	computed: [
		"text-emphasis-style",
		"text-emphasis-color"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
},
	"text-emphasis-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
},
	"text-emphasis-position": {
	syntax: "[ over | under ] && [ right | left ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "over right",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
},
	"text-emphasis-style": {
	syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
},
	"text-indent": {
	syntax: "<length-percentage> && hanging? && each-line?",
	media: "visual",
	inherited: true,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Text"
	],
	initial: "0",
	appliesto: "blockContainers",
	computed: "percentageOrAbsoluteLengthPlusKeywords",
	order: "lengthOrPercentageBeforeKeywords",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
},
	"text-justify": {
	syntax: "auto | inter-character | inter-word | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "inlineLevelAndTableCellElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
},
	"text-orientation": {
	syntax: "mixed | upright | sideways",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "mixed",
	appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
},
	"text-overflow": {
	syntax: "[ clip | ellipsis | <string> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "clip",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
},
	"text-rendering": {
	syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Miscellaneous"
	],
	initial: "auto",
	appliesto: "textElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
},
	"text-shadow": {
	syntax: "none | <shadow-t>#",
	media: "visual",
	inherited: true,
	animationType: "shadowList",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "colorPlusThreeAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
},
	"text-size-adjust": {
	syntax: "none | auto | <percentage>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "referToSizeOfFont",
	groups: [
		"CSS Text"
	],
	initial: "autoForSmartphoneBrowsersSupportingInflation",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
},
	"text-transform": {
	syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
},
	"text-underline-offset": {
	syntax: "auto | <length> | <percentage> ",
	media: "visual",
	inherited: true,
	animationType: "byComputedValueType",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
},
	"text-underline-position": {
	syntax: "auto | from-font | [ under || [ left | right ] ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
},
	top: top,
	"touch-action": {
	syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Pointer Events"
	],
	initial: "auto",
	appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
},
	transform: transform,
	"transform-box": {
	syntax: "content-box | border-box | fill-box | stroke-box | view-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "view-box",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
},
	"transform-origin": {
	syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpc",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "50% 50% 0",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
},
	"transform-style": {
	syntax: "flat | preserve-3d",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "flat",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
},
	transition: transition,
	"transition-delay": {
	syntax: "<time>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
},
	"transition-duration": {
	syntax: "<time>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
},
	"transition-property": {
	syntax: "none | <single-transition-property>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "all",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
},
	"transition-timing-function": {
	syntax: "<timing-function>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "ease",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
},
	translate: translate,
	"unicode-bidi": {
	syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "normal",
	appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
},
	"user-select": {
	syntax: "auto | text | none | contain | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
},
	"vertical-align": {
	syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToLineHeight",
	groups: [
		"CSS Table"
	],
	initial: "baseline",
	appliesto: "inlineLevelAndTableCellElements",
	computed: "absoluteLengthOrKeyword",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
},
	visibility: visibility,
	"white-space": {
	syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
},
	widows: widows,
	width: width,
	"will-change": {
	syntax: "auto | <animateable-feature>#",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Will Change"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
},
	"word-break": {
	syntax: "normal | break-all | keep-all | break-word",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
},
	"word-spacing": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "referToWidthOfAffectedGlyph",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
},
	"word-wrap": {
	syntax: "normal | break-word",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "nonReplacedInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
},
	"writing-mode": {
	syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "horizontal-tb",
	appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
},
	"z-index": {
	syntax: "auto | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
},
	zoom: zoom
};

const attachment = {
	syntax: "scroll | fixed | local"
};
const box = {
	syntax: "border-box | padding-box | content-box"
};
const color$1 = {
	syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
};
const combinator = {
	syntax: "'>' | '+' | '~' | [ '||' ]"
};
const gradient = {
	syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
};
const hue = {
	syntax: "<number> | <angle>"
};
const image = {
	syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
};
const nth$1 = {
	syntax: "<an-plus-b> | even | odd"
};
const position = {
	syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
};
const quote = {
	syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
};
const shadow = {
	syntax: "inset? && <length>{2,4} && <color>?"
};
const shape = {
	syntax: "rect(<top>, <right>, <bottom>, <left>)"
};
const size = {
	syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
};
const symbol = {
	syntax: "<string> | <image> | <custom-ident>"
};
const target = {
	syntax: "<target-counter()> | <target-counters()> | <target-text()>"
};
const require$$2$1 = {
	"absolute-size": {
	syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
},
	"alpha-value": {
	syntax: "<number> | <percentage>"
},
	"angle-percentage": {
	syntax: "<angle> | <percentage>"
},
	"angular-color-hint": {
	syntax: "<angle-percentage>"
},
	"angular-color-stop": {
	syntax: "<color> && <color-stop-angle>?"
},
	"angular-color-stop-list": {
	syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
},
	"animateable-feature": {
	syntax: "scroll-position | contents | <custom-ident>"
},
	attachment: attachment,
	"attr()": {
	syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
},
	"attr-matcher": {
	syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
},
	"attr-modifier": {
	syntax: "i | s"
},
	"attribute-selector": {
	syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
},
	"auto-repeat": {
	syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
},
	"auto-track-list": {
	syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
},
	"baseline-position": {
	syntax: "[ first | last ]? baseline"
},
	"basic-shape": {
	syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
},
	"bg-image": {
	syntax: "none | <image>"
},
	"bg-layer": {
	syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
},
	"bg-position": {
	syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
},
	"bg-size": {
	syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
},
	"blur()": {
	syntax: "blur( <length> )"
},
	"blend-mode": {
	syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
},
	box: box,
	"brightness()": {
	syntax: "brightness( <number-percentage> )"
},
	"calc()": {
	syntax: "calc( <calc-sum> )"
},
	"calc-sum": {
	syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
},
	"calc-product": {
	syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
},
	"calc-value": {
	syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
},
	"cf-final-image": {
	syntax: "<image> | <color>"
},
	"cf-mixing-image": {
	syntax: "<percentage>? && <image>"
},
	"circle()": {
	syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
},
	"clamp()": {
	syntax: "clamp( <calc-sum>#{3} )"
},
	"class-selector": {
	syntax: "'.' <ident-token>"
},
	"clip-source": {
	syntax: "<url>"
},
	color: color$1,
	"color-stop": {
	syntax: "<color-stop-length> | <color-stop-angle>"
},
	"color-stop-angle": {
	syntax: "<angle-percentage>{1,2}"
},
	"color-stop-length": {
	syntax: "<length-percentage>{1,2}"
},
	"color-stop-list": {
	syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
},
	combinator: combinator,
	"common-lig-values": {
	syntax: "[ common-ligatures | no-common-ligatures ]"
},
	"compat-auto": {
	syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
},
	"composite-style": {
	syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
},
	"compositing-operator": {
	syntax: "add | subtract | intersect | exclude"
},
	"compound-selector": {
	syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
},
	"compound-selector-list": {
	syntax: "<compound-selector>#"
},
	"complex-selector": {
	syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
},
	"complex-selector-list": {
	syntax: "<complex-selector>#"
},
	"conic-gradient()": {
	syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
},
	"contextual-alt-values": {
	syntax: "[ contextual | no-contextual ]"
},
	"content-distribution": {
	syntax: "space-between | space-around | space-evenly | stretch"
},
	"content-list": {
	syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
},
	"content-position": {
	syntax: "center | start | end | flex-start | flex-end"
},
	"content-replacement": {
	syntax: "<image>"
},
	"contrast()": {
	syntax: "contrast( [ <number-percentage> ] )"
},
	"counter()": {
	syntax: "counter( <custom-ident>, <counter-style>? )"
},
	"counter-style": {
	syntax: "<counter-style-name> | symbols()"
},
	"counter-style-name": {
	syntax: "<custom-ident>"
},
	"counters()": {
	syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
},
	"cross-fade()": {
	syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
},
	"cubic-bezier-timing-function": {
	syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
},
	"deprecated-system-color": {
	syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
},
	"discretionary-lig-values": {
	syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
},
	"display-box": {
	syntax: "contents | none"
},
	"display-inside": {
	syntax: "flow | flow-root | table | flex | grid | ruby"
},
	"display-internal": {
	syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
},
	"display-legacy": {
	syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
},
	"display-listitem": {
	syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
},
	"display-outside": {
	syntax: "block | inline | run-in"
},
	"drop-shadow()": {
	syntax: "drop-shadow( <length>{2,3} <color>? )"
},
	"east-asian-variant-values": {
	syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
},
	"east-asian-width-values": {
	syntax: "[ full-width | proportional-width ]"
},
	"element()": {
	syntax: "element( <id-selector> )"
},
	"ellipse()": {
	syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
},
	"ending-shape": {
	syntax: "circle | ellipse"
},
	"env()": {
	syntax: "env( <custom-ident> , <declaration-value>? )"
},
	"explicit-track-list": {
	syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
},
	"family-name": {
	syntax: "<string> | <custom-ident>+"
},
	"feature-tag-value": {
	syntax: "<string> [ <integer> | on | off ]?"
},
	"feature-type": {
	syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
},
	"feature-value-block": {
	syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
},
	"feature-value-block-list": {
	syntax: "<feature-value-block>+"
},
	"feature-value-declaration": {
	syntax: "<custom-ident>: <integer>+;"
},
	"feature-value-declaration-list": {
	syntax: "<feature-value-declaration>"
},
	"feature-value-name": {
	syntax: "<custom-ident>"
},
	"fill-rule": {
	syntax: "nonzero | evenodd"
},
	"filter-function": {
	syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
},
	"filter-function-list": {
	syntax: "[ <filter-function> | <url> ]+"
},
	"final-bg-layer": {
	syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
},
	"fit-content()": {
	syntax: "fit-content( [ <length> | <percentage> ] )"
},
	"fixed-breadth": {
	syntax: "<length-percentage>"
},
	"fixed-repeat": {
	syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
},
	"fixed-size": {
	syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
},
	"font-stretch-absolute": {
	syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
},
	"font-variant-css21": {
	syntax: "[ normal | small-caps ]"
},
	"font-weight-absolute": {
	syntax: "normal | bold | <number [1,1000]>"
},
	"frequency-percentage": {
	syntax: "<frequency> | <percentage>"
},
	"general-enclosed": {
	syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
},
	"generic-family": {
	syntax: "serif | sans-serif | cursive | fantasy | monospace"
},
	"generic-name": {
	syntax: "serif | sans-serif | cursive | fantasy | monospace"
},
	"geometry-box": {
	syntax: "<shape-box> | fill-box | stroke-box | view-box"
},
	gradient: gradient,
	"grayscale()": {
	syntax: "grayscale( <number-percentage> )"
},
	"grid-line": {
	syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
},
	"historical-lig-values": {
	syntax: "[ historical-ligatures | no-historical-ligatures ]"
},
	"hsl()": {
	syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
},
	"hsla()": {
	syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
},
	hue: hue,
	"hue-rotate()": {
	syntax: "hue-rotate( <angle> )"
},
	"id-selector": {
	syntax: "<hash-token>"
},
	image: image,
	"image()": {
	syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
},
	"image-set()": {
	syntax: "image-set( <image-set-option># )"
},
	"image-set-option": {
	syntax: "[ <image> | <string> ] <resolution>"
},
	"image-src": {
	syntax: "<url> | <string>"
},
	"image-tags": {
	syntax: "ltr | rtl"
},
	"inflexible-breadth": {
	syntax: "<length> | <percentage> | min-content | max-content | auto"
},
	"inset()": {
	syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
},
	"invert()": {
	syntax: "invert( <number-percentage> )"
},
	"keyframes-name": {
	syntax: "<custom-ident> | <string>"
},
	"keyframe-block": {
	syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
},
	"keyframe-block-list": {
	syntax: "<keyframe-block>+"
},
	"keyframe-selector": {
	syntax: "from | to | <percentage>"
},
	"leader()": {
	syntax: "leader( <leader-type> )"
},
	"leader-type": {
	syntax: "dotted | solid | space | <string>"
},
	"length-percentage": {
	syntax: "<length> | <percentage>"
},
	"line-names": {
	syntax: "'[' <custom-ident>* ']'"
},
	"line-name-list": {
	syntax: "[ <line-names> | <name-repeat> ]+"
},
	"line-style": {
	syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
},
	"line-width": {
	syntax: "<length> | thin | medium | thick"
},
	"linear-color-hint": {
	syntax: "<length-percentage>"
},
	"linear-color-stop": {
	syntax: "<color> <color-stop-length>?"
},
	"linear-gradient()": {
	syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
},
	"mask-layer": {
	syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
},
	"mask-position": {
	syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
},
	"mask-reference": {
	syntax: "none | <image> | <mask-source>"
},
	"mask-source": {
	syntax: "<url>"
},
	"masking-mode": {
	syntax: "alpha | luminance | match-source"
},
	"matrix()": {
	syntax: "matrix( <number>#{6} )"
},
	"matrix3d()": {
	syntax: "matrix3d( <number>#{16} )"
},
	"max()": {
	syntax: "max( <calc-sum># )"
},
	"media-and": {
	syntax: "<media-in-parens> [ and <media-in-parens> ]+"
},
	"media-condition": {
	syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
},
	"media-condition-without-or": {
	syntax: "<media-not> | <media-and> | <media-in-parens>"
},
	"media-feature": {
	syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
},
	"media-in-parens": {
	syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
},
	"media-not": {
	syntax: "not <media-in-parens>"
},
	"media-or": {
	syntax: "<media-in-parens> [ or <media-in-parens> ]+"
},
	"media-query": {
	syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
},
	"media-query-list": {
	syntax: "<media-query>#"
},
	"media-type": {
	syntax: "<ident>"
},
	"mf-boolean": {
	syntax: "<mf-name>"
},
	"mf-name": {
	syntax: "<ident>"
},
	"mf-plain": {
	syntax: "<mf-name> : <mf-value>"
},
	"mf-range": {
	syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
},
	"mf-value": {
	syntax: "<number> | <dimension> | <ident> | <ratio>"
},
	"min()": {
	syntax: "min( <calc-sum># )"
},
	"minmax()": {
	syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
},
	"named-color": {
	syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
},
	"namespace-prefix": {
	syntax: "<ident>"
},
	"ns-prefix": {
	syntax: "[ <ident-token> | '*' ]? '|'"
},
	"number-percentage": {
	syntax: "<number> | <percentage>"
},
	"numeric-figure-values": {
	syntax: "[ lining-nums | oldstyle-nums ]"
},
	"numeric-fraction-values": {
	syntax: "[ diagonal-fractions | stacked-fractions ]"
},
	"numeric-spacing-values": {
	syntax: "[ proportional-nums | tabular-nums ]"
},
	nth: nth$1,
	"opacity()": {
	syntax: "opacity( [ <number-percentage> ] )"
},
	"overflow-position": {
	syntax: "unsafe | safe"
},
	"outline-radius": {
	syntax: "<length> | <percentage>"
},
	"page-body": {
	syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
},
	"page-margin-box": {
	syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
},
	"page-margin-box-type": {
	syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
},
	"page-selector-list": {
	syntax: "[ <page-selector># ]?"
},
	"page-selector": {
	syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
},
	"path()": {
	syntax: "path( [ <fill-rule>, ]? <string> )"
},
	"paint()": {
	syntax: "paint( <ident>, <declaration-value>? )"
},
	"perspective()": {
	syntax: "perspective( <length> )"
},
	"polygon()": {
	syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
},
	position: position,
	"pseudo-class-selector": {
	syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
},
	"pseudo-element-selector": {
	syntax: "':' <pseudo-class-selector>"
},
	"pseudo-page": {
	syntax: ": [ left | right | first | blank ]"
},
	quote: quote,
	"radial-gradient()": {
	syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
},
	"relative-selector": {
	syntax: "<combinator>? <complex-selector>"
},
	"relative-selector-list": {
	syntax: "<relative-selector>#"
},
	"relative-size": {
	syntax: "larger | smaller"
},
	"repeat-style": {
	syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
},
	"repeating-linear-gradient()": {
	syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
},
	"repeating-radial-gradient()": {
	syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
},
	"rgb()": {
	syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
},
	"rgba()": {
	syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
},
	"rotate()": {
	syntax: "rotate( [ <angle> | <zero> ] )"
},
	"rotate3d()": {
	syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
},
	"rotateX()": {
	syntax: "rotateX( [ <angle> | <zero> ] )"
},
	"rotateY()": {
	syntax: "rotateY( [ <angle> | <zero> ] )"
},
	"rotateZ()": {
	syntax: "rotateZ( [ <angle> | <zero> ] )"
},
	"saturate()": {
	syntax: "saturate( <number-percentage> )"
},
	"scale()": {
	syntax: "scale( <number> , <number>? )"
},
	"scale3d()": {
	syntax: "scale3d( <number> , <number> , <number> )"
},
	"scaleX()": {
	syntax: "scaleX( <number> )"
},
	"scaleY()": {
	syntax: "scaleY( <number> )"
},
	"scaleZ()": {
	syntax: "scaleZ( <number> )"
},
	"self-position": {
	syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
},
	"shape-radius": {
	syntax: "<length-percentage> | closest-side | farthest-side"
},
	"skew()": {
	syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
},
	"skewX()": {
	syntax: "skewX( [ <angle> | <zero> ] )"
},
	"skewY()": {
	syntax: "skewY( [ <angle> | <zero> ] )"
},
	"sepia()": {
	syntax: "sepia( <number-percentage> )"
},
	shadow: shadow,
	"shadow-t": {
	syntax: "[ <length>{2,3} && <color>? ]"
},
	shape: shape,
	"shape-box": {
	syntax: "<box> | margin-box"
},
	"side-or-corner": {
	syntax: "[ left | right ] || [ top | bottom ]"
},
	"single-animation": {
	syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
},
	"single-animation-direction": {
	syntax: "normal | reverse | alternate | alternate-reverse"
},
	"single-animation-fill-mode": {
	syntax: "none | forwards | backwards | both"
},
	"single-animation-iteration-count": {
	syntax: "infinite | <number>"
},
	"single-animation-play-state": {
	syntax: "running | paused"
},
	"single-transition": {
	syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
},
	"single-transition-property": {
	syntax: "all | <custom-ident>"
},
	size: size,
	"step-position": {
	syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
},
	"step-timing-function": {
	syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
},
	"subclass-selector": {
	syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
},
	"supports-condition": {
	syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
},
	"supports-in-parens": {
	syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
},
	"supports-feature": {
	syntax: "<supports-decl> | <supports-selector-fn>"
},
	"supports-decl": {
	syntax: "( <declaration> )"
},
	"supports-selector-fn": {
	syntax: "selector( <complex-selector> )"
},
	symbol: symbol,
	target: target,
	"target-counter()": {
	syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
},
	"target-counters()": {
	syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
},
	"target-text()": {
	syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
},
	"time-percentage": {
	syntax: "<time> | <percentage>"
},
	"timing-function": {
	syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
},
	"track-breadth": {
	syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
},
	"track-list": {
	syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
},
	"track-repeat": {
	syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
},
	"track-size": {
	syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
},
	"transform-function": {
	syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
},
	"transform-list": {
	syntax: "<transform-function>+"
},
	"translate()": {
	syntax: "translate( <length-percentage> , <length-percentage>? )"
},
	"translate3d()": {
	syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
},
	"translateX()": {
	syntax: "translateX( <length-percentage> )"
},
	"translateY()": {
	syntax: "translateY( <length-percentage> )"
},
	"translateZ()": {
	syntax: "translateZ( <length> )"
},
	"type-or-unit": {
	syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
},
	"type-selector": {
	syntax: "<wq-name> | <ns-prefix>? '*'"
},
	"var()": {
	syntax: "var( <custom-property-name> , <declaration-value>? )"
},
	"viewport-length": {
	syntax: "auto | <length-percentage>"
},
	"wq-name": {
	syntax: "<ns-prefix>? <ident-token>"
}
};

const atrules = {
	charset: {
		prelude: "<string>"
	},
	"font-face": {
		descriptors: {
			"unicode-range": {
				comment: "replaces <unicode-range>, an old production name",
				syntax: "<urange>#"
			}
		}
	}
};
const properties = {
	"-moz-background-clip": {
		comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
		syntax: "padding | border"
	},
	"-moz-border-radius-bottomleft": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
		syntax: "<'border-bottom-left-radius'>"
	},
	"-moz-border-radius-bottomright": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
		syntax: "<'border-bottom-right-radius'>"
	},
	"-moz-border-radius-topleft": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
		syntax: "<'border-top-left-radius'>"
	},
	"-moz-border-radius-topright": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
		syntax: "<'border-bottom-right-radius'>"
	},
	"-moz-control-character-visibility": {
		comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
		syntax: "visible | hidden"
	},
	"-moz-osx-font-smoothing": {
		comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
		syntax: "auto | grayscale"
	},
	"-moz-user-select": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
		syntax: "none | text | all | -moz-none"
	},
	"-ms-flex-align": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
		syntax: "start | end | center | baseline | stretch"
	},
	"-ms-flex-item-align": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
		syntax: "auto | start | end | center | baseline | stretch"
	},
	"-ms-flex-line-pack": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
		syntax: "start | end | center | justify | distribute | stretch"
	},
	"-ms-flex-negative": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-shrink'>"
	},
	"-ms-flex-pack": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
		syntax: "start | end | center | justify | distribute"
	},
	"-ms-flex-order": {
		comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
		syntax: "<integer>"
	},
	"-ms-flex-positive": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-grow'>"
	},
	"-ms-flex-preferred-size": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-basis'>"
	},
	"-ms-interpolation-mode": {
		comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
		syntax: "nearest-neighbor | bicubic"
	},
	"-ms-grid-column-align": {
		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
		syntax: "start | end | center | stretch"
	},
	"-ms-grid-row-align": {
		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
		syntax: "start | end | center | stretch"
	},
	"-ms-hyphenate-limit-last": {
		comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
		syntax: "none | always | column | page | spread"
	},
	"-webkit-appearance": {
		comment: "webkit specific keywords",
		references: [
			"http://css-infos.net/property/-webkit-appearance"
		],
		syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
	},
	"-webkit-background-clip": {
		comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
		syntax: "[ <box> | border | padding | content | text ]#"
	},
	"-webkit-column-break-after": {
		comment: "added, http://help.dottoro.com/lcrthhhv.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-column-break-before": {
		comment: "added, http://help.dottoro.com/lcxquvkf.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-column-break-inside": {
		comment: "added, http://help.dottoro.com/lclhnthl.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-font-smoothing": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
		syntax: "auto | none | antialiased | subpixel-antialiased"
	},
	"-webkit-mask-box-image": {
		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
		syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
	},
	"-webkit-print-color-adjust": {
		comment: "missed",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
		],
		syntax: "economy | exact"
	},
	"-webkit-text-security": {
		comment: "missed; http://help.dottoro.com/lcbkewgt.php",
		syntax: "none | circle | disc | square"
	},
	"-webkit-user-drag": {
		comment: "missed; http://help.dottoro.com/lcbixvwm.php",
		syntax: "none | element | auto"
	},
	"-webkit-user-select": {
		comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
		syntax: "auto | none | text | all"
	},
	"alignment-baseline": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
		],
		syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
	},
	"baseline-shift": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
		],
		syntax: "baseline | sub | super | <svg-length>"
	},
	behavior: {
		comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
		syntax: "<url>+"
	},
	"clip-rule": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
		],
		syntax: "nonzero | evenodd"
	},
	cue: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'cue-before'> <'cue-after'>?"
	},
	"cue-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<url> <decibel>? | none"
	},
	"cue-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<url> <decibel>? | none"
	},
	cursor: {
		comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
		references: [
			"https://www.sitepoint.com/css3-cursor-styles/"
		],
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
	},
	display: {
		comment: "extended with -ms-flexbox",
		syntax: "| <-non-standard-display>"
	},
	position: {
		comment: "extended with -webkit-sticky",
		syntax: "| -webkit-sticky"
	},
	"dominant-baseline": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
		],
		syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
	},
	"image-rendering": {
		comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
			"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
		],
		syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
	},
	fill: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "<paint>"
	},
	"fill-opacity": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "<number-zero-one>"
	},
	"fill-rule": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "nonzero | evenodd"
	},
	filter: {
		comment: "extend with IE legacy syntaxes",
		syntax: "| <-ms-filter-function-list>"
	},
	"glyph-orientation-horizontal": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
		],
		syntax: "<angle>"
	},
	"glyph-orientation-vertical": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
		],
		syntax: "<angle>"
	},
	kerning: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#KerningProperty"
		],
		syntax: "auto | <svg-length>"
	},
	"letter-spacing": {
		comment: "fix syntax <length> -> <length-percentage>",
		references: [
			"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
		],
		syntax: "normal | <length-percentage>"
	},
	marker: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-end": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-mid": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-start": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"max-width": {
		comment: "fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
		syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
	},
	width: {
		comment: "per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)",
		syntax: "| fit-content | -moz-fit-content | -webkit-fit-content"
	},
	"min-width": {
		comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
		syntax: "auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
	},
	overflow: {
		comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
		syntax: "| <-non-standard-overflow>"
	},
	pause: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'pause-before'> <'pause-after'>?"
	},
	"pause-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"pause-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	rest: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'rest-before'> <'rest-after'>?"
	},
	"rest-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"rest-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"shape-rendering": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
		],
		syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
	},
	src: {
		comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
		syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
	},
	speak: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "auto | none | normal"
	},
	"speak-as": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
	},
	stroke: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<paint>"
	},
	"stroke-dasharray": {
		comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "none | [ <svg-length>+ ]#"
	},
	"stroke-dashoffset": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<svg-length>"
	},
	"stroke-linecap": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "butt | round | square"
	},
	"stroke-linejoin": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "miter | round | bevel"
	},
	"stroke-miterlimit": {
		comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<number-one-or-greater>"
	},
	"stroke-opacity": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<number-zero-one>"
	},
	"stroke-width": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<svg-length>"
	},
	"text-anchor": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
		],
		syntax: "start | middle | end"
	},
	"unicode-bidi": {
		comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
		syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
	},
	"unicode-range": {
		comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
		syntax: "<urange>#"
	},
	"voice-balance": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<number> | left | center | right | leftwards | rightwards"
	},
	"voice-duration": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "auto | <time>"
	},
	"voice-family": {
		comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
	},
	"voice-pitch": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
	},
	"voice-range": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
	},
	"voice-rate": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
	},
	"voice-stress": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "normal | strong | moderate | none | reduced"
	},
	"voice-volume": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
	},
	"writing-mode": {
		comment: "extend with SVG keywords",
		syntax: "| <svg-writing-mode>"
	}
};
const syntaxes = {
	"-legacy-gradient": {
		comment: "added collection of legacy gradient syntaxes",
		syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
	},
	"-legacy-linear-gradient": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
	},
	"-legacy-repeating-linear-gradient": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
	},
	"-legacy-linear-gradient-arguments": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
	},
	"-legacy-radial-gradient": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
	},
	"-legacy-repeating-radial-gradient": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
	},
	"-legacy-radial-gradient-arguments": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
	},
	"-legacy-radial-gradient-size": {
		comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
		syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
	},
	"-legacy-radial-gradient-shape": {
		comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
		syntax: "circle | ellipse"
	},
	"-non-standard-font": {
		comment: "non standard fonts",
		references: [
			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
		],
		syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
	},
	"-non-standard-color": {
		comment: "non standard colors",
		references: [
			"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
			"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
		],
		syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
	},
	"-non-standard-image-rendering": {
		comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
		syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
	},
	"-non-standard-overflow": {
		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
		syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
	},
	"-non-standard-width": {
		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
		syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
	},
	"-webkit-gradient()": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
		syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
	},
	"-webkit-gradient-color-stop": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
	},
	"-webkit-gradient-point": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
	},
	"-webkit-gradient-radius": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "<length> | <percentage>"
	},
	"-webkit-gradient-type": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "linear | radial"
	},
	"-webkit-mask-box-repeat": {
		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
		syntax: "repeat | stretch | round"
	},
	"-webkit-mask-clip-style": {
		comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
		syntax: "border | border-box | padding | padding-box | content | content-box | text"
	},
	"-ms-filter-function-list": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<-ms-filter-function>+"
	},
	"-ms-filter-function": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
	},
	"-ms-filter-function-progid": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
	},
	"-ms-filter-function-legacy": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<ident-token> | <function-token> <any-value>? )"
	},
	"-ms-filter": {
		syntax: "<string>"
	},
	age: {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "child | young | old"
	},
	"attr-name": {
		syntax: "<wq-name>"
	},
	"attr-fallback": {
		syntax: "<any-value>"
	},
	"border-radius": {
		comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
		syntax: "<length-percentage>{1,2}"
	},
	bottom: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"content-list": {
		comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
	},
	"element()": {
		comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
		syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
	},
	"generic-voice": {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "[ <age>? <gender> <integer>? ]"
	},
	gender: {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "male | female | neutral"
	},
	"generic-family": {
		comment: "added -apple-system",
		references: [
			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
		],
		syntax: "| -apple-system"
	},
	gradient: {
		comment: "added legacy syntaxes support",
		syntax: "| <-legacy-gradient>"
	},
	left: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"mask-image": {
		comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
		syntax: "<mask-reference>#"
	},
	"name-repeat": {
		comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
		syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
	},
	"named-color": {
		comment: "added non standard color names",
		syntax: "| <-non-standard-color>"
	},
	paint: {
		comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
		syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
	},
	"page-size": {
		comment: "https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size",
		syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
	},
	ratio: {
		comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
		syntax: "<integer> / <integer>"
	},
	right: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	shape: {
		comment: "missed spaces in function body and add backwards compatible syntax",
		syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
	},
	"svg-length": {
		comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
		references: [
			"https://www.w3.org/TR/SVG11/coords.html#Units"
		],
		syntax: "<percentage> | <length> | <number>"
	},
	"svg-writing-mode": {
		comment: "SVG specific keywords (deprecated for CSS)",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
			"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
		],
		syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
	},
	top: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"track-group": {
		comment: "used by old grid-columns and grid-rows syntax v0",
		syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
	},
	"track-list-v0": {
		comment: "used by old grid-columns and grid-rows syntax v0",
		syntax: "[ <string>* <track-group> <string>* ]+ | none"
	},
	"track-minmax": {
		comment: "used by old grid-columns and grid-rows syntax v0",
		syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
	},
	x: {
		comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
		syntax: "<number>"
	},
	y: {
		comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
		syntax: "<number>"
	},
	declaration: {
		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
		syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
	},
	"declaration-list": {
		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
		syntax: "[ <declaration>? ';' ]* <declaration>?"
	},
	url: {
		comment: "https://drafts.csswg.org/css-values-4/#urls",
		syntax: "url( <string> <url-modifier>* ) | <url-token>"
	},
	"url-modifier": {
		comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
		syntax: "<ident> | <function-token> <any-value> )"
	},
	"number-zero-one": {
		syntax: "<number [0,1]>"
	},
	"number-one-or-greater": {
		syntax: "<number [1,âˆž]>"
	},
	"positive-integer": {
		syntax: "<integer [0,âˆž]>"
	},
	"-non-standard-display": {
		syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
	}
};
const require$$3 = {
	atrules: atrules,
	properties: properties,
	syntaxes: syntaxes
};

const mdnAtrules = require$$0;
const mdnProperties = require$$1;
const mdnSyntaxes = require$$2$1;
const patch = require$$3;
const extendSyntax = /^\s*\|\s*/;

function preprocessAtrules(dict) {
    const result = Object.create(null);

    for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;

        if (atrule.descriptors) {
            descriptors = Object.create(null);

            for (const descriptor in atrule.descriptors) {
                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
        }

        result[atruleName.substr(1)] = {
            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
            descriptors
        };
    }

    return result;
}

function patchDictionary(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
    }

    // apply a patch
    for (const key in patchDict) {
        if (key in dict) {
            if (patchDict[key].syntax) {
                result[key] = extendSyntax.test(patchDict[key].syntax)
                    ? result[key] + ' ' + patchDict[key].syntax.trim()
                    : patchDict[key].syntax;
            } else {
                delete result[key];
            }
        } else {
            if (patchDict[key].syntax) {
                result[key] = patchDict[key].syntax.replace(extendSyntax, '');
            }
        }
    }

    return result;
}

function unpackSyntaxes(dict) {
    const result = {};

    for (const key in dict) {
        result[key] = dict[key].syntax;
    }

    return result;
}

function patchAtrules(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;

        result[key] = {
            prelude: key in patchDict && 'prelude' in patchDict[key]
                ? patchDict[key].prelude
                : dict[key].prelude || null,
            descriptors: dict[key].descriptors
                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})
                : patchDescriptors && unpackSyntaxes(patchDescriptors)
        };
    }

    // apply a patch
    for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
            result[key] = {
                prelude: patchDict[key].prelude || null,
                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
            };
        }
    }

    return result;
}

var data$1 = {
    types: patchDictionary(mdnSyntaxes, patch.syntaxes),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
    properties: patchDictionary(mdnProperties, patch.properties)
};

var cmpChar$2 = tokenizer$3.cmpChar;
var isDigit$2 = tokenizer$3.isDigit;
var TYPE$y = tokenizer$3.TYPE;

var WHITESPACE$8 = TYPE$y.WhiteSpace;
var COMMENT$6 = TYPE$y.Comment;
var IDENT$f = TYPE$y.Ident;
var NUMBER$6 = TYPE$y.Number;
var DIMENSION$5 = TYPE$y.Dimension;
var PLUSSIGN$5 = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS$2 = 0x002D; // U+002D HYPHEN-MINUS (-)
var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
    var pos = this.scanner.tokenStart + offset;
    var code = this.scanner.source.charCodeAt(pos);

    if (code === PLUSSIGN$5 || code === HYPHENMINUS$2) {
        if (disallowSign) {
            this.error('Number sign is not allowed');
        }
        pos++;
    }

    for (; pos < this.scanner.tokenEnd; pos++) {
        if (!isDigit$2(this.scanner.source.charCodeAt(pos))) {
            this.error('Integer is expected', pos);
        }
    }
}

function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
    if (!cmpChar$2(this.scanner.source, this.scanner.tokenStart + offset, code)) {
        var msg = '';

        switch (code) {
            case N:
                msg = 'N is expected';
                break;
            case HYPHENMINUS$2:
                msg = 'HyphenMinus is expected';
                break;
        }

        this.error(msg, this.scanner.tokenStart + offset);
    }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB() {
    var offset = 0;
    var sign = 0;
    var type = this.scanner.tokenType;

    while (type === WHITESPACE$8 || type === COMMENT$6) {
        type = this.scanner.lookupType(++offset);
    }

    if (type !== NUMBER$6) {
        if (this.scanner.isDelim(PLUSSIGN$5, offset) ||
            this.scanner.isDelim(HYPHENMINUS$2, offset)) {
            sign = this.scanner.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;

            do {
                type = this.scanner.lookupType(++offset);
            } while (type === WHITESPACE$8 || type === COMMENT$6);

            if (type !== NUMBER$6) {
                this.scanner.skip(offset);
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
        } else {
            return null;
        }
    }

    if (offset > 0) {
        this.scanner.skip(offset);
    }

    if (sign === 0) {
        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        if (type !== PLUSSIGN$5 && type !== HYPHENMINUS$2) {
            this.error('Number sign is expected');
        }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS$2 ? '-' + this.consume(NUMBER$6) : this.consume(NUMBER$6);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
var AnPlusB = {
    name: 'AnPlusB',
    structure: {
        a: [String, null],
        b: [String, null]
    },
    parse: function() {
        /* eslint-disable brace-style*/
        var start = this.scanner.tokenStart;
        var a = null;
        var b = null;

        // <integer>
        if (this.scanner.tokenType === NUMBER$6) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b = this.consume(NUMBER$6);
        }

        // -n
        // -n <signed-integer>
        // -n ['+' | '-'] <signless-integer>
        // -n- <signless-integer>
        // <dashndashdigit-ident>
        else if (this.scanner.tokenType === IDENT$f && cmpChar$2(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$2)) {
            a = '-1';

            expectCharCode.call(this, 1, N);

            switch (this.scanner.getTokenLength()) {
                // -n
                // -n <signed-integer>
                // -n ['+' | '-'] <signless-integer>
                case 2:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // -n- <signless-integer>
                case 3:
                    expectCharCode.call(this, 2, HYPHENMINUS$2);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER$6);
                    break;

                // <dashndashdigit-ident>
                default:
                    expectCharCode.call(this, 2, HYPHENMINUS$2);
                    checkInteger.call(this, 3, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + 2);
            }
        }

        // '+'? n
        // '+'? n <signed-integer>
        // '+'? n ['+' | '-'] <signless-integer>
        // '+'? n- <signless-integer>
        // '+'? <ndashdigit-ident>
        else if (this.scanner.tokenType === IDENT$f || (this.scanner.isDelim(PLUSSIGN$5) && this.scanner.lookupType(1) === IDENT$f)) {
            var sign = 0;
            a = '1';

            // just ignore a plus
            if (this.scanner.isDelim(PLUSSIGN$5)) {
                sign = 1;
                this.scanner.next();
            }

            expectCharCode.call(this, 0, N);

            switch (this.scanner.getTokenLength()) {
                // '+'? n
                // '+'? n <signed-integer>
                // '+'? n ['+' | '-'] <signless-integer>
                case 1:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // '+'? n- <signless-integer>
                case 2:
                    expectCharCode.call(this, 1, HYPHENMINUS$2);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER$6);
                    break;

                // '+'? <ndashdigit-ident>
                default:
                    expectCharCode.call(this, 1, HYPHENMINUS$2);
                    checkInteger.call(this, 2, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + sign + 1);
            }
        }

        // <ndashdigit-dimension>
        // <ndash-dimension> <signless-integer>
        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        else if (this.scanner.tokenType === DIMENSION$5) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN$5 || code === HYPHENMINUS$2;

            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
                if (!isDigit$2(this.scanner.source.charCodeAt(i))) {
                    break;
                }
            }

            if (i === this.scanner.tokenStart + sign) {
                this.error('Integer is expected', this.scanner.tokenStart + sign);
            }

            expectCharCode.call(this, i - this.scanner.tokenStart, N);
            a = this.scanner.source.substring(start, i);

            // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>
            if (i + 1 === this.scanner.tokenEnd) {
                this.scanner.next();
                b = consumeB.call(this);
            } else {
                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$2);

                // <ndash-dimension> <signless-integer>
                if (i + 2 === this.scanner.tokenEnd) {
                    this.scanner.next();
                    this.scanner.skipSC();
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                    b = '-' + this.consume(NUMBER$6);
                }
                // <ndashdigit-dimension>
                else {
                    checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
                    this.scanner.next();
                    b = this.scanner.substrToCursor(i + 1);
                }
            }
        } else {
            this.error();
        }

        if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
            a = a.substr(1);
        }

        if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
            b = b.substr(1);
        }

        return {
            type: 'AnPlusB',
            loc: this.getLocation(start, this.scanner.tokenStart),
            a: a,
            b: b
        };
    },
    generate: function(node) {
        var a = node.a !== null && node.a !== undefined;
        var b = node.b !== null && node.b !== undefined;

        if (a) {
            this.chunk(
                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
            );

            if (b) {
                b = String(node.b);
                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
                    this.chunk(b.charAt(0));
                    this.chunk(b.substr(1));
                } else {
                    this.chunk('+');
                    this.chunk(b);
                }
            }
        } else {
            this.chunk(String(node.b));
        }
    }
};

var tokenizer = tokenizer$3;
var TYPE$x = tokenizer.TYPE;

var WhiteSpace$2 = TYPE$x.WhiteSpace;
var Semicolon = TYPE$x.Semicolon;
var LeftCurlyBracket = TYPE$x.LeftCurlyBracket;
var Delim = TYPE$x.Delim;
var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)

function getOffsetExcludeWS() {
    if (this.scanner.tokenIndex > 0) {
        if (this.scanner.lookupType(-1) === WhiteSpace$2) {
            return this.scanner.tokenIndex > 1
                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
                : this.scanner.firstCharOffset;
        }
    }

    return this.scanner.tokenStart;
}

// 0, 0, false
function balanceEnd() {
    return 0;
}

// LEFTCURLYBRACKET, 0, false
function leftCurlyBracket(tokenType) {
    return tokenType === LeftCurlyBracket ? 1 : 0;
}

// LEFTCURLYBRACKET, SEMICOLON, false
function leftCurlyBracketOrSemicolon(tokenType) {
    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
}

// EXCLAMATIONMARK, SEMICOLON, false
function exclamationMarkOrSemicolon(tokenType, source, offset) {
    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$2) {
        return 1;
    }

    return tokenType === Semicolon ? 1 : 0;
}

// 0, SEMICOLON, true
function semicolonIncluded(tokenType) {
    return tokenType === Semicolon ? 2 : 0;
}

var Raw$1 = {
    name: 'Raw',
    structure: {
        value: String
    },
    parse: function(startToken, mode, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;

        this.scanner.skip(
            this.scanner.getRawLength(startToken, mode || balanceEnd)
        );

        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = getOffsetExcludeWS.call(this);
        } else {
            endOffset = this.scanner.tokenStart;
        }

        return {
            type: 'Raw',
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    },

    mode: {
        default: balanceEnd,
        leftCurlyBracket: leftCurlyBracket,
        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
        semicolonIncluded: semicolonIncluded
    }
};

var TYPE$w = tokenizer$3.TYPE;
var rawMode$5 = Raw$1.mode;

var ATKEYWORD$2 = TYPE$w.AtKeyword;
var SEMICOLON$4 = TYPE$w.Semicolon;
var LEFTCURLYBRACKET$3 = TYPE$w.LeftCurlyBracket;
var RIGHTCURLYBRACKET$1 = TYPE$w.RightCurlyBracket;

function consumeRaw$5(startToken) {
    return this.Raw(startToken, rawMode$5.leftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET$1) {
            return true;
        }

        if (type === LEFTCURLYBRACKET$3 ||
            type === ATKEYWORD$2) {
            return false;
        }
    }

    return false;
}

var Atrule$2 = {
    name: 'Atrule',
    structure: {
        name: String,
        prelude: ['AtrulePrelude', 'Raw', null],
        block: ['Block', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;

        this.eat(ATKEYWORD$2);

        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();

        // parse prelude
        if (this.scanner.eof === false &&
            this.scanner.tokenType !== LEFTCURLYBRACKET$3 &&
            this.scanner.tokenType !== SEMICOLON$4) {
            if (this.parseAtrulePrelude) {
                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw$5);

                // turn empty AtrulePrelude into null
                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
                    prelude = null;
                }
            } else {
                prelude = consumeRaw$5.call(this, this.scanner.tokenIndex);
            }

            this.scanner.skipSC();
        }

        switch (this.scanner.tokenType) {
            case SEMICOLON$4:
                this.scanner.next();
                break;

            case LEFTCURLYBRACKET$3:
                if (this.atrule.hasOwnProperty(nameLowerCase) &&
                    typeof this.atrule[nameLowerCase].block === 'function') {
                    block = this.atrule[nameLowerCase].block.call(this);
                } else {
                    // TODO: should consume block content as Raw?
                    block = this.Block(isDeclarationBlockAtrule.call(this));
                }

                break;
        }

        return {
            type: 'Atrule',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.chunk('@');
        this.chunk(node.name);

        if (node.prelude !== null) {
            this.chunk(' ');
            this.node(node.prelude);
        }

        if (node.block) {
            this.node(node.block);
        } else {
            this.chunk(';');
        }
    },
    walkContext: 'atrule'
};

var TYPE$v = tokenizer$3.TYPE;

var SEMICOLON$3 = TYPE$v.Semicolon;
var LEFTCURLYBRACKET$2 = TYPE$v.LeftCurlyBracket;

var AtrulePrelude = {
    name: 'AtrulePrelude',
    structure: {
        children: [[]]
    },
    parse: function(name) {
        var children = null;

        if (name !== null) {
            name = name.toLowerCase();
        }

        this.scanner.skipSC();

        if (this.atrule.hasOwnProperty(name) &&
            typeof this.atrule[name].prelude === 'function') {
            // custom consumer
            children = this.atrule[name].prelude.call(this);
        } else {
            // default consumer
            children = this.readSequence(this.scope.AtrulePrelude);
        }

        this.scanner.skipSC();

        if (this.scanner.eof !== true &&
            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
            this.scanner.tokenType !== SEMICOLON$3) {
            this.error('Semicolon or block is expected');
        }

        if (children === null) {
            children = this.createList();
        }

        return {
            type: 'AtrulePrelude',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'atrulePrelude'
};

var TYPE$u = tokenizer$3.TYPE;

var IDENT$e = TYPE$u.Ident;
var STRING$3 = TYPE$u.String;
var COLON$6 = TYPE$u.Colon;
var LEFTSQUAREBRACKET$3 = TYPE$u.LeftSquareBracket;
var RIGHTSQUAREBRACKET$1 = TYPE$u.RightSquareBracket;
var DOLLARSIGN$1 = 0x0024;       // U+0024 DOLLAR SIGN ($)
var ASTERISK$5 = 0x002A;         // U+002A ASTERISK (*)
var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
var VERTICALLINE$2 = 0x007C;     // U+007C VERTICAL LINE (|)
var TILDE$2 = 0x007E;            // U+007E TILDE (~)

function getAttributeName() {
    if (this.scanner.eof) {
        this.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdent = false;
    var checkColon = true;

    if (this.scanner.isDelim(ASTERISK$5)) {
        expectIdent = true;
        checkColon = false;
        this.scanner.next();
    } else if (!this.scanner.isDelim(VERTICALLINE$2)) {
        this.eat(IDENT$e);
    }

    if (this.scanner.isDelim(VERTICALLINE$2)) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
            this.scanner.next();
            this.eat(IDENT$e);
        } else if (expectIdent) {
            this.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdent) {
        this.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON$6) {
        this.scanner.next();
        this.eat(IDENT$e);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator() {
    var start = this.scanner.tokenStart;
    var code = this.scanner.source.charCodeAt(start);

    if (code !== EQUALSSIGN &&        // =
        code !== TILDE$2 &&             // ~=
        code !== CIRCUMFLEXACCENT &&  // ^=
        code !== DOLLARSIGN$1 &&        // $=
        code !== ASTERISK$5 &&          // *=
        code !== VERTICALLINE$2         // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    this.scanner.next();

    if (code !== EQUALSSIGN) {
        if (!this.scanner.isDelim(EQUALSSIGN)) {
            this.error('Equal sign is expected');
        }

        this.scanner.next();
    }

    return this.scanner.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
var AttributeSelector$1 = {
    name: 'AttributeSelector',
    structure: {
        name: 'Identifier',
        matcher: [String, null],
        value: ['String', 'Identifier', null],
        flags: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;

        this.eat(LEFTSQUAREBRACKET$3);
        this.scanner.skipSC();

        name = getAttributeName.call(this);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
            // avoid case `[name i]`
            if (this.scanner.tokenType !== IDENT$e) {
                matcher = getOperator.call(this);

                this.scanner.skipSC();

                value = this.scanner.tokenType === STRING$3
                    ? this.String()
                    : this.Identifier();

                this.scanner.skipSC();
            }

            // attribute flags
            if (this.scanner.tokenType === IDENT$e) {
                flags = this.scanner.getTokenValue();
                this.scanner.next();

                this.scanner.skipSC();
            }
        }

        this.eat(RIGHTSQUAREBRACKET$1);

        return {
            type: 'AttributeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    },
    generate: function(node) {
        var flagsPrefix = ' ';

        this.chunk('[');
        this.node(node.name);

        if (node.matcher !== null) {
            this.chunk(node.matcher);

            if (node.value !== null) {
                this.node(node.value);

                // space between string and flags is not required
                if (node.value.type === 'String') {
                    flagsPrefix = '';
                }
            }
        }

        if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
        }

        this.chunk(']');
    }
};

var TYPE$t = tokenizer$3.TYPE;
var rawMode$4 = Raw$1.mode;

var WHITESPACE$7 = TYPE$t.WhiteSpace;
var COMMENT$5 = TYPE$t.Comment;
var SEMICOLON$2 = TYPE$t.Semicolon;
var ATKEYWORD$1 = TYPE$t.AtKeyword;
var LEFTCURLYBRACKET$1 = TYPE$t.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE$t.RightCurlyBracket;

function consumeRaw$4(startToken) {
    return this.Raw(startToken, null, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$4);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, rawMode$4.semicolonIncluded, true);
}
function consumeDeclaration() {
    if (this.scanner.tokenType === SEMICOLON$2) {
        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
    }

    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.scanner.tokenType === SEMICOLON$2) {
        this.scanner.next();
    }

    return node;
}

var Block = {
    name: 'Block',
    structure: {
        children: [[
            'Atrule',
            'Rule',
            'Declaration'
        ]]
    },
    parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

        var start = this.scanner.tokenStart;
        var children = this.createList();

        this.eat(LEFTCURLYBRACKET$1);

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET:
                    break scan;

                case WHITESPACE$7:
                case COMMENT$5:
                    this.scanner.next();
                    break;

                case ATKEYWORD$1:
                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$4));
                    break;

                default:
                    children.push(consumer.call(this));
            }
        }

        if (!this.scanner.eof) {
            this.eat(RIGHTCURLYBRACKET);
        }

        return {
            type: 'Block',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('{');
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
        this.chunk('}');
    },
    walkContext: 'block'
};

var TYPE$s = tokenizer$3.TYPE;

var LEFTSQUAREBRACKET$2 = TYPE$s.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE$s.RightSquareBracket;

var Brackets = {
    name: 'Brackets',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTSQUAREBRACKET$2);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTSQUAREBRACKET);
        }

        return {
            type: 'Brackets',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('[');
        this.children(node);
        this.chunk(']');
    }
};

var CDC$1 = tokenizer$3.TYPE.CDC;

var CDC_1 = {
    name: 'CDC',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDC$1); // -->

        return {
            type: 'CDC',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('-->');
    }
};

var CDO$1 = tokenizer$3.TYPE.CDO;

var CDO_1 = {
    name: 'CDO',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDO$1); // <!--

        return {
            type: 'CDO',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('<!--');
    }
};

var TYPE$r = tokenizer$3.TYPE;

var IDENT$d = TYPE$r.Ident;
var FULLSTOP$2 = 0x002E; // U+002E FULL STOP (.)

// '.' ident
var ClassSelector = {
    name: 'ClassSelector',
    structure: {
        name: String
    },
    parse: function() {
        if (!this.scanner.isDelim(FULLSTOP$2)) {
            this.error('Full stop is expected');
        }

        this.scanner.next();

        return {
            type: 'ClassSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.consume(IDENT$d)
        };
    },
    generate: function(node) {
        this.chunk('.');
        this.chunk(node.name);
    }
};

var TYPE$q = tokenizer$3.TYPE;

var IDENT$c = TYPE$q.Ident;
var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
var TILDE$1 = 0x007E;           // U+007E TILDE (~)

// + | > | ~ | /deep/
var Combinator = {
    name: 'Combinator',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

        switch (code) {
            case GREATERTHANSIGN$1:
            case PLUSSIGN$4:
            case TILDE$1:
                this.scanner.next();
                break;

            case SOLIDUS$5:
                this.scanner.next();

                if (this.scanner.tokenType !== IDENT$c || this.scanner.lookupValue(0, 'deep') === false) {
                    this.error('Identifier `deep` is expected');
                }

                this.scanner.next();

                if (!this.scanner.isDelim(SOLIDUS$5)) {
                    this.error('Solidus is expected');
                }

                this.scanner.next();
                break;

            default:
                this.error('Combinator is expected');
        }

        return {
            type: 'Combinator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

var TYPE$p = tokenizer$3.TYPE;

var COMMENT$4 = TYPE$p.Comment;
var ASTERISK$4 = 0x002A;        // U+002A ASTERISK (*)
var SOLIDUS$4 = 0x002F;         // U+002F SOLIDUS (/)

// '/*' .* '*/'
var Comment$1 = {
    name: 'Comment',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;

        this.eat(COMMENT$4);

        if ((end - start + 2) >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK$4 &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$4) {
            end -= 2;
        }

        return {
            type: 'Comment',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
        };
    },
    generate: function(node) {
        this.chunk('/*');
        this.chunk(node.value);
        this.chunk('*/');
    }
};

var isCustomProperty = names$2.isCustomProperty;
var TYPE$o = tokenizer$3.TYPE;
var rawMode$3 = Raw$1.mode;

var IDENT$b = TYPE$o.Ident;
var HASH$4 = TYPE$o.Hash;
var COLON$5 = TYPE$o.Colon;
var SEMICOLON$1 = TYPE$o.Semicolon;
var DELIM$4 = TYPE$o.Delim;
var WHITESPACE$6 = TYPE$o.WhiteSpace;
var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)
var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
var DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
var AMPERSAND = 0x0026;       // U+0026 ANPERSAND (&)
var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN$3 = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS$3 = 0x002F;         // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
    return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, false);
}

function consumeValue() {
    var startValueToken = this.scanner.tokenIndex;
    var value = this.Value();

    if (value.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== SEMICOLON$1 &&
        this.scanner.isDelim(EXCLAMATIONMARK$1) === false &&
        this.scanner.isBalanceEdge(startValueToken) === false) {
        this.error();
    }

    return value;
}

var Declaration$1 = {
    name: 'Declaration',
    structure: {
        important: [Boolean, String],
        property: String,
        value: ['Value', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.tokenIndex;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;

        this.scanner.skipSC();
        this.eat(COLON$5);

        const valueStart = this.scanner.tokenIndex;

        if (!customProperty) {
            this.scanner.skipSC();
        }

        if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
            value = consumeRaw.call(this, this.scanner.tokenIndex);
        }

        if (customProperty && value.type === 'Value' && value.children.isEmpty()) {
            for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
                if (this.scanner.lookupType(offset) === WHITESPACE$6) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        if (this.scanner.isDelim(EXCLAMATIONMARK$1)) {
            important = getImportant.call(this);
            this.scanner.skipSC();
        }

        // Do not include semicolon to range per spec
        // https://drafts.csswg.org/css-syntax/#declaration-diagram

        if (this.scanner.eof === false &&
            this.scanner.tokenType !== SEMICOLON$1 &&
            this.scanner.isBalanceEdge(startToken) === false) {
            this.error();
        }

        return {
            type: 'Declaration',
            loc: this.getLocation(start, this.scanner.tokenStart),
            important: important,
            property: property,
            value: value
        };
    },
    generate: function(node) {
        this.chunk(node.property);
        this.chunk(':');
        this.node(node.value);

        if (node.important) {
            this.chunk(node.important === true ? '!important' : '!' + node.important);
        }
    },
    walkContext: 'declaration'
};

function readProperty() {
    var start = this.scanner.tokenStart;

    // hacks
    if (this.scanner.tokenType === DELIM$4) {
        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
            case ASTERISK$3:
            case DOLLARSIGN:
            case PLUSSIGN$3:
            case NUMBERSIGN$2:
            case AMPERSAND:
                this.scanner.next();
                break;

            // TODO: not sure we should support this hack
            case SOLIDUS$3:
                this.scanner.next();
                if (this.scanner.isDelim(SOLIDUS$3)) {
                    this.scanner.next();
                }
                break;
        }
    }

    if (this.scanner.tokenType === HASH$4) {
        this.eat(HASH$4);
    } else {
        this.eat(IDENT$b);
    }

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.eat(DELIM$4);
    this.scanner.skipSC();

    var important = this.consume(IDENT$b);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}

var TYPE$n = tokenizer$3.TYPE;
var rawMode$2 = Raw$1.mode;

var WHITESPACE$5 = TYPE$n.WhiteSpace;
var COMMENT$3 = TYPE$n.Comment;
var SEMICOLON = TYPE$n.Semicolon;

function consumeRaw$3(startToken) {
    return this.Raw(startToken, rawMode$2.semicolonIncluded, true);
}

var DeclarationList = {
    name: 'DeclarationList',
    structure: {
        children: [[
            'Declaration'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE$5:
                case COMMENT$3:
                case SEMICOLON:
                    this.scanner.next();
                    break;

                default:
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
            }
        }

        return {
            type: 'DeclarationList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
    }
};

var consumeNumber$2 = utils$7.consumeNumber;
var TYPE$m = tokenizer$3.TYPE;

var DIMENSION$4 = TYPE$m.Dimension;

var Dimension$1 = {
    name: 'Dimension',
    structure: {
        value: String,
        unit: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber$2(this.scanner.source, start);

        this.eat(DIMENSION$4);

        return {
            type: 'Dimension',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
    }
};

var TYPE$l = tokenizer$3.TYPE;

var RIGHTPARENTHESIS$5 = TYPE$l.RightParenthesis;

// <function-token> <sequence> )
var _Function = {
    name: 'Function',
    structure: {
        name: String,
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;

        children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS$5);
        }

        return {
            type: 'Function',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(node.name);
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    },
    walkContext: 'function'
};

var TYPE$k = tokenizer$3.TYPE;

var HASH$3 = TYPE$k.Hash;

// '#' ident
var Hash = {
    name: 'Hash',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(HASH$3);

        return {
            type: 'Hash',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.value);
    }
};

var TYPE$j = tokenizer$3.TYPE;

var IDENT$a = TYPE$j.Ident;

var Identifier = {
    name: 'Identifier',
    structure: {
        name: String
    },
    parse: function() {
        return {
            type: 'Identifier',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.consume(IDENT$a)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

var TYPE$i = tokenizer$3.TYPE;

var HASH$2 = TYPE$i.Hash;

// <hash-token>
var IdSelector = {
    name: 'IdSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // TODO: check value is an ident
        this.eat(HASH$2);

        return {
            type: 'IdSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.name);
    }
};

var TYPE$h = tokenizer$3.TYPE;

var IDENT$9 = TYPE$h.Ident;
var NUMBER$5 = TYPE$h.Number;
var DIMENSION$3 = TYPE$h.Dimension;
var LEFTPARENTHESIS$5 = TYPE$h.LeftParenthesis;
var RIGHTPARENTHESIS$4 = TYPE$h.RightParenthesis;
var COLON$4 = TYPE$h.Colon;
var DELIM$3 = TYPE$h.Delim;

var MediaFeature = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.eat(LEFTPARENTHESIS$5);
        this.scanner.skipSC();

        name = this.consume(IDENT$9);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS$4) {
            this.eat(COLON$4);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER$5:
                    if (this.lookupNonWSType(1) === DELIM$3) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case DIMENSION$3:
                    value = this.Dimension();
                    break;

                case IDENT$9:
                    value = this.Identifier();

                    break;

                default:
                    this.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.eat(RIGHTPARENTHESIS$4);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.chunk(node.name);
        if (node.value !== null) {
            this.chunk(':');
            this.node(node.value);
        }
        this.chunk(')');
    }
};

var TYPE$g = tokenizer$3.TYPE;

var WHITESPACE$4 = TYPE$g.WhiteSpace;
var COMMENT$2 = TYPE$g.Comment;
var IDENT$8 = TYPE$g.Ident;
var LEFTPARENTHESIS$4 = TYPE$g.LeftParenthesis;

var MediaQuery = {
    name: 'MediaQuery',
    structure: {
        children: [[
            'Identifier',
            'MediaFeature',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = this.createList();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT$2:
                    this.scanner.next();
                    continue;

                case WHITESPACE$4:
                    space = this.WhiteSpace();
                    continue;

                case IDENT$8:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS$4:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.push(space);
                space = null;
            }

            children.push(child);
        }

        if (child === null) {
            this.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

var COMMA$3 = tokenizer$3.TYPE.Comma;

var MediaQueryList = {
    name: 'MediaQueryList',
    structure: {
        children: [[
            'MediaQuery'
        ]]
    },
    parse: function(relative) {
        var children = this.createList();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA$3) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    }
};

var Nth = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = this.getLastListNode(selector.children).loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
            this.chunk(' of ');
            this.node(node.selector);
        }
    }
};

var NUMBER$4 = tokenizer$3.TYPE.Number;

var _Number$1 = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(NUMBER$4)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

// '/' | '*' | ',' | ':' | '+' | '-'
var Operator = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var TYPE$f = tokenizer$3.TYPE;

var LEFTPARENTHESIS$3 = TYPE$f.LeftParenthesis;
var RIGHTPARENTHESIS$3 = TYPE$f.RightParenthesis;

var Parentheses = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTPARENTHESIS$3);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS$3);
        }

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    }
};

var consumeNumber$1 = utils$7.consumeNumber;
var TYPE$e = tokenizer$3.TYPE;

var PERCENTAGE$2 = TYPE$e.Percentage;

var Percentage$1 = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber$1(this.scanner.source, start);

        this.eat(PERCENTAGE$2);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk('%');
    }
};

var TYPE$d = tokenizer$3.TYPE;

var IDENT$7 = TYPE$d.Ident;
var FUNCTION$5 = TYPE$d.Function;
var COLON$3 = TYPE$d.Colon;
var RIGHTPARENTHESIS$2 = TYPE$d.RightParenthesis;

// : [ <ident> | <function-token> <any-value>? ) ]
var PseudoClassSelector = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON$3);

        if (this.scanner.tokenType === FUNCTION$5) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS$2);
        } else {
            name = this.consume(IDENT$7);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(':');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};

var TYPE$c = tokenizer$3.TYPE;

var IDENT$6 = TYPE$c.Ident;
var FUNCTION$4 = TYPE$c.Function;
var COLON$2 = TYPE$c.Colon;
var RIGHTPARENTHESIS$1 = TYPE$c.RightParenthesis;

// :: [ <ident> | <function-token> <any-value>? ) ]
var PseudoElementSelector = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON$2);
        this.eat(COLON$2);

        if (this.scanner.tokenType === FUNCTION$4) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS$1);
        } else {
            name = this.consume(IDENT$6);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk('::');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};

var isDigit$1 = tokenizer$3.isDigit;
var TYPE$b = tokenizer$3.TYPE;

var NUMBER$3 = TYPE$b.Number;
var DELIM$2 = TYPE$b.Delim;
var SOLIDUS$2 = 0x002F;  // U+002F SOLIDUS (/)
var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber() {
    this.scanner.skipWS();

    var value = this.consume(NUMBER$3);

    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isDigit$1(code) && code !== FULLSTOP$1) {
            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
var Ratio = {
    name: 'Ratio',
    structure: {
        left: String,
        right: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber.call(this);
        var right;

        this.scanner.skipWS();

        if (!this.scanner.isDelim(SOLIDUS$2)) {
            this.error('Solidus is expected');
        }
        this.eat(DELIM$2);
        right = consumeNumber.call(this);

        return {
            type: 'Ratio',
            loc: this.getLocation(start, this.scanner.tokenStart),
            left: left,
            right: right
        };
    },
    generate: function(node) {
        this.chunk(node.left);
        this.chunk('/');
        this.chunk(node.right);
    }
};

var TYPE$a = tokenizer$3.TYPE;
var rawMode$1 = Raw$1.mode;

var LEFTCURLYBRACKET = TYPE$a.LeftCurlyBracket;

function consumeRaw$2(startToken) {
    return this.Raw(startToken, rawMode$1.leftCurlyBracket, true);
}

function consumePrelude() {
    var prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.error();
    }

    return prelude;
}

var Rule$1 = {
    name: 'Rule',
    structure: {
        prelude: ['SelectorList', 'Raw'],
        block: ['Block']
    },
    parse: function() {
        var startToken = this.scanner.tokenIndex;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;

        if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw$2);
        } else {
            prelude = consumeRaw$2.call(this, startToken);
        }

        block = this.Block(true);

        return {
            type: 'Rule',
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
    },
    walkContext: 'rule'
};

var Selector = {
    name: 'Selector',
    structure: {
        children: [[
            'TypeSelector',
            'IdSelector',
            'ClassSelector',
            'AttributeSelector',
            'PseudoClassSelector',
            'PseudoElementSelector',
            'Combinator',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        var children = this.readSequence(this.scope.Selector);

        // nothing were consumed
        if (this.getFirstListNode(children) === null) {
            this.error('Selector is expected');
        }

        return {
            type: 'Selector',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

var TYPE$9 = tokenizer$3.TYPE;

var COMMA$2 = TYPE$9.Comma;

var SelectorList = {
    name: 'SelectorList',
    structure: {
        children: [[
            'Selector',
            'Raw'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            children.push(this.Selector());

            if (this.scanner.tokenType === COMMA$2) {
                this.scanner.next();
                continue;
            }

            break;
        }

        return {
            type: 'SelectorList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    },
    walkContext: 'selector'
};

var STRING$2 = tokenizer$3.TYPE.String;

var _String$1 = {
    name: 'String',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'String',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(STRING$2)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var TYPE$8 = tokenizer$3.TYPE;

var WHITESPACE$3 = TYPE$8.WhiteSpace;
var COMMENT$1 = TYPE$8.Comment;
var ATKEYWORD = TYPE$8.AtKeyword;
var CDO = TYPE$8.CDO;
var CDC = TYPE$8.CDC;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw$1(startToken) {
    return this.Raw(startToken, null, false);
}

var StyleSheet = {
    name: 'StyleSheet',
    structure: {
        children: [[
            'Comment',
            'CDO',
            'CDC',
            'Atrule',
            'Rule',
            'Raw'
        ]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;

        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE$3:
                    this.scanner.next();
                    continue;

                case COMMENT$1:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                        this.scanner.next();
                        continue;
                    }

                    child = this.Comment();
                    break;

                case CDO: // <!--
                    child = this.CDO();
                    break;

                case CDC: // -->
                    child = this.CDC();
                    break;

                // CSS Syntax Module Level 3
                // Â§2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case ATKEYWORD:
                    child = this.parseWithFallback(this.Atrule, consumeRaw$1);
                    break;

                // Anything else starts a qualified rule ...
                default:
                    child = this.parseWithFallback(this.Rule, consumeRaw$1);
            }

            children.push(child);
        }

        return {
            type: 'StyleSheet',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'stylesheet'
};

var TYPE$7 = tokenizer$3.TYPE;

var IDENT$5 = TYPE$7.Ident;
var ASTERISK$2 = 0x002A;     // U+002A ASTERISK (*)
var VERTICALLINE$1 = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENT$5 &&
        this.scanner.isDelim(ASTERISK$2) === false) {
        this.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
var TypeSelector$1 = {
    name: 'TypeSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        if (this.scanner.isDelim(VERTICALLINE$1)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);

            if (this.scanner.isDelim(VERTICALLINE$1)) {
                this.scanner.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }

        return {
            type: 'TypeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

var isHexDigit = tokenizer$3.isHexDigit;
var cmpChar$1 = tokenizer$3.cmpChar;
var TYPE$6 = tokenizer$3.TYPE;
var NAME = tokenizer$3.NAME;

var IDENT$4 = TYPE$6.Ident;
var NUMBER$2 = TYPE$6.Number;
var DIMENSION$2 = TYPE$6.Dimension;
var PLUSSIGN$2 = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS$1 = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function eatHexSequence(offset, allowDash) {
    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
        var code = this.scanner.source.charCodeAt(pos);

        if (code === HYPHENMINUS$1 && allowDash && len !== 0) {
            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
                this.error();
            }

            return -1;
        }

        if (!isHexDigit(code)) {
            this.error(
                allowDash && len !== 0
                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
                pos
            );
        }

        if (++len > 6) {
            this.error('Too many hex digits', pos);
        }    }

    this.scanner.next();
    return len;
}

function eatQuestionMarkSequence(max) {
    var count = 0;

    while (this.scanner.isDelim(QUESTIONMARK)) {
        if (++count > max) {
            this.error('Too many question marks');
        }

        this.scanner.next();
    }
}

function startsWith(code) {
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
        this.error(NAME[code] + ' is expected');
    }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
    var hexLength = 0;

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (this.scanner.isDelim(PLUSSIGN$2)) {
        this.scanner.next();

        if (this.scanner.tokenType === IDENT$4) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            return;
        }

        if (this.scanner.isDelim(QUESTIONMARK)) {
            this.scanner.next();
            eatQuestionMarkSequence.call(this, 5);
            return;
        }

        this.error('Hex digit or question mark is expected');
        return;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (this.scanner.tokenType === NUMBER$2) {
        startsWith.call(this, PLUSSIGN$2);
        hexLength = eatHexSequence.call(this, 1, true);

        if (this.scanner.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            return;
        }

        if (this.scanner.tokenType === DIMENSION$2 ||
            this.scanner.tokenType === NUMBER$2) {
            startsWith.call(this, HYPHENMINUS$1);
            eatHexSequence.call(this, 1, false);
            return;
        }

        return;
    }

    // u <dimension-token> '?'*
    if (this.scanner.tokenType === DIMENSION$2) {
        startsWith.call(this, PLUSSIGN$2);
        hexLength = eatHexSequence.call(this, 1, true);

        if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
        }

        return;
    }

    this.error();
}

var UnicodeRange = {
    name: 'UnicodeRange',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // U or u
        if (!cmpChar$1(this.scanner.source, start, U$1)) {
            this.error('U is expected');
        }

        if (!cmpChar$1(this.scanner.source, start + 1, PLUSSIGN$2)) {
            this.error('Plus sign is expected');
        }

        this.scanner.next();
        scanUnicodeRange.call(this);

        return {
            type: 'UnicodeRange',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var isWhiteSpace = tokenizer$3.isWhiteSpace;
var cmpStr$1 = tokenizer$3.cmpStr;
var TYPE$5 = tokenizer$3.TYPE;

var FUNCTION$3 = TYPE$5.Function;
var URL$3 = TYPE$5.Url;
var RIGHTPARENTHESIS = TYPE$5.RightParenthesis;

// <url-token> | <function-token> <string> )
var Url$1 = {
    name: 'Url',
    structure: {
        value: ['String', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value;

        switch (this.scanner.tokenType) {
            case URL$3:
                var rawStart = start + 4;
                var rawEnd = this.scanner.tokenEnd - 1;

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
                    rawStart++;
                }

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
                    rawEnd--;
                }

                value = {
                    type: 'Raw',
                    loc: this.getLocation(rawStart, rawEnd),
                    value: this.scanner.source.substring(rawStart, rawEnd)
                };

                this.eat(URL$3);
                break;

            case FUNCTION$3:
                if (!cmpStr$1(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
                    this.error('Function name must be `url`');
                }

                this.eat(FUNCTION$3);
                this.scanner.skipSC();
                value = this.String();
                this.scanner.skipSC();
                this.eat(RIGHTPARENTHESIS);
                break;

            default:
                this.error('Url or Function is expected');
        }

        return {
            type: 'Url',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value
        };
    },
    generate: function(node) {
        this.chunk('url');
        this.chunk('(');
        this.node(node.value);
        this.chunk(')');
    }
};

var Value$1 = {
    name: 'Value',
    structure: {
        children: [[]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);

        return {
            type: 'Value',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

var WHITESPACE$2 = tokenizer$3.TYPE.WhiteSpace;
var SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

var WhiteSpace$1 = {
    name: 'WhiteSpace',
    structure: {
        value: String
    },
    parse: function() {
        this.eat(WHITESPACE$2);
        return SPACE;

        // return {
        //     type: 'WhiteSpace',
        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        //     value: this.consume(WHITESPACE)
        // };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var node = {
    AnPlusB: AnPlusB,
    Atrule: Atrule$2,
    AtrulePrelude: AtrulePrelude,
    AttributeSelector: AttributeSelector$1,
    Block: Block,
    Brackets: Brackets,
    CDC: CDC_1,
    CDO: CDO_1,
    ClassSelector: ClassSelector,
    Combinator: Combinator,
    Comment: Comment$1,
    Declaration: Declaration$1,
    DeclarationList: DeclarationList,
    Dimension: Dimension$1,
    Function: _Function,
    Hash: Hash,
    Identifier: Identifier,
    IdSelector: IdSelector,
    MediaFeature: MediaFeature,
    MediaQuery: MediaQuery,
    MediaQueryList: MediaQueryList,
    Nth: Nth,
    Number: _Number$1,
    Operator: Operator,
    Parentheses: Parentheses,
    Percentage: Percentage$1,
    PseudoClassSelector: PseudoClassSelector,
    PseudoElementSelector: PseudoElementSelector,
    Ratio: Ratio,
    Raw: Raw$1,
    Rule: Rule$1,
    Selector: Selector,
    SelectorList: SelectorList,
    String: _String$1,
    StyleSheet: StyleSheet,
    TypeSelector: TypeSelector$1,
    UnicodeRange: UnicodeRange,
    Url: Url$1,
    Value: Value$1,
    WhiteSpace: WhiteSpace$1
};

var data = data$1;

var lexer$2 = {
    generic: true,
    types: data.types,
    atrules: data.atrules,
    properties: data.properties,
    node: node
};

var cmpChar = tokenizer$3.cmpChar;
var cmpStr = tokenizer$3.cmpStr;
var TYPE$4 = tokenizer$3.TYPE;

var IDENT$3 = TYPE$4.Ident;
var STRING$1 = TYPE$4.String;
var NUMBER$1 = TYPE$4.Number;
var FUNCTION$2 = TYPE$4.Function;
var URL$2 = TYPE$4.Url;
var HASH$1 = TYPE$4.Hash;
var DIMENSION$1 = TYPE$4.Dimension;
var PERCENTAGE$1 = TYPE$4.Percentage;
var LEFTPARENTHESIS$2 = TYPE$4.LeftParenthesis;
var LEFTSQUAREBRACKET$1 = TYPE$4.LeftSquareBracket;
var COMMA$1 = TYPE$4.Comma;
var DELIM$1 = TYPE$4.Delim;
var NUMBERSIGN$1 = 0x0023;  // U+0023 NUMBER SIGN (#)
var ASTERISK$1 = 0x002A;    // U+002A ASTERISK (*)
var PLUSSIGN$1 = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var SOLIDUS$1 = 0x002F;     // U+002F SOLIDUS (/)
var U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

var _default = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
        case HASH$1:
            return this.Hash();

        case COMMA$1:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();

        case LEFTPARENTHESIS$2:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LEFTSQUAREBRACKET$1:
            return this.Brackets(this.readSequence, context.recognizer);

        case STRING$1:
            return this.String();

        case DIMENSION$1:
            return this.Dimension();

        case PERCENTAGE$1:
            return this.Percentage();

        case NUMBER$1:
            return this.Number();

        case FUNCTION$2:
            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
                ? this.Url()
                : this.Function(this.readSequence, context.recognizer);

        case URL$2:
            return this.Url();

        case IDENT$3:
            // check for unicode range, it should start with u+ or U+
            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$1)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }

        case DELIM$1:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            if (code === SOLIDUS$1 ||
                code === ASTERISK$1 ||
                code === PLUSSIGN$1 ||
                code === HYPHENMINUS) {
                return this.Operator(); // TODO: replace with Delim
            }

            // TODO: produce a node with Delim node type

            if (code === NUMBERSIGN$1) {
                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
            }

            break;
    }
};

var atrulePrelude = {
    getNode: _default
};

var TYPE$3 = tokenizer$3.TYPE;

var DELIM = TYPE$3.Delim;
var IDENT$2 = TYPE$3.Ident;
var DIMENSION = TYPE$3.Dimension;
var PERCENTAGE = TYPE$3.Percentage;
var NUMBER = TYPE$3.Number;
var HASH = TYPE$3.Hash;
var COLON$1 = TYPE$3.Colon;
var LEFTSQUAREBRACKET = TYPE$3.LeftSquareBracket;
var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
var FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
var VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
var TILDE = 0x007E;           // U+007E TILDE (~)

function getNode(context) {
    switch (this.scanner.tokenType) {
        case LEFTSQUAREBRACKET:
            return this.AttributeSelector();

        case HASH:
            return this.IdSelector();

        case COLON$1:
            if (this.scanner.lookupType(1) === COLON$1) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case IDENT$2:
            return this.TypeSelector();

        case NUMBER:
        case PERCENTAGE:
            return this.Percentage();

        case DIMENSION:
            // throws when .123ident
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
                this.error('Identifier is expected', this.scanner.tokenStart + 1);
            }
            break;

        case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            switch (code) {
                case PLUSSIGN:
                case GREATERTHANSIGN:
                case TILDE:
                    context.space = null;
                    context.ignoreWSAfter = true;
                    return this.Combinator();

                case SOLIDUS:  // /deep/
                    return this.Combinator();

                case FULLSTOP:
                    return this.ClassSelector();

                case ASTERISK:
                case VERTICALLINE:
                    return this.TypeSelector();

                case NUMBERSIGN:
                    return this.IdSelector();
            }

            break;
    }
}
var selector = {
    getNode: getNode
};

// legacy IE function
// expression( <any-value> )
var expression = function() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
};

var TYPE$2 = tokenizer$3.TYPE;
var rawMode = Raw$1.mode;

var COMMA = TYPE$2.Comma;
var WHITESPACE$1 = TYPE$2.WhiteSpace;

// var( <ident> , <value>? )
var _var = function() {
    var children = this.createList();

    this.scanner.skipSC();

    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    children.push(this.Identifier());

    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());

        const startIndex = this.scanner.tokenIndex;
        const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);

        if (value.type === 'Value' && value.children.isEmpty()) {
            for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
                if (this.scanner.lookupType(offset) === WHITESPACE$1) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        children.push(value);
    }

    return children;
};

var value = {
    getNode: _default,
    'expression': expression,
    'var': _var
};

var scope = {
    AtrulePrelude: atrulePrelude,
    Selector: selector,
    Value: value
};

var fontFace = {
    parse: {
        prelude: null,
        block: function() {
            return this.Block(true);
        }
    }
};

var TYPE$1 = tokenizer$3.TYPE;

var STRING = TYPE$1.String;
var IDENT$1 = TYPE$1.Ident;
var URL$1 = TYPE$1.Url;
var FUNCTION$1 = TYPE$1.Function;
var LEFTPARENTHESIS$1 = TYPE$1.LeftParenthesis;

var _import = {
    parse: {
        prelude: function() {
            var children = this.createList();

            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case STRING:
                    children.push(this.String());
                    break;

                case URL$1:
                case FUNCTION$1:
                    children.push(this.Url());
                    break;

                default:
                    this.error('String or url() is expected');
            }

            if (this.lookupNonWSType(0) === IDENT$1 ||
                this.lookupNonWSType(0) === LEFTPARENTHESIS$1) {
                children.push(this.WhiteSpace());
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};

var media = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block: function() {
            return this.Block(false);
        }
    }
};

var page = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block: function() {
            return this.Block(true);
        }
    }
};

var TYPE = tokenizer$3.TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
}

function parentheses() {
    this.scanner.skipSC();

    if (this.scanner.tokenType === IDENT &&
        this.lookupNonWSType(1) === COLON) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    var children = this.createList();
    var space = null;
    var child;

    this.scanner.skipSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE:
                space = this.WhiteSpace();
                continue;

            case COMMENT:
                this.scanner.next();
                continue;

            case FUNCTION:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case IDENT:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.push(space);
            space = null;
        }

        children.push(child);
    }

    return children;
}

var supports = {
    parse: {
        prelude: function() {
            var children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.error('Condition is expected');
            }

            return children;
        },
        block: function() {
            return this.Block(false);
        }
    }
};

var atrule = {
    'font-face': fontFace,
    'import': _import,
    'media': media,
    'page': page,
    'supports': supports
};

var dir = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

var has = {
    parse: function() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

var lang = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

var matchesExports = {};
var matches$1 = {
  get exports(){ return matchesExports; },
  set exports(v){ matchesExports = v; },
};

var selectorList = {
    parse: function selectorList() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

(function (module) {
	module.exports = selectorList;
} (matches$1));

var notExports = {};
var not = {
  get exports(){ return notExports; },
  set exports(v){ notExports = v; },
};

(function (module) {
	module.exports = selectorList;
} (not));

var nthChildExports = {};
var nthChild = {
  get exports(){ return nthChildExports; },
  set exports(v){ nthChildExports = v; },
};

var ALLOW_OF_CLAUSE = true;

var nthWithOfClause = {
    parse: function nthWithOfClause() {
        return this.createSingleNodeList(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};

(function (module) {
	module.exports = nthWithOfClause;
} (nthChild));

var nthLastChildExports = {};
var nthLastChild = {
  get exports(){ return nthLastChildExports; },
  set exports(v){ nthLastChildExports = v; },
};

(function (module) {
	module.exports = nthWithOfClause;
} (nthLastChild));

var nthLastOfTypeExports = {};
var nthLastOfType = {
  get exports(){ return nthLastOfTypeExports; },
  set exports(v){ nthLastOfTypeExports = v; },
};

var DISALLOW_OF_CLAUSE = false;

var nth = {
    parse: function nth() {
        return this.createSingleNodeList(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};

(function (module) {
	module.exports = nth;
} (nthLastOfType));

var nthOfTypeExports = {};
var nthOfType = {
  get exports(){ return nthOfTypeExports; },
  set exports(v){ nthOfTypeExports = v; },
};

(function (module) {
	module.exports = nth;
} (nthOfType));

var slotted = {
    parse: function compoundSelector() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};

var pseudo = {
    'dir': dir,
    'has': has,
    'lang': lang,
    'matches': matchesExports,
    'not': notExports,
    'nth-child': nthChildExports,
    'nth-last-child': nthLastChildExports,
    'nth-last-of-type': nthLastOfTypeExports,
    'nth-of-type': nthOfTypeExports,
    'slotted': slotted
};

var parser$1 = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude: function(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block: function() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: scope,
    atrule: atrule,
    pseudo: pseudo,
    node: node
};

var walker = {
    node: node
};

const name$1 = "css-tree";
const version$1 = "1.1.3";
const description$1 = "A tool set for CSS: fast detailed parser (CSS â†’ AST), walker (AST traversal), generator (AST â†’ CSS) and lexer (validation and matching) based on specs and browser implementations";
const author$1 = "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)";
const license$1 = "MIT";
const repository$1 = "csstree/csstree";
const keywords$1 = [
	"css",
	"ast",
	"tokenizer",
	"parser",
	"walker",
	"lexer",
	"generator",
	"utils",
	"syntax",
	"validation"
];
const main$1 = "lib/index.js";
const unpkg = "dist/csstree.min.js";
const jsdelivr = "dist/csstree.min.js";
const scripts$1 = {
	build: "rollup --config",
	lint: "eslint data lib scripts test && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
	"lint-and-test": "npm run lint && npm test",
	"update:docs": "node scripts/update-docs",
	"review:syntax-patch": "node scripts/review-syntax-patch",
	test: "mocha --reporter progress",
	coverage: "nyc npm test",
	travis: "nyc npm run lint-and-test && npm run coveralls",
	coveralls: "nyc report --reporter=text-lcov | coveralls",
	prepublishOnly: "npm run build",
	hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
};
const dependencies$1 = {
	"mdn-data": "2.0.14",
	"source-map": "^0.6.1"
};
const devDependencies$1 = {
	"@rollup/plugin-commonjs": "^11.0.2",
	"@rollup/plugin-json": "^4.0.2",
	"@rollup/plugin-node-resolve": "^7.1.1",
	coveralls: "^3.0.9",
	eslint: "^6.8.0",
	"json-to-ast": "^2.1.0",
	mocha: "^6.2.3",
	nyc: "^14.1.1",
	rollup: "^1.32.1",
	"rollup-plugin-terser": "^5.3.0"
};
const engines$1 = {
	node: ">=8.0.0"
};
const files$1 = [
	"data",
	"dist",
	"lib"
];
const require$$4 = {
	name: name$1,
	version: version$1,
	description: description$1,
	author: author$1,
	license: license$1,
	repository: repository$1,
	keywords: keywords$1,
	main: main$1,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	scripts: scripts$1,
	dependencies: dependencies$1,
	devDependencies: devDependencies$1,
	engines: engines$1,
	files: files$1
};

function merge() {
    var dest = {};

    for (var i = 0; i < arguments.length; i++) {
        var src = arguments[i];
        for (var key in src) {
            dest[key] = src[key];
        }
    }

    return dest;
}

syntax.exports = create$4.create(
    merge(
        lexer$2,
        parser$1,
        walker
    )
);
syntaxExports.version = require$$4.version;

(function (module) {
	module.exports = syntaxExports;
} (lib$1));

var cssTools = {};

var stableExports = {};
var stable$3 = {
  get exports(){ return stableExports; },
  set exports(v){ stableExports = v; },
};

(function (module, exports) {
	//! stable.js 0.1.8, https://github.com/Two-Screen/stable
	//! Â© 2018 Angry Bytes and contributors. MIT licensed.

	(function (global, factory) {
	  module.exports = factory() ;
	}(commonjsGlobal, (function () {
	  // A stable array sort, because `Array#sort()` is not guaranteed stable.
	  // This is an implementation of merge sort, without recursion.

	  var stable = function (arr, comp) {
	    return exec(arr.slice(), comp)
	  };

	  stable.inplace = function (arr, comp) {
	    var result = exec(arr, comp);

	    // This simply copies back if the result isn't in the original array,
	    // which happens on an odd number of passes.
	    if (result !== arr) {
	      pass(result, null, arr.length, arr);
	    }

	    return arr
	  };

	  // Execute the sort using the input array and a second buffer as work space.
	  // Returns one of those two, containing the final result.
	  function exec(arr, comp) {
	    if (typeof(comp) !== 'function') {
	      comp = function (a, b) {
	        return String(a).localeCompare(b)
	      };
	    }

	    // Short-circuit when there's nothing to sort.
	    var len = arr.length;
	    if (len <= 1) {
	      return arr
	    }

	    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
	    // Chunks are the size of the left or right hand in merge sort.
	    // Stop when the left-hand covers all of the array.
	    var buffer = new Array(len);
	    for (var chk = 1; chk < len; chk *= 2) {
	      pass(arr, comp, chk, buffer);

	      var tmp = arr;
	      arr = buffer;
	      buffer = tmp;
	    }

	    return arr
	  }

	  // Run a single pass with the given chunk size.
	  var pass = function (arr, comp, chk, result) {
	    var len = arr.length;
	    var i = 0;
	    // Step size / double chunk size.
	    var dbl = chk * 2;
	    // Bounds of the left and right chunks.
	    var l, r, e;
	    // Iterators over the left and right chunk.
	    var li, ri;

	    // Iterate over pairs of chunks.
	    for (l = 0; l < len; l += dbl) {
	      r = l + chk;
	      e = r + chk;
	      if (r > len) r = len;
	      if (e > len) e = len;

	      // Iterate both chunks in parallel.
	      li = l;
	      ri = r;
	      while (true) {
	        // Compare the chunks.
	        if (li < r && ri < e) {
	          // This works for a regular `sort()` compatible comparator,
	          // but also for a simple comparator like: `a > b`
	          if (comp(arr[li], arr[ri]) <= 0) {
	            result[i++] = arr[li++];
	          }
	          else {
	            result[i++] = arr[ri++];
	          }
	        }
	        // Nothing to compare, just flush what's left.
	        else if (li < r) {
	          result[i++] = arr[li++];
	        }
	        else if (ri < e) {
	          result[i++] = arr[ri++];
	        }
	        // Both iterators are at the chunk ends.
	        else {
	          break
	        }
	      }
	    }
	  };

	  return stable;

	})));
} (stable$3));

var specificity$4 = function specificity(simpleSelector) {
    var A = 0;
    var B = 0;
    var C = 0;

    simpleSelector.children.each(function walk(node) {
        switch (node.type) {
            case 'SelectorList':
            case 'Selector':
                node.children.each(walk);
                break;

            case 'IdSelector':
                A++;
                break;

            case 'ClassSelector':
            case 'AttributeSelector':
                B++;
                break;

            case 'PseudoClassSelector':
                switch (node.name.toLowerCase()) {
                    case 'not':
                        node.children.each(walk);
                        break;

                    case 'before':
                    case 'after':
                    case 'first-line':
                    case 'first-letter':
                        C++;
                        break;

                    // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()
                    default:
                        B++;
                }
                break;

            case 'PseudoElementSelector':
                C++;
                break;

            case 'TypeSelector':
                // ignore universal selector
                if (node.name.charAt(node.name.length - 1) !== '*') {
                    C++;
                }
                break;

        }
    });

    return [A, B, C];
};

var csstree$5 = libExports,
  List$6 = csstree$5.List,
  stable$2 = stableExports,
  specificity$3 = specificity$4;

/**
 * Flatten a CSS AST to a selectors list.
 *
 * @param {import('css-tree').CssNode} cssAst css-tree AST to flatten
 * @return {Array} selectors
 */
function flattenToSelectors(cssAst) {
  var selectors = [];

  csstree$5.walk(cssAst, {
    visit: 'Rule',
    enter: function (node) {
      if (node.type !== 'Rule') {
        return;
      }

      var atrule = this.atrule;
      var rule = node;

      node.prelude.children.each(function (selectorNode, selectorItem) {
        var selector = {
          item: selectorItem,
          atrule: atrule,
          rule: rule,
          pseudos: /** @type {{item: any; list: any[]}[]} */ ([]),
        };

        selectorNode.children.each(function (
          selectorChildNode,
          selectorChildItem,
          selectorChildList
        ) {
          if (
            selectorChildNode.type === 'PseudoClassSelector' ||
            selectorChildNode.type === 'PseudoElementSelector'
          ) {
            selector.pseudos.push({
              item: selectorChildItem,
              list: selectorChildList,
            });
          }
        });

        selectors.push(selector);
      });
    },
  });

  return selectors;
}

/**
 * Filter selectors by Media Query.
 *
 * @param {Array} selectors to filter
 * @param {Array} useMqs Array with strings of media queries that should pass (<name> <expression>)
 * @return {Array} Filtered selectors that match the passed media queries
 */
function filterByMqs(selectors, useMqs) {
  return selectors.filter(function (selector) {
    if (selector.atrule === null) {
      return ~useMqs.indexOf('');
    }

    var mqName = selector.atrule.name;
    var mqStr = mqName;
    if (
      selector.atrule.expression &&
      selector.atrule.expression.children.first().type === 'MediaQueryList'
    ) {
      var mqExpr = csstree$5.generate(selector.atrule.expression);
      mqStr = [mqName, mqExpr].join(' ');
    }

    return ~useMqs.indexOf(mqStr);
  });
}

/**
 * Filter selectors by the pseudo-elements and/or -classes they contain.
 *
 * @param {Array} selectors to filter
 * @param {Array} usePseudos Array with strings of single or sequence of pseudo-elements and/or -classes that should pass
 * @return {Array} Filtered selectors that match the passed pseudo-elements and/or -classes
 */
function filterByPseudos(selectors, usePseudos) {
  return selectors.filter(function (selector) {
    var pseudoSelectorsStr = csstree$5.generate({
      type: 'Selector',
      children: new List$6().fromArray(
        selector.pseudos.map(function (pseudo) {
          return pseudo.item.data;
        })
      ),
    });
    return ~usePseudos.indexOf(pseudoSelectorsStr);
  });
}

/**
 * Remove pseudo-elements and/or -classes from the selectors for proper matching.
 *
 * @param {Array} selectors to clean
 * @return {void}
 */
function cleanPseudos(selectors) {
  selectors.forEach(function (selector) {
    selector.pseudos.forEach(function (pseudo) {
      pseudo.list.remove(pseudo.item);
    });
  });
}

/**
 * Compares two selector specificities.
 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
 *
 * @param {Array} aSpecificity Specificity of selector A
 * @param {Array} bSpecificity Specificity of selector B
 * @return {number} Score of selector specificity A compared to selector specificity B
 */
function compareSpecificity$2(aSpecificity, bSpecificity) {
  for (var i = 0; i < 4; i += 1) {
    if (aSpecificity[i] < bSpecificity[i]) {
      return -1;
    } else if (aSpecificity[i] > bSpecificity[i]) {
      return 1;
    }
  }

  return 0;
}

/**
 * Compare two simple selectors.
 *
 * @param {Object} aSimpleSelectorNode Simple selector A
 * @param {Object} bSimpleSelectorNode Simple selector B
 * @return {number} Score of selector A compared to selector B
 */
function compareSimpleSelectorNode(aSimpleSelectorNode, bSimpleSelectorNode) {
  var aSpecificity = specificity$3(aSimpleSelectorNode),
    bSpecificity = specificity$3(bSimpleSelectorNode);
  return compareSpecificity$2(aSpecificity, bSpecificity);
}

function _bySelectorSpecificity(selectorA, selectorB) {
  return compareSimpleSelectorNode(selectorA.item.data, selectorB.item.data);
}

/**
 * Sort selectors stably by their specificity.
 *
 * @param {Array} selectors to be sorted
 * @return {Array} Stable sorted selectors
 */
function sortSelectors(selectors) {
  return stable$2(selectors, _bySelectorSpecificity);
}

/**
 * Convert a css-tree AST style declaration to CSSStyleDeclaration property.
 *
 * @param {import('css-tree').CssNode} declaration css-tree style declaration
 * @return {Object} CSSStyleDeclaration property
 */
function csstreeToStyleDeclaration(declaration) {
  var propertyName = declaration.property,
    propertyValue = csstree$5.generate(declaration.value),
    propertyPriority = declaration.important ? 'important' : '';
  return {
    name: propertyName,
    value: propertyValue,
    priority: propertyPriority,
  };
}

/**
 * Gets the CSS string of a style element
 *
 * @param {Object} elem style element
 * @return {string} CSS string or empty array if no styles are set
 */
function getCssStr(elem) {
  if (
    elem.children.length > 0 &&
    (elem.children[0].type === 'text' || elem.children[0].type === 'cdata')
  ) {
    return elem.children[0].value;
  }
  return '';
}

/**
 * Sets the CSS string of a style element
 *
 * @param {Object} elem style element
 * @param {string} css string to be set
 * @return {string} reference to field with CSS
 */
function setCssStr(elem, css) {
  if (elem.children.length === 0) {
    elem.children.push({
      type: 'text',
      value: '',
    });
  }

  if (elem.children[0].type !== 'text' && elem.children[0].type !== 'cdata') {
    return css;
  }

  elem.children[0].value = css;

  return css;
}

cssTools.flattenToSelectors = flattenToSelectors;

cssTools.filterByMqs = filterByMqs;
cssTools.filterByPseudos = filterByPseudos;
cssTools.cleanPseudos = cleanPseudos;

cssTools.compareSpecificity = compareSpecificity$2;
cssTools.compareSimpleSelectorNode = compareSimpleSelectorNode;

cssTools.sortSelectors = sortSelectors;

cssTools.csstreeToStyleDeclaration = csstreeToStyleDeclaration;

cssTools.getCssStr = getCssStr;
cssTools.setCssStr = setCssStr;

var csstree$4 = libExports,
  csstools = cssTools;

var CSSStyleDeclaration$1 = function (node) {
  this.parentNode = node;

  this.properties = new Map();
  this.hasSynced = false;

  this.styleValue = null;

  this.parseError = false;
  const value = node.attributes.style;
  if (value != null) {
    this.addStyleValueHandler();
    this.setStyleValue(value);
  }
};

// attr.style.value

CSSStyleDeclaration$1.prototype.addStyleValueHandler = function () {
  Object.defineProperty(this.parentNode.attributes, 'style', {
    get: this.getStyleValue.bind(this),
    set: this.setStyleValue.bind(this),
    enumerable: true,
    configurable: true,
  });
};

CSSStyleDeclaration$1.prototype.getStyleValue = function () {
  return this.getCssText();
};

CSSStyleDeclaration$1.prototype.setStyleValue = function (newValue) {
  this.properties.clear(); // reset all existing properties
  this.styleValue = newValue;
  this.hasSynced = false; // raw css changed
};

CSSStyleDeclaration$1.prototype._loadCssText = function () {
  if (this.hasSynced) {
    return;
  }
  this.hasSynced = true; // must be set here to prevent loop in setProperty(...)

  if (!this.styleValue || this.styleValue.length === 0) {
    return;
  }
  var inlineCssStr = this.styleValue;

  var declarations = {};
  try {
    declarations = csstree$4.parse(inlineCssStr, {
      context: 'declarationList',
      parseValue: false,
    });
  } catch (parseError) {
    this.parseError = parseError;
    return;
  }
  this.parseError = false;

  var self = this;
  declarations.children.each(function (declaration) {
    try {
      var styleDeclaration = csstools.csstreeToStyleDeclaration(declaration);
      self.setProperty(
        styleDeclaration.name,
        styleDeclaration.value,
        styleDeclaration.priority
      );
    } catch (styleError) {
      if (styleError.message !== 'Unknown node type: undefined') {
        self.parseError = styleError;
      }
    }
  });
};

// only reads from properties

/**
 * Get the textual representation of the declaration block (equivalent to .cssText attribute).
 *
 * @return {string} Textual representation of the declaration block (empty string for no properties)
 */
CSSStyleDeclaration$1.prototype.getCssText = function () {
  var properties = this.getProperties();

  if (this.parseError) {
    // in case of a parse error, pass through original styles
    return this.styleValue;
  }

  var cssText = [];
  properties.forEach(function (property, propertyName) {
    var strImportant = property.priority === 'important' ? '!important' : '';
    cssText.push(
      propertyName.trim() + ':' + property.value.trim() + strImportant
    );
  });
  return cssText.join(';');
};

CSSStyleDeclaration$1.prototype._handleParseError = function () {
  if (this.parseError) {
    console.warn(
      "Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr('style').value. Error details: " +
        this.parseError
    );
  }
};

CSSStyleDeclaration$1.prototype._getProperty = function (propertyName) {
  if (typeof propertyName === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  var properties = this.getProperties();
  this._handleParseError();

  var property = properties.get(propertyName.trim());
  return property;
};

/**
 * Return the optional priority, "important".
 *
 * @param {string} propertyName representing the property name to be checked.
 * @return {string} priority that represents the priority (e.g. "important") if one exists. If none exists, returns the empty string.
 */
CSSStyleDeclaration$1.prototype.getPropertyPriority = function (propertyName) {
  var property = this._getProperty(propertyName);
  return property ? property.priority : '';
};

/**
 * Return the property value given a property name.
 *
 * @param {string} propertyName representing the property name to be checked.
 * @return {string} value containing the value of the property. If not set, returns the empty string.
 */
CSSStyleDeclaration$1.prototype.getPropertyValue = function (propertyName) {
  var property = this._getProperty(propertyName);
  return property ? property.value : null;
};

/**
 * Return a property name.
 *
 * @param {number} index of the node to be fetched. The index is zero-based.
 * @return {string} propertyName that is the name of the CSS property at the specified index.
 */
CSSStyleDeclaration$1.prototype.item = function (index) {
  if (typeof index === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  var properties = this.getProperties();
  this._handleParseError();

  return Array.from(properties.keys())[index];
};

/**
 * Return all properties of the node.
 *
 * @return {Map} properties that is a Map with propertyName as key and property (propertyValue + propertyPriority) as value.
 */
CSSStyleDeclaration$1.prototype.getProperties = function () {
  this._loadCssText();
  return this.properties;
};

// writes to properties

/**
 * Remove a property from the CSS declaration block.
 *
 * @param {string} propertyName representing the property name to be removed.
 * @return {string} oldValue equal to the value of the CSS property before it was removed.
 */
CSSStyleDeclaration$1.prototype.removeProperty = function (propertyName) {
  if (typeof propertyName === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  this.addStyleValueHandler();

  var properties = this.getProperties();
  this._handleParseError();

  var oldValue = this.getPropertyValue(propertyName);
  properties.delete(propertyName.trim());
  return oldValue;
};

/**
 * Modify an existing CSS property or creates a new CSS property in the declaration block.
 *
 * @param {string} propertyName representing the CSS property name to be modified.
 * @param {string} value containing the new property value. If not specified, treated as the empty string. value must not contain "!important" -- that should be set using the priority parameter.
 * @param {string} priority allowing the "important" CSS priority to be set. If not specified, treated as the empty string.
 * @return {{value: string, priority: string}}
 */
CSSStyleDeclaration$1.prototype.setProperty = function (
  propertyName,
  value,
  priority
) {
  if (typeof propertyName === 'undefined') {
    throw Error('propertyName argument required, but only not present.');
  }

  this.addStyleValueHandler();

  var properties = this.getProperties();
  this._handleParseError();

  var property = {
    value: value.trim(),
    priority: priority.trim(),
  };
  properties.set(propertyName.trim(), property);

  return property;
};

var cssStyleDeclaration = CSSStyleDeclaration$1;

const { selectAll, selectOne, is } = lib$8;
const svgoCssSelectAdapter = cssSelectAdapter;
const CSSClassList = cssClassList;
const CSSStyleDeclaration = cssStyleDeclaration;

/**
 * @type {(name: string) => { prefix: string, local: string }}
 */
const parseName = (name) => {
  if (name == null) {
    return {
      prefix: '',
      local: '',
    };
  }
  if (name === 'xmlns') {
    return {
      prefix: 'xmlns',
      local: '',
    };
  }
  const chunks = name.split(':');
  if (chunks.length === 1) {
    return {
      prefix: '',
      local: chunks[0],
    };
  }
  return {
    prefix: chunks[0],
    local: chunks[1],
  };
};

var cssSelectOpts = {
  xmlMode: true,
  adapter: svgoCssSelectAdapter,
};

const attrsHandler = {
  get: (attributes, name) => {
    // eslint-disable-next-line no-prototype-builtins
    if (attributes.hasOwnProperty(name)) {
      return {
        name,
        get value() {
          return attributes[name];
        },
        set value(value) {
          attributes[name] = value;
        },
      };
    }
  },
  set: (attributes, name, attr) => {
    attributes[name] = attr.value;
    return true;
  },
};

var JSAPI$4 = function (data, parentNode) {
  Object.assign(this, data);
  if (this.type === 'element') {
    if (this.attributes == null) {
      this.attributes = {};
    }
    if (this.children == null) {
      this.children = [];
    }
    Object.defineProperty(this, 'class', {
      writable: true,
      configurable: true,
      value: new CSSClassList(this),
    });
    Object.defineProperty(this, 'style', {
      writable: true,
      configurable: true,
      value: new CSSStyleDeclaration(this),
    });
    Object.defineProperty(this, 'parentNode', {
      writable: true,
      value: parentNode,
    });

    // temporary attrs polyfill
    // TODO remove after migration
    const element = this;
    Object.defineProperty(this, 'attrs', {
      configurable: true,
      get() {
        return new Proxy(element.attributes, attrsHandler);
      },
      set(value) {
        const newAttributes = {};
        for (const attr of Object.values(value)) {
          newAttributes[attr.name] = attr.value;
        }
        element.attributes = newAttributes;
      },
    });
  }
};
var jsAPI = JSAPI$4;

/**
 * Perform a deep clone of this node.
 *
 * @return {Object} element
 */
JSAPI$4.prototype.clone = function () {
  const { children, ...nodeData } = this;
  // Deep-clone node data.
  const clonedNode = new JSAPI$4(JSON.parse(JSON.stringify(nodeData)), null);
  if (children) {
    clonedNode.children = children.map((child) => {
      const clonedChild = child.clone();
      clonedChild.parentNode = clonedNode;
      return clonedChild;
    });
  }
  return clonedNode;
};

/**
 * Determine if item is an element
 * (any, with a specific name or in a names array).
 *
 * @param {String|Array} [param] element name or names arrays
 * @return {Boolean}
 */
JSAPI$4.prototype.isElem = function (param) {
  if (this.type !== 'element') {
    return false;
  }
  if (param == null) {
    return true;
  }
  if (Array.isArray(param)) {
    return param.includes(this.name);
  }
  return this.name === param;
};

/**
 * Renames an element
 *
 * @param {String} name new element name
 * @return {Object} element
 */
JSAPI$4.prototype.renameElem = function (name) {
  if (name && typeof name === 'string') this.name = name;

  return this;
};

/**
 * Determine if element is empty.
 *
 * @return {Boolean}
 */
JSAPI$4.prototype.isEmpty = function () {
  return !this.children || !this.children.length;
};

/**
 * Find the closest ancestor of the current element.
 * @param elemName
 *
 * @return {?Object}
 */
JSAPI$4.prototype.closestElem = function (elemName) {
  var elem = this;

  while ((elem = elem.parentNode) && !elem.isElem(elemName));

  return elem;
};

/**
 * Changes children by removing elements and/or adding new elements.
 *
 * @param {Number} start Index at which to start changing the children.
 * @param {Number} n Number of elements to remove.
 * @param {Array|Object} [insertion] Elements to add to the children.
 * @return {Array} Removed elements.
 */
JSAPI$4.prototype.spliceContent = function (start, n, insertion) {
  if (arguments.length < 2) return [];

  if (!Array.isArray(insertion))
    insertion = Array.apply(null, arguments).slice(2);

  insertion.forEach(function (inner) {
    inner.parentNode = this;
  }, this);

  return this.children.splice.apply(
    this.children,
    [start, n].concat(insertion)
  );
};

/**
 * Determine if element has an attribute
 * (any, or by name or by name + value).
 *
 * @param {String} [name] attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Boolean}
 */
JSAPI$4.prototype.hasAttr = function (name, val) {
  if (this.type !== 'element') {
    return false;
  }
  if (Object.keys(this.attributes).length === 0) {
    return false;
  }
  if (name == null) {
    return true;
  }
  // eslint-disable-next-line no-prototype-builtins
  if (this.attributes.hasOwnProperty(name) === false) {
    return false;
  }
  if (val !== undefined) {
    return this.attributes[name] === val.toString();
  }
  return true;
};

/**
 * Determine if element has an attribute by local name
 * (any, or by name or by name + value).
 *
 * @param {String} [localName] local attribute name
 * @param {Number|String|RegExp|Function} [val] attribute value (will be toString()'ed or executed, otherwise ignored)
 * @return {Boolean}
 */
JSAPI$4.prototype.hasAttrLocal = function (localName, val) {
  if (!this.attrs || !Object.keys(this.attrs).length) return false;

  if (!arguments.length) return !!this.attrs;

  var callback;

  switch (val != null && val.constructor && val.constructor.name) {
    case 'Number': // same as String
    case 'String':
      callback = stringValueTest;
      break;
    case 'RegExp':
      callback = regexpValueTest;
      break;
    case 'Function':
      callback = funcValueTest;
      break;
    default:
      callback = nameTest;
  }
  return this.someAttr(callback);

  function nameTest(attr) {
    const { local } = parseName(attr.name);
    return local === localName;
  }

  function stringValueTest(attr) {
    const { local } = parseName(attr.name);
    return local === localName && val == attr.value;
  }

  function regexpValueTest(attr) {
    const { local } = parseName(attr.name);
    return local === localName && val.test(attr.value);
  }

  function funcValueTest(attr) {
    const { local } = parseName(attr.name);
    return local === localName && val(attr.value);
  }
};

/**
 * Get a specific attribute from an element
 * (by name or name + value).
 *
 * @param {String} name attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Object|Undefined}
 */
JSAPI$4.prototype.attr = function (name, val) {
  if (this.hasAttr(name, val)) {
    return this.attrs[name];
  }
};

/**
 * Get computed attribute value from an element
 *
 * @param {String} name attribute name
 * @return {Object|Undefined}
 */
JSAPI$4.prototype.computedAttr = function (name, val) {
  if (!arguments.length) return;

  for (
    var elem = this;
    elem && (!elem.hasAttr(name) || !elem.attributes[name]);
    elem = elem.parentNode
  );

  if (val != null) {
    return elem ? elem.hasAttr(name, val) : false;
  } else if (elem && elem.hasAttr(name)) {
    return elem.attributes[name];
  }
};

/**
 * Remove a specific attribute.
 *
 * @param {String|Array} name attribute name
 * @param {String} [val] attribute value
 * @return {Boolean}
 */
JSAPI$4.prototype.removeAttr = function (name, val) {
  if (this.type !== 'element') {
    return false;
  }
  if (arguments.length === 0) {
    return false;
  }
  if (Array.isArray(name)) {
    for (const nameItem of name) {
      this.removeAttr(nameItem, val);
    }
    return false;
  }
  if (this.hasAttr(name, val) === false) {
    return false;
  }
  delete this.attributes[name];
  return true;
};

/**
 * Add attribute.
 *
 * @param {Object} [attr={}] attribute object
 * @return {Object|Boolean} created attribute or false if no attr was passed in
 */
JSAPI$4.prototype.addAttr = function (attr) {
  attr = attr || {};

  if (attr.name === undefined) return false;

  this.attributes[attr.name] = attr.value;

  if (attr.name === 'class') {
    // newly added class attribute
    this.class.addClassValueHandler();
  }

  if (attr.name === 'style') {
    // newly added style attribute
    this.style.addStyleValueHandler();
  }

  return this.attrs[attr.name];
};

/**
 * Iterates over all attributes.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */
JSAPI$4.prototype.eachAttr = function (callback, context) {
  if (this.type !== 'element') {
    return false;
  }
  if (callback == null) {
    return false;
  }
  for (const attr of Object.values(this.attrs)) {
    callback.call(context, attr);
  }
  return true;
};

/**
 * Tests whether some attribute passes the test.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */
JSAPI$4.prototype.someAttr = function (callback, context) {
  if (this.type !== 'element') {
    return false;
  }

  for (const attr of Object.values(this.attrs)) {
    if (callback.call(context, attr)) return true;
  }

  return false;
};

/**
 * Evaluate a string of CSS selectors against the element and returns matched elements.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no elements matched
 */
JSAPI$4.prototype.querySelectorAll = function (selectors) {
  var matchedEls = selectAll(selectors, this, cssSelectOpts);

  return matchedEls.length > 0 ? matchedEls : null;
};

/**
 * Evaluate a string of CSS selectors against the element and returns only the first matched element.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no element matched
 */
JSAPI$4.prototype.querySelector = function (selectors) {
  return selectOne(selectors, this, cssSelectOpts);
};

/**
 * Test if a selector matches a given element.
 *
 * @param {String} selector CSS selector string
 * @return {Boolean} true if element would be selected by selector string, false if it does not
 */
JSAPI$4.prototype.matches = function (selector) {
  return is(this, selector, cssSelectOpts);
};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { visitSkip: visitSkip$5, detachNodeFromParent: detachNodeFromParent$g } = xast;
const JSAPI$3 = jsAPI;

mergeStyles$1.name = 'mergeStyles';
mergeStyles$1.type = 'visitor';
mergeStyles$1.active = true;
mergeStyles$1.description = 'merge multiple style elements into one';

/**
 * Merge multiple style elements into one.
 *
 * @author strarsis <strarsis@gmail.com>
 *
 * @type {import('../lib/types').Plugin<void>}
 */
mergeStyles$1.fn = () => {
  /**
   * @type {null | XastElement}
   */
  let firstStyleElement = null;
  let collectedStyles = '';
  let styleContentType = 'text';

  return {
    element: {
      enter: (node, parentNode) => {
        // skip <foreignObject> content
        if (node.name === 'foreignObject') {
          return visitSkip$5;
        }

        // collect style elements
        if (node.name !== 'style') {
          return;
        }

        // skip <style> with invalid type attribute
        if (
          node.attributes.type != null &&
          node.attributes.type !== '' &&
          node.attributes.type !== 'text/css'
        ) {
          return;
        }

        // extract style element content
        let css = '';
        for (const child of node.children) {
          if (child.type === 'text') {
            css += child.value;
          }
          if (child.type === 'cdata') {
            styleContentType = 'cdata';
            css += child.value;
          }
        }

        // remove empty style elements
        if (css.trim().length === 0) {
          detachNodeFromParent$g(node, parentNode);
          return;
        }

        // collect css and wrap with media query if present in attribute
        if (node.attributes.media == null) {
          collectedStyles += css;
        } else {
          collectedStyles += `@media ${node.attributes.media}{${css}}`;
          delete node.attributes.media;
        }

        // combine collected styles in the first style element
        if (firstStyleElement == null) {
          firstStyleElement = node;
        } else {
          detachNodeFromParent$g(node, parentNode);
          firstStyleElement.children = [
            new JSAPI$3(
              { type: styleContentType, value: collectedStyles },
              firstStyleElement
            ),
          ];
        }
      },
    },
  };
};

var inlineStyles$1 = {};

/**
 * @typedef {import('../lib/types').Specificity} Specificity
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 */

const csstree$3 = libExports;
// @ts-ignore not defined in @types/csso
const specificity$2 = specificity$4;
const stable$1 = stableExports;
const {
  visitSkip: visitSkip$4,
  querySelectorAll: querySelectorAll$1,
  detachNodeFromParent: detachNodeFromParent$f,
} = xast;

inlineStyles$1.type = 'visitor';
inlineStyles$1.name = 'inlineStyles';
inlineStyles$1.active = true;
inlineStyles$1.description = 'inline styles (additional options)';

/**
 * Compares two selector specificities.
 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
 *
 * @type {(a: Specificity, b: Specificity) => number}
 */
const compareSpecificity$1 = (a, b) => {
  for (var i = 0; i < 4; i += 1) {
    if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }
  return 0;
};

/**
 * Moves + merges styles from style elements to element styles
 *
 * Options
 *   onlyMatchedOnce (default: true)
 *     inline only selectors that match once
 *
 *   removeMatchedSelectors (default: true)
 *     clean up matched selectors,
 *     leave selectors that hadn't matched
 *
 *   useMqs (default: ['', 'screen'])
 *     what media queries to be used
 *     empty string element for styles outside media queries
 *
 *   usePseudos (default: [''])
 *     what pseudo-classes/-elements to be used
 *     empty string element for all non-pseudo-classes and/or -elements
 *
 * @author strarsis <strarsis@gmail.com>
 *
 * @type {import('../lib/types').Plugin<{
 *   onlyMatchedOnce?: boolean,
 *   removeMatchedSelectors?: boolean,
 *   useMqs?: Array<string>,
 *   usePseudos?: Array<string>
 * }>}
 */
inlineStyles$1.fn = (root, params) => {
  const {
    onlyMatchedOnce = true,
    removeMatchedSelectors = true,
    useMqs = ['', 'screen'],
    usePseudos = [''],
  } = params;

  /**
   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}
   */
  const styles = [];
  /**
   * @type {Array<{
   *   node: csstree.Selector,
   *   item: csstree.ListItem<csstree.CssNode>,
   *   rule: csstree.Rule,
   *   matchedElements?: Array<XastElement>
   * }>}
   */
  let selectors = [];

  return {
    element: {
      enter: (node, parentNode) => {
        // skip <foreignObject /> content
        if (node.name === 'foreignObject') {
          return visitSkip$4;
        }
        // collect only non-empty <style /> elements
        if (node.name !== 'style' || node.children.length === 0) {
          return;
        }
        // values other than the empty string or text/css are not used
        if (
          node.attributes.type != null &&
          node.attributes.type !== '' &&
          node.attributes.type !== 'text/css'
        ) {
          return;
        }
        // parse css in style element
        let cssText = '';
        for (const child of node.children) {
          if (child.type === 'text' || child.type === 'cdata') {
            cssText += child.value;
          }
        }
        /**
         * @type {null | csstree.CssNode}
         */
        let cssAst = null;
        try {
          cssAst = csstree$3.parse(cssText, {
            parseValue: false,
            parseCustomProperty: false,
          });
        } catch {
          return;
        }
        if (cssAst.type === 'StyleSheet') {
          styles.push({ node, parentNode, cssAst });
        }

        // collect selectors
        csstree$3.walk(cssAst, {
          visit: 'Selector',
          enter(node, item) {
            const atrule = this.atrule;
            const rule = this.rule;
            if (rule == null) {
              return;
            }

            // skip media queries not included into useMqs param
            let mq = '';
            if (atrule != null) {
              mq = atrule.name;
              if (atrule.prelude != null) {
                mq += ` ${csstree$3.generate(atrule.prelude)}`;
              }
            }
            if (useMqs.includes(mq) === false) {
              return;
            }

            /**
             * @type {Array<{
             *   item: csstree.ListItem<csstree.CssNode>,
             *   list: csstree.List<csstree.CssNode>
             * }>}
             */
            const pseudos = [];
            if (node.type === 'Selector') {
              node.children.each((childNode, childItem, childList) => {
                if (
                  childNode.type === 'PseudoClassSelector' ||
                  childNode.type === 'PseudoElementSelector'
                ) {
                  pseudos.push({ item: childItem, list: childList });
                }
              });
            }

            // skip pseudo classes and pseudo elements not includes into usePseudos param
            const pseudoSelectors = csstree$3.generate({
              type: 'Selector',
              children: new csstree$3.List().fromArray(
                pseudos.map((pseudo) => pseudo.item.data)
              ),
            });
            if (usePseudos.includes(pseudoSelectors) === false) {
              return;
            }

            // remove pseudo classes and elements to allow querySelector match elements
            // TODO this is not very accurate since some pseudo classes like first-child
            // are used for selection
            for (const pseudo of pseudos) {
              pseudo.list.remove(pseudo.item);
            }

            selectors.push({ node, item, rule });
          },
        });
      },
    },

    root: {
      exit: () => {
        if (styles.length === 0) {
          return;
        }
        // stable sort selectors
        const sortedSelectors = stable$1(selectors, (a, b) => {
          const aSpecificity = specificity$2(a.item.data);
          const bSpecificity = specificity$2(b.item.data);
          return compareSpecificity$1(aSpecificity, bSpecificity);
        }).reverse();

        for (const selector of sortedSelectors) {
          // match selectors
          const selectorText = csstree$3.generate(selector.item.data);
          /**
           * @type {Array<XastElement>}
           */
          const matchedElements = [];
          try {
            for (const node of querySelectorAll$1(root, selectorText)) {
              if (node.type === 'element') {
                matchedElements.push(node);
              }
            }
          } catch (selectError) {
            continue;
          }
          // nothing selected
          if (matchedElements.length === 0) {
            continue;
          }

          // apply styles to matched elements
          // skip selectors that match more than once if option onlyMatchedOnce is enabled
          if (onlyMatchedOnce && matchedElements.length > 1) {
            continue;
          }

          // apply <style/> to matched elements
          for (const selectedEl of matchedElements) {
            const styleDeclarationList = csstree$3.parse(
              selectedEl.attributes.style == null
                ? ''
                : selectedEl.attributes.style,
              {
                context: 'declarationList',
                parseValue: false,
              }
            );
            if (styleDeclarationList.type !== 'DeclarationList') {
              continue;
            }
            const styleDeclarationItems = new Map();
            csstree$3.walk(styleDeclarationList, {
              visit: 'Declaration',
              enter(node, item) {
                styleDeclarationItems.set(node.property, item);
              },
            });
            // merge declarations
            csstree$3.walk(selector.rule, {
              visit: 'Declaration',
              enter(ruleDeclaration) {
                // existing inline styles have higher priority
                // no inline styles, external styles,                                    external styles used
                // inline styles,    external styles same   priority as inline styles,   inline   styles used
                // inline styles,    external styles higher priority than inline styles, external styles used
                const matchedItem = styleDeclarationItems.get(
                  ruleDeclaration.property
                );
                const ruleDeclarationItem =
                  styleDeclarationList.children.createItem(ruleDeclaration);
                if (matchedItem == null) {
                  styleDeclarationList.children.append(ruleDeclarationItem);
                } else if (
                  matchedItem.data.important !== true &&
                  ruleDeclaration.important === true
                ) {
                  styleDeclarationList.children.replace(
                    matchedItem,
                    ruleDeclarationItem
                  );
                  styleDeclarationItems.set(
                    ruleDeclaration.property,
                    ruleDeclarationItem
                  );
                }
              },
            });
            selectedEl.attributes.style =
              csstree$3.generate(styleDeclarationList);
          }

          if (
            removeMatchedSelectors &&
            matchedElements.length !== 0 &&
            selector.rule.prelude.type === 'SelectorList'
          ) {
            // clean up matching simple selectors if option removeMatchedSelectors is enabled
            selector.rule.prelude.children.remove(selector.item);
          }
          selector.matchedElements = matchedElements;
        }

        // no further processing required
        if (removeMatchedSelectors === false) {
          return;
        }

        // clean up matched class + ID attribute values
        for (const selector of sortedSelectors) {
          if (selector.matchedElements == null) {
            continue;
          }

          if (onlyMatchedOnce && selector.matchedElements.length > 1) {
            // skip selectors that match more than once if option onlyMatchedOnce is enabled
            continue;
          }

          for (const selectedEl of selector.matchedElements) {
            // class
            const classList = new Set(
              selectedEl.attributes.class == null
                ? null
                : selectedEl.attributes.class.split(' ')
            );
            const firstSubSelector = selector.node.children.first();
            if (
              firstSubSelector != null &&
              firstSubSelector.type === 'ClassSelector'
            ) {
              classList.delete(firstSubSelector.name);
            }
            if (classList.size === 0) {
              delete selectedEl.attributes.class;
            } else {
              selectedEl.attributes.class = Array.from(classList).join(' ');
            }

            // ID
            if (
              firstSubSelector != null &&
              firstSubSelector.type === 'IdSelector'
            ) {
              if (selectedEl.attributes.id === firstSubSelector.name) {
                delete selectedEl.attributes.id;
              }
            }
          }
        }

        for (const style of styles) {
          csstree$3.walk(style.cssAst, {
            visit: 'Rule',
            enter: function (node, item, list) {
              // clean up <style/> rulesets without any css selectors left
              if (
                node.type === 'Rule' &&
                node.prelude.type === 'SelectorList' &&
                node.prelude.children.isEmpty()
              ) {
                list.remove(item);
              }
            },
          });

          if (style.cssAst.children.isEmpty()) {
            // remove emtpy style element
            detachNodeFromParent$f(style.node, style.parentNode);
          } else {
            // update style element if any styles left
            const firstChild = style.node.children[0];
            if (firstChild.type === 'text' || firstChild.type === 'cdata') {
              firstChild.value = csstree$3.generate(style.cssAst);
            }
          }
        }
      },
    },
  };
};

var minifyStyles$1 = {};

var hasOwnProperty$4 = Object.prototype.hasOwnProperty;

function buildMap(list, caseInsensitive) {
    var map = Object.create(null);

    if (!Array.isArray(list)) {
        return null;
    }

    for (var i = 0; i < list.length; i++) {
        var name = list[i];

        if (caseInsensitive) {
            name = name.toLowerCase();
        }

        map[name] = true;
    }

    return map;
}

function buildList(data) {
    if (!data) {
        return null;
    }

    var tags = buildMap(data.tags, true);
    var ids = buildMap(data.ids);
    var classes = buildMap(data.classes);

    if (tags === null &&
        ids === null &&
        classes === null) {
        return null;
    }

    return {
        tags: tags,
        ids: ids,
        classes: classes
    };
}

function buildIndex(data) {
    var scopes = false;

    if (data.scopes && Array.isArray(data.scopes)) {
        scopes = Object.create(null);

        for (var i = 0; i < data.scopes.length; i++) {
            var list = data.scopes[i];

            if (!list || !Array.isArray(list)) {
                throw new Error('Wrong usage format');
            }

            for (var j = 0; j < list.length; j++) {
                var name = list[j];

                if (hasOwnProperty$4.call(scopes, name)) {
                    throw new Error('Class can\'t be used for several scopes: ' + name);
                }

                scopes[name] = i + 1;
            }
        }
    }

    return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes: scopes
    };
}

var usage = {
    buildIndex: buildIndex
};

var utils$4 = {
    hasNoChildren: function(node) {
        return !node || !node.children || node.children.isEmpty();
    },
    isNodeChildrenList: function(node, list) {
        return node !== null && node.children === list;
    }
};

var resolveKeyword$4 = libExports.keyword;
var { hasNoChildren: hasNoChildren$1 } = utils$4;

var Atrule$1 = function cleanAtrule(node, item, list) {
    if (node.block) {
        // otherwise removed at-rule don't prevent @import for removal
        if (this.stylesheet !== null) {
            this.stylesheet.firstAtrulesAllowed = false;
        }

        if (hasNoChildren$1(node.block)) {
            list.remove(item);
            return;
        }
    }

    switch (node.name) {
        case 'charset':
            if (hasNoChildren$1(node.prelude)) {
                list.remove(item);
                return;
            }

            // if there is any rule before @charset -> remove it
            if (item.prev) {
                list.remove(item);
                return;
            }

            break;

        case 'import':
            if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
                list.remove(item);
                return;
            }

            // if there are some rules that not an @import or @charset before @import
            // remove it
            list.prevUntil(item.prev, function(rule) {
                if (rule.type === 'Atrule') {
                    if (rule.name === 'import' || rule.name === 'charset') {
                        return;
                    }
                }

                this.root.firstAtrulesAllowed = false;
                list.remove(item);
                return true;
            }, this);

            break;

        default:
            var name = resolveKeyword$4(node.name).basename;
            if (name === 'keyframes' ||
                name === 'media' ||
                name === 'supports') {

                // drop at-rule with no prelude
                if (hasNoChildren$1(node.prelude) || hasNoChildren$1(node.block)) {
                    list.remove(item);
                }
            }
    }
};

var Comment = function cleanComment(data, item, list) {
    list.remove(item);
};

var property = libExports.property;

var Declaration = function cleanDeclartion(node, item, list) {
    if (node.value.children && node.value.children.isEmpty()) {
        list.remove(item);
        return;
    }

    if (property(node.property).custom) {
        if (/\S/.test(node.value.value)) {
            node.value.value = node.value.value.trim();
        }
    }
};

var { isNodeChildrenList: isNodeChildrenList$1 } = utils$4;

var Raw = function cleanRaw(node, item, list) {
    // raw in stylesheet or block children
    if (isNodeChildrenList$1(this.stylesheet, list) ||
        isNodeChildrenList$1(this.block, list)) {
        list.remove(item);
    }
};

var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var walk$b = libExports.walk;
var { hasNoChildren } = utils$4;

function cleanUnused(selectorList, usageData) {
    selectorList.children.each(function(selector, item, list) {
        var shouldRemove = false;

        walk$b(selector, function(node) {
            // ignore nodes in nested selectors
            if (this.selector === null || this.selector === selectorList) {
                switch (node.type) {
                    case 'SelectorList':
                        // TODO: remove toLowerCase when pseudo selectors will be normalized
                        // ignore selectors inside :not()
                        if (this.function === null || this.function.name.toLowerCase() !== 'not') {
                            if (cleanUnused(node, usageData)) {
                                shouldRemove = true;
                            }
                        }
                        break;

                    case 'ClassSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.classes !== null &&
                            !hasOwnProperty$3.call(usageData.whitelist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.classes !== null &&
                            hasOwnProperty$3.call(usageData.blacklist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'IdSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.ids !== null &&
                            !hasOwnProperty$3.call(usageData.whitelist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.ids !== null &&
                            hasOwnProperty$3.call(usageData.blacklist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'TypeSelector':
                        // TODO: remove toLowerCase when type selectors will be normalized
                        // ignore universal selectors
                        if (node.name.charAt(node.name.length - 1) !== '*') {
                            if (usageData.whitelist !== null &&
                                usageData.whitelist.tags !== null &&
                                !hasOwnProperty$3.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                            if (usageData.blacklist !== null &&
                                usageData.blacklist.tags !== null &&
                                hasOwnProperty$3.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                        }
                        break;
                }
            }
        });

        if (shouldRemove) {
            list.remove(item);
        }
    });

    return selectorList.children.isEmpty();
}

var Rule = function cleanRule(node, item, list, options) {
    if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
        list.remove(item);
        return;
    }

    var usageData = options.usage;

    if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
        cleanUnused(node.prelude, usageData);

        if (hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
        }
    }
};

// remove useless universal selector
var TypeSelector = function cleanTypeSelector(node, item, list) {
    var name = item.data.name;

    // check it's a non-namespaced universal selector
    if (name !== '*') {
        return;
    }

    // remove when universal selector before other selectors
    var nextType = item.next && item.next.data.type;
    if (nextType === 'IdSelector' ||
        nextType === 'ClassSelector' ||
        nextType === 'AttributeSelector' ||
        nextType === 'PseudoClassSelector' ||
        nextType === 'PseudoElementSelector') {
        list.remove(item);
    }
};

var { isNodeChildrenList } = utils$4;

function isSafeOperator(node) {
    return node.type === 'Operator' && node.value !== '+' && node.value !== '-';
}

var WhiteSpace = function cleanWhitespace(node, item, list) {
    // remove when first or last item in sequence
    if (item.next === null || item.prev === null) {
        list.remove(item);
        return;
    }

    // white space in stylesheet or block children
    if (isNodeChildrenList(this.stylesheet, list) ||
        isNodeChildrenList(this.block, list)) {
        list.remove(item);
        return;
    }

    if (item.next.data.type === 'WhiteSpace') {
        list.remove(item);
        return;
    }

    if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
        list.remove(item);
        return;
    }
};

var walk$a = libExports.walk;
var handlers$2 = {
    Atrule: Atrule$1,
    Comment: Comment,
    Declaration: Declaration,
    Raw: Raw,
    Rule: Rule,
    TypeSelector: TypeSelector,
    WhiteSpace: WhiteSpace
};

var clean$1 = function(ast, options) {
    walk$a(ast, {
        leave: function(node, item, list) {
            if (handlers$2.hasOwnProperty(node.type)) {
                handlers$2[node.type].call(this, node, item, list, options);
            }
        }
    });
};

var keyframes = function(node) {
    node.block.children.each(function(rule) {
        rule.prelude.children.each(function(simpleselector) {
            simpleselector.children.each(function(data, item) {
                if (data.type === 'Percentage' && data.value === '100') {
                    item.data = {
                        type: 'TypeSelector',
                        loc: data.loc,
                        name: 'to'
                    };
                } else if (data.type === 'TypeSelector' && data.name === 'from') {
                    item.data = {
                        type: 'Percentage',
                        loc: data.loc,
                        value: '0'
                    };
                }
            });
        });
    });
};

var resolveKeyword$3 = libExports.keyword;
var compressKeyframes = keyframes;

var Atrule = function(node) {
    // compress @keyframe selectors
    if (resolveKeyword$3(node.name).basename === 'keyframes') {
        compressKeyframes(node);
    }
};

// Can unquote attribute detection
// Adopted implementation of Mathias Bynens
// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
    if (value === '' || value === '-') {
        return;
    }

    // Escapes are valid, so replace them with a valid non-empty string
    value = value.replace(escapesRx, 'a');

    return !blockUnquoteRx.test(value);
}

var AttributeSelector = function(node) {
    var attrValue = node.value;

    if (!attrValue || attrValue.type !== 'String') {
        return;
    }

    var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');
    if (canUnquote(unquotedValue)) {
        node.value = {
            type: 'Identifier',
            loc: attrValue.loc,
            name: unquotedValue
        };
    }
};

var font = function compressFont(node) {
    var list = node.children;

    list.eachRight(function(node, item) {
        if (node.type === 'Identifier') {
            if (node.name === 'bold') {
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '700'
                };
            } else if (node.name === 'normal') {
                var prev = item.prev;

                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
                    this.remove(prev);
                }

                this.remove(item);
            } else if (node.name === 'medium') {
                var next = item.next;

                if (!next || next.data.type !== 'Operator') {
                    this.remove(item);
                }
            }
        }
    });

    // remove redundant spaces
    list.each(function(node, item) {
        if (node.type === 'WhiteSpace') {
            if (!item.prev || !item.next || item.next.data.type === 'WhiteSpace') {
                this.remove(item);
            }
        }
    });

    if (list.isEmpty()) {
        list.insert(list.createItem({
            type: 'Identifier',
            name: 'normal'
        }));
    }
};

var fontWeight = function compressFontWeight(node) {
    var value = node.children.head.data;

    if (value.type === 'Identifier') {
        switch (value.name) {
            case 'normal':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '400'
                };
                break;
            case 'bold':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '700'
                };
                break;
        }
    }
};

var List$5 = libExports.List;

var background = function compressBackground(node) {
    function lastType() {
        if (buffer.length) {
            return buffer[buffer.length - 1].type;
        }
    }

    function flush() {
        if (lastType() === 'WhiteSpace') {
            buffer.pop();
        }

        if (!buffer.length) {
            buffer.unshift(
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                },
                {
                    type: 'WhiteSpace',
                    value: ' '
                },
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                }
            );
        }

        newValue.push.apply(newValue, buffer);

        buffer = [];
    }

    var newValue = [];
    var buffer = [];

    node.children.each(function(node) {
        if (node.type === 'Operator' && node.value === ',') {
            flush();
            newValue.push(node);
            return;
        }

        // remove defaults
        if (node.type === 'Identifier') {
            if (node.name === 'transparent' ||
                node.name === 'none' ||
                node.name === 'repeat' ||
                node.name === 'scroll') {
                return;
            }
        }

        // don't add redundant spaces
        if (node.type === 'WhiteSpace' && (!buffer.length || lastType() === 'WhiteSpace')) {
            return;
        }

        buffer.push(node);
    });

    flush();
    node.children = new List$5().fromArray(newValue);
};

function removeItemAndRedundantWhiteSpace(list, item) {
    var prev = item.prev;
    var next = item.next;

    if (next !== null) {
        if (next.data.type === 'WhiteSpace' && (prev === null || prev.data.type === 'WhiteSpace')) {
            list.remove(next);
        }
    } else if (prev !== null && prev.data.type === 'WhiteSpace') {
        list.remove(prev);
    }

    list.remove(item);
}

var border = function compressBorder(node) {
    node.children.each(function(node, item, list) {
        if (node.type === 'Identifier' && node.name.toLowerCase() === 'none') {
            if (list.head === list.tail) {
                // replace `none` for zero when `none` is a single term
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '0'
                };
            } else {
                removeItemAndRedundantWhiteSpace(list, item);
            }
        }
    });
};

var resolveName = libExports.property;
var handlers$1 = {
    'font': font,
    'font-weight': fontWeight,
    'background': background,
    'border': border,
    'outline': border
};

var Value = function compressValue(node) {
    if (!this.declaration) {
        return;
    }

    var property = resolveName(this.declaration.property);

    if (handlers$1.hasOwnProperty(property.basename)) {
        handlers$1[property.basename](node);
    }
};

var _NumberExports = {};
var _Number = {
  get exports(){ return _NumberExports; },
  set exports(v){ _NumberExports = v; },
};

var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var unsafeToRemovePlusSignAfter = {
    Dimension: true,
    Hash: true,
    Identifier: true,
    Number: true,
    Raw: true,
    UnicodeRange: true
};

function packNumber$3(value, item) {
    // omit plus sign only if no prev or prev is safe type
    var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type)
        ? KEEP_PLUSSIGN
        : OMIT_PLUSSIGN;

    // 100 -> '100'
    // 00100 -> '100'
    // +100 -> '100' (only when safe, e.g. omitting plus sign for 1px+1px leads to single dimension instead of two)
    // -100 -> '-100'
    // 0.123 -> '.123'
    // 0.12300 -> '.123'
    // 0.0 -> ''
    // 0 -> ''
    // -0 -> '-'
    value = String(value).replace(regexp, '$1$2$3');

    if (value === '' || value === '-') {
        value = '0';
    }

    return value;
}

_Number.exports = function(node, item) {
    node.value = packNumber$3(node.value, item);
};
_NumberExports.pack = packNumber$3;

var packNumber$2 = _NumberExports.pack;
var MATH_FUNCTIONS = {
    'calc': true,
    'min': true,
    'max': true,
    'clamp': true
};
var LENGTH_UNIT = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var Dimension = function compressDimension(node, item) {
    var value = packNumber$2(node.value, item);

    node.value = value;

    if (value === '0' && this.declaration !== null && this.atrulePrelude === null) {
        var unit = node.unit.toLowerCase();

        // only length values can be compressed
        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
            return;
        }

        // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
        // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
        if (this.declaration.property === '-ms-flex' ||
            this.declaration.property === 'flex') {
            return;
        }

        // issue #222: don't remove units inside calc
        if (this.function && MATH_FUNCTIONS.hasOwnProperty(this.function.name)) {
            return;
        }

        item.data = {
            type: 'Number',
            loc: node.loc,
            value: value
        };
    }
};

var lexer$1 = libExports.lexer;
var packNumber$1 = _NumberExports.pack;
var blacklist = new Set([
    // see https://github.com/jakubpawlowicz/clean-css/issues/957
    'width',
    'min-width',
    'max-width',
    'height',
    'min-height',
    'max-height',

    // issue #410: Donâ€™t remove units in flex-basis value for (-ms-)flex shorthand
    // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
    // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
    'flex',
    '-ms-flex'
]);

var Percentage = function compressPercentage(node, item) {
    node.value = packNumber$1(node.value, item);

    if (node.value === '0' && this.declaration && !blacklist.has(this.declaration.property)) {
        // try to convert a number
        item.data = {
            type: 'Number',
            loc: node.loc,
            value: node.value
        };

        // that's ok only when new value matches on length
        if (!lexer$1.matchDeclaration(this.declaration).isType(item.data, 'length')) {
            // otherwise rollback changes
            item.data = node;
        }
    }
};

var _String = function(node) {
    var value = node.value;

    // remove escaped newlines, i.e.
    // .a { content: "foo\
    // bar"}
    // ->
    // .a { content: "foobar" }
    value = value.replace(/\\(\r\n|\r|\n|\f)/g, '');

    node.value = value;
};

var UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
var ESCAPE = '(' + UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
var NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
var SAFE_URL = new RegExp('^(' + ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + NONPRINTABLE + '])*$', 'i');

var Url = function(node) {
    var value = node.value;

    if (value.type !== 'String') {
        return;
    }

    var quote = value.value[0];
    var url = value.value.substr(1, value.value.length - 2);

    // convert `\\` to `/`
    url = url.replace(/\\\\/g, '/');

    // remove quotes when safe
    // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram
    if (SAFE_URL.test(url)) {
        node.value = {
            type: 'Raw',
            loc: node.value.loc,
            value: url
        };
    } else {
        // use double quotes if string has no double quotes
        // otherwise use original quotes
        // TODO: make better quote type selection
        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
    }
};

var lexer = libExports.lexer;
var packNumber = _NumberExports.pack;

// http://www.w3.org/TR/css3-color/#svg-color
var NAME_TO_HEX = {
    'aliceblue': 'f0f8ff',
    'antiquewhite': 'faebd7',
    'aqua': '0ff',
    'aquamarine': '7fffd4',
    'azure': 'f0ffff',
    'beige': 'f5f5dc',
    'bisque': 'ffe4c4',
    'black': '000',
    'blanchedalmond': 'ffebcd',
    'blue': '00f',
    'blueviolet': '8a2be2',
    'brown': 'a52a2a',
    'burlywood': 'deb887',
    'cadetblue': '5f9ea0',
    'chartreuse': '7fff00',
    'chocolate': 'd2691e',
    'coral': 'ff7f50',
    'cornflowerblue': '6495ed',
    'cornsilk': 'fff8dc',
    'crimson': 'dc143c',
    'cyan': '0ff',
    'darkblue': '00008b',
    'darkcyan': '008b8b',
    'darkgoldenrod': 'b8860b',
    'darkgray': 'a9a9a9',
    'darkgrey': 'a9a9a9',
    'darkgreen': '006400',
    'darkkhaki': 'bdb76b',
    'darkmagenta': '8b008b',
    'darkolivegreen': '556b2f',
    'darkorange': 'ff8c00',
    'darkorchid': '9932cc',
    'darkred': '8b0000',
    'darksalmon': 'e9967a',
    'darkseagreen': '8fbc8f',
    'darkslateblue': '483d8b',
    'darkslategray': '2f4f4f',
    'darkslategrey': '2f4f4f',
    'darkturquoise': '00ced1',
    'darkviolet': '9400d3',
    'deeppink': 'ff1493',
    'deepskyblue': '00bfff',
    'dimgray': '696969',
    'dimgrey': '696969',
    'dodgerblue': '1e90ff',
    'firebrick': 'b22222',
    'floralwhite': 'fffaf0',
    'forestgreen': '228b22',
    'fuchsia': 'f0f',
    'gainsboro': 'dcdcdc',
    'ghostwhite': 'f8f8ff',
    'gold': 'ffd700',
    'goldenrod': 'daa520',
    'gray': '808080',
    'grey': '808080',
    'green': '008000',
    'greenyellow': 'adff2f',
    'honeydew': 'f0fff0',
    'hotpink': 'ff69b4',
    'indianred': 'cd5c5c',
    'indigo': '4b0082',
    'ivory': 'fffff0',
    'khaki': 'f0e68c',
    'lavender': 'e6e6fa',
    'lavenderblush': 'fff0f5',
    'lawngreen': '7cfc00',
    'lemonchiffon': 'fffacd',
    'lightblue': 'add8e6',
    'lightcoral': 'f08080',
    'lightcyan': 'e0ffff',
    'lightgoldenrodyellow': 'fafad2',
    'lightgray': 'd3d3d3',
    'lightgrey': 'd3d3d3',
    'lightgreen': '90ee90',
    'lightpink': 'ffb6c1',
    'lightsalmon': 'ffa07a',
    'lightseagreen': '20b2aa',
    'lightskyblue': '87cefa',
    'lightslategray': '789',
    'lightslategrey': '789',
    'lightsteelblue': 'b0c4de',
    'lightyellow': 'ffffe0',
    'lime': '0f0',
    'limegreen': '32cd32',
    'linen': 'faf0e6',
    'magenta': 'f0f',
    'maroon': '800000',
    'mediumaquamarine': '66cdaa',
    'mediumblue': '0000cd',
    'mediumorchid': 'ba55d3',
    'mediumpurple': '9370db',
    'mediumseagreen': '3cb371',
    'mediumslateblue': '7b68ee',
    'mediumspringgreen': '00fa9a',
    'mediumturquoise': '48d1cc',
    'mediumvioletred': 'c71585',
    'midnightblue': '191970',
    'mintcream': 'f5fffa',
    'mistyrose': 'ffe4e1',
    'moccasin': 'ffe4b5',
    'navajowhite': 'ffdead',
    'navy': '000080',
    'oldlace': 'fdf5e6',
    'olive': '808000',
    'olivedrab': '6b8e23',
    'orange': 'ffa500',
    'orangered': 'ff4500',
    'orchid': 'da70d6',
    'palegoldenrod': 'eee8aa',
    'palegreen': '98fb98',
    'paleturquoise': 'afeeee',
    'palevioletred': 'db7093',
    'papayawhip': 'ffefd5',
    'peachpuff': 'ffdab9',
    'peru': 'cd853f',
    'pink': 'ffc0cb',
    'plum': 'dda0dd',
    'powderblue': 'b0e0e6',
    'purple': '800080',
    'rebeccapurple': '639',
    'red': 'f00',
    'rosybrown': 'bc8f8f',
    'royalblue': '4169e1',
    'saddlebrown': '8b4513',
    'salmon': 'fa8072',
    'sandybrown': 'f4a460',
    'seagreen': '2e8b57',
    'seashell': 'fff5ee',
    'sienna': 'a0522d',
    'silver': 'c0c0c0',
    'skyblue': '87ceeb',
    'slateblue': '6a5acd',
    'slategray': '708090',
    'slategrey': '708090',
    'snow': 'fffafa',
    'springgreen': '00ff7f',
    'steelblue': '4682b4',
    'tan': 'd2b48c',
    'teal': '008080',
    'thistle': 'd8bfd8',
    'tomato': 'ff6347',
    'turquoise': '40e0d0',
    'violet': 'ee82ee',
    'wheat': 'f5deb3',
    'white': 'fff',
    'whitesmoke': 'f5f5f5',
    'yellow': 'ff0',
    'yellowgreen': '9acd32'
};

var HEX_TO_NAME = {
    '800000': 'maroon',
    '800080': 'purple',
    '808000': 'olive',
    '808080': 'gray',
    '00ffff': 'cyan',
    'f0ffff': 'azure',
    'f5f5dc': 'beige',
    'ffe4c4': 'bisque',
    '000000': 'black',
    '0000ff': 'blue',
    'a52a2a': 'brown',
    'ff7f50': 'coral',
    'ffd700': 'gold',
    '008000': 'green',
    '4b0082': 'indigo',
    'fffff0': 'ivory',
    'f0e68c': 'khaki',
    '00ff00': 'lime',
    'faf0e6': 'linen',
    '000080': 'navy',
    'ffa500': 'orange',
    'da70d6': 'orchid',
    'cd853f': 'peru',
    'ffc0cb': 'pink',
    'dda0dd': 'plum',
    'f00': 'red',
    'ff0000': 'red',
    'fa8072': 'salmon',
    'a0522d': 'sienna',
    'c0c0c0': 'silver',
    'fffafa': 'snow',
    'd2b48c': 'tan',
    '008080': 'teal',
    'ff6347': 'tomato',
    'ee82ee': 'violet',
    'f5deb3': 'wheat',
    'ffffff': 'white',
    'ffff00': 'yellow'
};

function hueToRgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}

function hslToRgb(h, s, l, a) {
    var r;
    var g;
    var b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        a
    ];
}

function toHex(value) {
    value = value.toString(16);
    return value.length === 1 ? '0' + value : value;
}

function parseFunctionArgs(functionArgs, count, rgb) {
    var cursor = functionArgs.head;
    var args = [];
    var wasValue = false;

    while (cursor !== null) {
        var node = cursor.data;
        var type = node.type;

        switch (type) {
            case 'Number':
            case 'Percentage':
                if (wasValue) {
                    return;
                }

                wasValue = true;
                args.push({
                    type: type,
                    value: Number(node.value)
                });
                break;

            case 'Operator':
                if (node.value === ',') {
                    if (!wasValue) {
                        return;
                    }
                    wasValue = false;
                } else if (wasValue || node.value !== '+') {
                    return;
                }
                break;

            default:
                // something we couldn't understand
                return;
        }

        cursor = cursor.next;
    }

    if (args.length !== count) {
        // invalid arguments count
        // TODO: remove those tokens
        return;
    }

    if (args.length === 4) {
        if (args[3].type !== 'Number') {
            // 4th argument should be a number
            // TODO: remove those tokens
            return;
        }

        args[3].type = 'Alpha';
    }

    if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            // invalid color, numbers and percentage shouldn't be mixed
            // TODO: remove those tokens
            return;
        }
    } else {
        if (args[0].type !== 'Number' ||
            args[1].type !== 'Percentage' ||
            args[2].type !== 'Percentage') {
            // invalid color, for hsl values should be: number, percentage, percentage
            // TODO: remove those tokens
            return;
        }

        args[0].type = 'Angle';
    }

    return args.map(function(arg) {
        var value = Math.max(0, arg.value);

        switch (arg.type) {
            case 'Number':
                // fit value to [0..255] range
                value = Math.min(value, 255);
                break;

            case 'Percentage':
                // convert 0..100% to value in [0..255] range
                value = Math.min(value, 100) / 100;

                if (!rgb) {
                    return value;
                }

                value = 255 * value;
                break;

            case 'Angle':
                // fit value to (-360..360) range
                return (((value % 360) + 360) % 360) / 360;

            case 'Alpha':
                // fit value to [0..1] range
                return Math.min(value, 1);
        }

        return Math.round(value);
    });
}

function compressFunction(node, item, list) {
    var functionName = node.name;
    var args;

    if (functionName === 'rgba' || functionName === 'hsla') {
        args = parseFunctionArgs(node.children, 4, functionName === 'rgba');

        if (!args) {
            // something went wrong
            return;
        }

        if (functionName === 'hsla') {
            args = hslToRgb.apply(null, args);
            node.name = 'rgba';
        }

        if (args[3] === 0) {
            // try to replace `rgba(x, x, x, 0)` to `transparent`
            // always replace `rgba(0, 0, 0, 0)` to `transparent`
            // otherwise avoid replacement in gradients since it may break color transition
            // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
            var scopeFunctionName = this.function && this.function.name;
            if ((args[0] === 0 && args[1] === 0 && args[2] === 0) ||
                !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {

                item.data = {
                    type: 'Identifier',
                    loc: node.loc,
                    name: 'transparent'
                };

                return;
            }
        }

        if (args[3] !== 1) {
            // replace argument values for normalized/interpolated
            node.children.each(function(node, item, list) {
                if (node.type === 'Operator') {
                    if (node.value !== ',') {
                        list.remove(item);
                    }
                    return;
                }

                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: packNumber(args.shift(), null)
                };
            });

            return;
        }

        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
        functionName = 'rgb';
    }

    if (functionName === 'hsl') {
        args = args || parseFunctionArgs(node.children, 3, false);

        if (!args) {
            // something went wrong
            return;
        }

        // convert to rgb
        args = hslToRgb.apply(null, args);
        functionName = 'rgb';
    }

    if (functionName === 'rgb') {
        args = args || parseFunctionArgs(node.children, 3, true);

        if (!args) {
            // something went wrong
            return;
        }

        // check if color is not at the end and not followed by space
        var next = item.next;
        if (next && next.data.type !== 'WhiteSpace') {
            list.insert(list.createItem({
                type: 'WhiteSpace',
                value: ' '
            }), next);
        }

        item.data = {
            type: 'Hash',
            loc: node.loc,
            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };

        compressHex(item.data, item);
    }
}

function compressIdent(node, item) {
    if (this.declaration === null) {
        return;
    }

    var color = node.name.toLowerCase();

    if (NAME_TO_HEX.hasOwnProperty(color) &&
        lexer.matchDeclaration(this.declaration).isType(node, 'color')) {
        var hex = NAME_TO_HEX[color];

        if (hex.length + 1 <= color.length) {
            // replace for shorter hex value
            item.data = {
                type: 'Hash',
                loc: node.loc,
                value: hex
            };
        } else {
            // special case for consistent colors
            if (color === 'grey') {
                color = 'gray';
            }

            // just replace value for lower cased name
            node.name = color;
        }
    }
}

function compressHex(node, item) {
    var color = node.value.toLowerCase();

    // #112233 -> #123
    if (color.length === 6 &&
        color[0] === color[1] &&
        color[2] === color[3] &&
        color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
    }

    if (HEX_TO_NAME[color]) {
        item.data = {
            type: 'Identifier',
            loc: node.loc,
            name: HEX_TO_NAME[color]
        };
    } else {
        node.value = color;
    }
}

var color = {
    compressFunction: compressFunction,
    compressIdent: compressIdent,
    compressHex: compressHex
};

var walk$9 = libExports.walk;
var handlers = {
    Atrule: Atrule,
    AttributeSelector: AttributeSelector,
    Value: Value,
    Dimension: Dimension,
    Percentage: Percentage,
    Number: _NumberExports,
    String: _String,
    Url: Url,
    Hash: color.compressHex,
    Identifier: color.compressIdent,
    Function: color.compressFunction
};

var replace$1 = function(ast) {
    walk$9(ast, {
        leave: function(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
                handlers[node.type].call(this, node, item, list);
            }
        }
    });
};

var generate$5 = libExports.generate;

function Index() {
    this.seed = 0;
    this.map = Object.create(null);
}

Index.prototype.resolve = function(str) {
    var index = this.map[str];

    if (!index) {
        index = ++this.seed;
        this.map[str] = index;
    }

    return index;
};

var createDeclarationIndexer$1 = function createDeclarationIndexer() {
    var ids = new Index();

    return function markDeclaration(node) {
        var id = generate$5(node);

        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;

        return node;
    };
};

var generate$4 = libExports.generate;
var specificity$1 = specificity$4;

var nonFreezePseudoElements = {
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};
var nonFreezePseudoClasses = {
    'link': true,
    'visited': true,
    'hover': true,
    'active': true,
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};

var processSelector$1 = function freeze(node, usageData) {
    var pseudos = Object.create(null);
    var hasPseudo = false;

    node.prelude.children.each(function(simpleSelector) {
        var tagName = '*';
        var scope = 0;

        simpleSelector.children.each(function(node) {
            switch (node.type) {
                case 'ClassSelector':
                    if (usageData && usageData.scopes) {
                        var classScope = usageData.scopes[node.name] || 0;

                        if (scope !== 0 && classScope !== scope) {
                            throw new Error('Selector can\'t has classes from different scopes: ' + generate$4(simpleSelector));
                        }

                        scope = classScope;
                    }
                    break;

                case 'PseudoClassSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                        pseudos[':' + name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'PseudoElementSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                        pseudos['::' + name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'TypeSelector':
                    tagName = node.name.toLowerCase();
                    break;

                case 'AttributeSelector':
                    if (node.flags) {
                        pseudos['[' + node.flags.toLowerCase() + ']'] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'WhiteSpace':
                case 'Combinator':
                    tagName = '*';
                    break;
            }
        });

        simpleSelector.compareMarker = specificity$1(simpleSelector).toString();
        simpleSelector.id = null; // pre-init property to avoid multiple hidden class
        simpleSelector.id = generate$4(simpleSelector);

        if (scope) {
            simpleSelector.compareMarker += ':' + scope;
        }

        if (tagName !== '*') {
            simpleSelector.compareMarker += ',' + tagName;
        }
    });

    // add property to all rule nodes to avoid multiple hidden class
    node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(',');
};

var resolveKeyword$2 = libExports.keyword;
var walk$8 = libExports.walk;
var generate$3 = libExports.generate;
var createDeclarationIndexer = createDeclarationIndexer$1;
var processSelector = processSelector$1;

var prepare$1 = function prepare(ast, options) {
    var markDeclaration = createDeclarationIndexer();

    walk$8(ast, {
        visit: 'Rule',
        enter: function processRule(node) {
            node.block.children.each(markDeclaration);
            processSelector(node, options.usage);
        }
    });

    walk$8(ast, {
        visit: 'Atrule',
        enter: function(node) {
            if (node.prelude) {
                node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate
                node.prelude.id = generate$3(node.prelude);
            }

            // compare keyframe selectors by its values
            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
            if (resolveKeyword$2(node.name).basename === 'keyframes') {
                node.block.avoidRulesMerge = true;  /* probably we don't need to prevent those merges for @keyframes
                                                       TODO: need to be checked */
                node.block.children.each(function(rule) {
                    rule.prelude.children.each(function(simpleselector) {
                        simpleselector.compareMarker = simpleselector.id;
                    });
                });
            }
        }
    });

    return {
        declaration: markDeclaration
    };
};

var List$4 = libExports.List;
var resolveKeyword$1 = libExports.keyword;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var walk$7 = libExports.walk;

function addRuleToMap(map, item, list, single) {
    var node = item.data;
    var name = resolveKeyword$1(node.name).basename;
    var id = node.name.toLowerCase() + '/' + (node.prelude ? node.prelude.id : null);

    if (!hasOwnProperty$2.call(map, name)) {
        map[name] = Object.create(null);
    }

    if (single) {
        delete map[name][id];
    }

    if (!hasOwnProperty$2.call(map[name], id)) {
        map[name][id] = new List$4();
    }

    map[name][id].append(list.remove(item));
}

function relocateAtrules(ast, options) {
    var collected = Object.create(null);
    var topInjectPoint = null;

    ast.children.each(function(node, item, list) {
        if (node.type === 'Atrule') {
            var name = resolveKeyword$1(node.name).basename;

            switch (name) {
                case 'keyframes':
                    addRuleToMap(collected, item, list, true);
                    return;

                case 'media':
                    if (options.forceMediaMerge) {
                        addRuleToMap(collected, item, list, false);
                        return;
                    }
                    break;
            }

            if (topInjectPoint === null &&
                name !== 'charset' &&
                name !== 'import') {
                topInjectPoint = item;
            }
        } else {
            if (topInjectPoint === null) {
                topInjectPoint = item;
            }
        }
    });

    for (var atrule in collected) {
        for (var id in collected[atrule]) {
            ast.children.insertList(
                collected[atrule][id],
                atrule === 'media' ? null : topInjectPoint
            );
        }
    }
}
function isMediaRule(node) {
    return node.type === 'Atrule' && node.name === 'media';
}

function processAtrule(node, item, list) {
    if (!isMediaRule(node)) {
        return;
    }

    var prev = item.prev && item.prev.data;

    if (!prev || !isMediaRule(prev)) {
        return;
    }

    // merge @media with same query
    if (node.prelude &&
        prev.prelude &&
        node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);

        // TODO: use it when we can refer to several points in source
        // prev.loc = {
        //     primary: prev.loc,
        //     merged: node.loc
        // };
    }
}

var _1MergeAtrule = function rejoinAtrule(ast, options) {
    relocateAtrules(ast, options);

    walk$7(ast, {
        visit: 'Atrule',
        reverse: true,
        enter: processAtrule
    });
};

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function isEqualSelectors(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function isEqualDeclarations(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function compareDeclarations(declarations1, declarations2) {
    var result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
    };

    var fingerprints = Object.create(null);
    var declarations2hash = Object.create(null);

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        declarations2hash[cursor.data.id] = true;
    }

    for (var cursor = declarations1.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.important;
        }

        if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
        } else {
            result.ne1.push(data);
        }
    }

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (declarations2hash[data.id]) {
            // when declarations1 has an overriding declaration, this is not a difference
            // unless no !important is used on prev and !important is used on the following
            if (!hasOwnProperty$1.call(fingerprints, data.fingerprint) ||
                (!fingerprints[data.fingerprint] && data.important)) {
                result.ne2.push(data);
            }

            result.ne2overrided.push(data);
        }
    }

    return result;
}

function addSelectors(dest, source) {
    source.each(function(sourceData) {
        var newStr = sourceData.id;
        var cursor = dest.head;

        while (cursor) {
            var nextStr = cursor.data.id;

            if (nextStr === newStr) {
                return;
            }

            if (nextStr > newStr) {
                break;
            }

            cursor = cursor.next;
        }

        dest.insert(dest.createItem(sourceData), cursor);
    });

    return dest;
}

// check if simpleselectors has no equal specificity and element selector
function hasSimilarSelectors(selectors1, selectors2) {
    var cursor1 = selectors1.head;

    while (cursor1 !== null) {
        var cursor2 = selectors2.head;

        while (cursor2 !== null) {
            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
                return true;
            }

            cursor2 = cursor2.next;
        }

        cursor1 = cursor1.next;
    }

    return false;
}

// test node can't to be skipped
function unsafeToSkipNode(node) {
    switch (node.type) {
        case 'Rule':
            // unsafe skip ruleset with selector similarities
            return hasSimilarSelectors(node.prelude.children, this);

        case 'Atrule':
            // can skip at-rules with blocks
            if (node.block) {
                // unsafe skip at-rule if block contains something unsafe to skip
                return node.block.children.some(unsafeToSkipNode, this);
            }
            break;

        case 'Declaration':
            return false;
    }

    // unsafe by default
    return true;
}

var utils$3 = {
    isEqualSelectors: isEqualSelectors,
    isEqualDeclarations: isEqualDeclarations,
    compareDeclarations: compareDeclarations,
    addSelectors: addSelectors,
    hasSimilarSelectors: hasSimilarSelectors,
    unsafeToSkipNode: unsafeToSkipNode
};

var walk$6 = libExports.walk;
var utils$2 = utils$3;

function processRule$5(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;

    list.prevUntil(item.prev, function(prev) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Rule') {
            return utils$2.unsafeToSkipNode.call(selectors, prev);
        }

        var prevSelectors = prev.prelude.children;
        var prevDeclarations = prev.block.children;

        // try to join rulesets with equal pseudo signature
        if (node.pseudoSignature === prev.pseudoSignature) {
            // try to join by selectors
            if (utils$2.isEqualSelectors(prevSelectors, selectors)) {
                prevDeclarations.appendList(declarations);
                list.remove(item);
                return true;
            }

            // try to join by declarations
            if (utils$2.isEqualDeclarations(declarations, prevDeclarations)) {
                utils$2.addSelectors(prevSelectors, selectors);
                list.remove(item);
                return true;
            }
        }

        // go to prev ruleset if has no selector similarities
        return utils$2.hasSimilarSelectors(selectors, prevSelectors);
    });
}

// NOTE: direction should be left to right, since rulesets merge to left
// ruleset. When direction right to left unmerged rulesets may prevent lookup
// TODO: remove initial merge
var _2InitialMergeRuleset = function initialMergeRule(ast) {
    walk$6(ast, {
        visit: 'Rule',
        enter: processRule$5
    });
};

var List$3 = libExports.List;
var walk$5 = libExports.walk;

function processRule$4(node, item, list) {
    var selectors = node.prelude.children;

    // generate new rule sets:
    // .a, .b { color: red; }
    // ->
    // .a { color: red; }
    // .b { color: red; }

    // while there are more than 1 simple selector split for rulesets
    while (selectors.head !== selectors.tail) {
        var newSelectors = new List$3();
        newSelectors.insert(selectors.remove(selectors.head));

        list.insert(list.createItem({
            type: 'Rule',
            loc: node.loc,
            prelude: {
                type: 'SelectorList',
                loc: node.prelude.loc,
                children: newSelectors
            },
            block: {
                type: 'Block',
                loc: node.block.loc,
                children: node.block.children.copy()
            },
            pseudoSignature: node.pseudoSignature
        }), item);
    }
}

var _3DisjoinRuleset = function disjoinRule(ast) {
    walk$5(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule$4
    });
};

var List$2 = libExports.List;
var generate$2 = libExports.generate;
var walk$4 = libExports.walk;

var REPLACE = 1;
var REMOVE = 2;
var TOP = 0;
var RIGHT = 1;
var BOTTOM = 2;
var LEFT = 3;
var SIDES = ['top', 'right', 'bottom', 'left'];
var SIDE = {
    'margin-top': 'top',
    'margin-right': 'right',
    'margin-bottom': 'bottom',
    'margin-left': 'left',

    'padding-top': 'top',
    'padding-right': 'right',
    'padding-bottom': 'bottom',
    'padding-left': 'left',

    'border-top-color': 'top',
    'border-right-color': 'right',
    'border-bottom-color': 'bottom',
    'border-left-color': 'left',
    'border-top-width': 'top',
    'border-right-width': 'right',
    'border-bottom-width': 'bottom',
    'border-left-width': 'left',
    'border-top-style': 'top',
    'border-right-style': 'right',
    'border-bottom-style': 'bottom',
    'border-left-style': 'left'
};
var MAIN_PROPERTY = {
    'margin': 'margin',
    'margin-top': 'margin',
    'margin-right': 'margin',
    'margin-bottom': 'margin',
    'margin-left': 'margin',

    'padding': 'padding',
    'padding-top': 'padding',
    'padding-right': 'padding',
    'padding-bottom': 'padding',
    'padding-left': 'padding',

    'border-color': 'border-color',
    'border-top-color': 'border-color',
    'border-right-color': 'border-color',
    'border-bottom-color': 'border-color',
    'border-left-color': 'border-color',
    'border-width': 'border-width',
    'border-top-width': 'border-width',
    'border-right-width': 'border-width',
    'border-bottom-width': 'border-width',
    'border-left-width': 'border-width',
    'border-style': 'border-style',
    'border-top-style': 'border-style',
    'border-right-style': 'border-style',
    'border-bottom-style': 'border-style',
    'border-left-style': 'border-style'
};

function TRBL(name) {
    this.name = name;
    this.loc = null;
    this.iehack = undefined;
    this.sides = {
        'top': null,
        'right': null,
        'bottom': null,
        'left': null
    };
}

TRBL.prototype.getValueSequence = function(declaration, count) {
    var values = [];
    var iehack = '';
    var hasBadValues = declaration.value.type !== 'Value' || declaration.value.children.some(function(child) {
        var special = false;

        switch (child.type) {
            case 'Identifier':
                switch (child.name) {
                    case '\\0':
                    case '\\9':
                        iehack = child.name;
                        return;

                    case 'inherit':
                    case 'initial':
                    case 'unset':
                    case 'revert':
                        special = child.name;
                        break;
                }
                break;

            case 'Dimension':
                switch (child.unit) {
                    // is not supported until IE11
                    case 'rem':

                    // v* units is too buggy across browsers and better
                    // don't merge values with those units
                    case 'vw':
                    case 'vh':
                    case 'vmin':
                    case 'vmax':
                    case 'vm': // IE9 supporting "vm" instead of "vmin".
                        special = child.unit;
                        break;
                }
                break;

            case 'Hash': // color
            case 'Number':
            case 'Percentage':
                break;

            case 'Function':
                if (child.name === 'var') {
                    return true;
                }

                special = child.name;
                break;

            case 'WhiteSpace':
                return false; // ignore space

            default:
                return true;  // bad value
        }

        values.push({
            node: child,
            special: special,
            important: declaration.important
        });
    });

    if (hasBadValues || values.length > count) {
        return false;
    }

    if (typeof this.iehack === 'string' && this.iehack !== iehack) {
        return false;
    }

    this.iehack = iehack; // move outside

    return values;
};

TRBL.prototype.canOverride = function(side, value) {
    var currentValue = this.sides[side];

    return !currentValue || (value.important && !currentValue.important);
};

TRBL.prototype.add = function(name, declaration) {
    function attemptToAdd() {
        var sides = this.sides;
        var side = SIDE[name];

        if (side) {
            if (side in sides === false) {
                return false;
            }

            var values = this.getValueSequence(declaration, 1);

            if (!values || !values.length) {
                return false;
            }

            // can mix only if specials are equal
            for (var key in sides) {
                if (sides[key] !== null && sides[key].special !== values[0].special) {
                    return false;
                }
            }

            if (!this.canOverride(side, values[0])) {
                return true;
            }

            sides[side] = values[0];
            return true;
        } else if (name === this.name) {
            var values = this.getValueSequence(declaration, 4);

            if (!values || !values.length) {
                return false;
            }

            switch (values.length) {
                case 1:
                    values[RIGHT] = values[TOP];
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[TOP];
                    break;

                case 2:
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[RIGHT];
                    break;

                case 3:
                    values[LEFT] = values[RIGHT];
                    break;
            }

            // can mix only if specials are equal
            for (var i = 0; i < 4; i++) {
                for (var key in sides) {
                    if (sides[key] !== null && sides[key].special !== values[i].special) {
                        return false;
                    }
                }
            }

            for (var i = 0; i < 4; i++) {
                if (this.canOverride(SIDES[i], values[i])) {
                    sides[SIDES[i]] = values[i];
                }
            }

            return true;
        }
    }

    if (!attemptToAdd.call(this)) {
        return false;
    }

    // TODO: use it when we can refer to several points in source
    // if (this.loc) {
    //     this.loc = {
    //         primary: this.loc,
    //         merged: declaration.loc
    //     };
    // } else {
    //     this.loc = declaration.loc;
    // }
    if (!this.loc) {
        this.loc = declaration.loc;
    }

    return true;
};

TRBL.prototype.isOkToMinimize = function() {
    var top = this.sides.top;
    var right = this.sides.right;
    var bottom = this.sides.bottom;
    var left = this.sides.left;

    if (top && right && bottom && left) {
        var important =
            top.important +
            right.important +
            bottom.important +
            left.important;

        return important === 0 || important === 4;
    }

    return false;
};

TRBL.prototype.getValue = function() {
    var result = new List$2();
    var sides = this.sides;
    var values = [
        sides.top,
        sides.right,
        sides.bottom,
        sides.left
    ];
    var stringValues = [
        generate$2(sides.top.node),
        generate$2(sides.right.node),
        generate$2(sides.bottom.node),
        generate$2(sides.left.node)
    ];

    if (stringValues[LEFT] === stringValues[RIGHT]) {
        values.pop();
        if (stringValues[BOTTOM] === stringValues[TOP]) {
            values.pop();
            if (stringValues[RIGHT] === stringValues[TOP]) {
                values.pop();
            }
        }
    }

    for (var i = 0; i < values.length; i++) {
        if (i) {
            result.appendData({ type: 'WhiteSpace', value: ' ' });
        }

        result.appendData(values[i].node);
    }

    if (this.iehack) {
        result.appendData({ type: 'WhiteSpace', value: ' ' });
        result.appendData({
            type: 'Identifier',
            loc: null,
            name: this.iehack
        });
    }

    return {
        type: 'Value',
        loc: null,
        children: result
    };
};

TRBL.prototype.getDeclaration = function() {
    return {
        type: 'Declaration',
        loc: this.loc,
        important: this.sides.top.important,
        property: this.name,
        value: this.getValue()
    };
};

function processRule$3(rule, shorts, shortDeclarations, lastShortSelector) {
    var declarations = rule.block.children;
    var selector = rule.prelude.children.first().id;

    rule.block.children.eachRight(function(declaration, item) {
        var property = declaration.property;

        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
        }

        var key = MAIN_PROPERTY[property];
        var shorthand;
        var operation;

        if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
                operation = REMOVE;
                shorthand = shorts[key];
            }
        }

        if (!shorthand || !shorthand.add(property, declaration)) {
            operation = REPLACE;
            shorthand = new TRBL(key);

            // if can't parse value ignore it and break shorthand children
            if (!shorthand.add(property, declaration)) {
                lastShortSelector = null;
                return;
            }
        }

        shorts[key] = shorthand;
        shortDeclarations.push({
            operation: operation,
            block: declarations,
            item: item,
            shorthand: shorthand
        });

        lastShortSelector = selector;
    });

    return lastShortSelector;
}

function processShorthands(shortDeclarations, markDeclaration) {
    shortDeclarations.forEach(function(item) {
        var shorthand = item.shorthand;

        if (!shorthand.isOkToMinimize()) {
            return;
        }

        if (item.operation === REPLACE) {
            item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
            item.block.remove(item.item);
        }
    });
}

var _4RestructShorthand = function restructBlock(ast, indexer) {
    var stylesheetMap = {};
    var shortDeclarations = [];

    walk$4(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var shorts;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {
                    lastShortSelector: null
                };
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                shorts = ruleMap[ruleId];
            } else {
                shorts = {};
                ruleMap[ruleId] = shorts;
            }

            ruleMap.lastShortSelector = processRule$3.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
    });

    processShorthands(shortDeclarations, indexer.declaration);
};

var resolveProperty = libExports.property;
var resolveKeyword = libExports.keyword;
var walk$3 = libExports.walk;
var generate$1 = libExports.generate;
var fingerprintId = 1;
var dontRestructure = {
    'src': 1 // https://github.com/afelix/csso/issues/50
};

var DONT_MIX_VALUE = {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
    'text-align': /^(start|end|match-parent|justify-all)$/i
};

var SAFE_VALUES = {
    cursor: [
        'auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help',
        'n-resize', 'e-resize', 's-resize', 'w-resize',
        'ne-resize', 'nw-resize', 'se-resize', 'sw-resize',
        'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll',
        'col-resize', 'row-resize'
    ],
    overflow: [
        'hidden', 'visible', 'scroll', 'auto'
    ],
    position: [
        'static', 'relative', 'absolute', 'fixed'
    ]
};

var NEEDLESS_TABLE = {
    'border-width': ['border'],
    'border-style': ['border'],
    'border-color': ['border'],
    'border-top': ['border'],
    'border-right': ['border'],
    'border-bottom': ['border'],
    'border-left': ['border'],
    'border-top-width': ['border-top', 'border-width', 'border'],
    'border-right-width': ['border-right', 'border-width', 'border'],
    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
    'border-left-width': ['border-left', 'border-width', 'border'],
    'border-top-style': ['border-top', 'border-style', 'border'],
    'border-right-style': ['border-right', 'border-style', 'border'],
    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
    'border-left-style': ['border-left', 'border-style', 'border'],
    'border-top-color': ['border-top', 'border-color', 'border'],
    'border-right-color': ['border-right', 'border-color', 'border'],
    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
    'border-left-color': ['border-left', 'border-color', 'border'],
    'margin-top': ['margin'],
    'margin-right': ['margin'],
    'margin-bottom': ['margin'],
    'margin-left': ['margin'],
    'padding-top': ['padding'],
    'padding-right': ['padding'],
    'padding-bottom': ['padding'],
    'padding-left': ['padding'],
    'font-style': ['font'],
    'font-variant': ['font'],
    'font-weight': ['font'],
    'font-size': ['font'],
    'font-family': ['font'],
    'list-style-type': ['list-style'],
    'list-style-position': ['list-style'],
    'list-style-image': ['list-style']
};

function getPropertyFingerprint(propertyName, declaration, fingerprints) {
    var realName = resolveProperty(propertyName).basename;

    if (realName === 'background') {
        return propertyName + ':' + generate$1(declaration.value);
    }

    var declarationId = declaration.id;
    var fingerprint = fingerprints[declarationId];

    if (!fingerprint) {
        switch (declaration.value.type) {
            case 'Value':
                var vendorId = '';
                var iehack = '';
                var special = {};
                var raw = false;

                declaration.value.children.each(function walk(node) {
                    switch (node.type) {
                        case 'Value':
                        case 'Brackets':
                        case 'Parentheses':
                            node.children.each(walk);
                            break;

                        case 'Raw':
                            raw = true;
                            break;

                        case 'Identifier':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (/\\[09]/.test(name)) {
                                iehack = RegExp.lastMatch;
                            }

                            if (SAFE_VALUES.hasOwnProperty(realName)) {
                                if (SAFE_VALUES[realName].indexOf(name) === -1) {
                                    special[name] = true;
                                }
                            } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                                if (DONT_MIX_VALUE[realName].test(name)) {
                                    special[name] = true;
                                }
                            }

                            break;

                        case 'Function':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (name === 'rect') {
                                // there are 2 forms of rect:
                                //   rect(<top>, <right>, <bottom>, <left>) - standart
                                //   rect(<top> <right> <bottom> <left>) â€“ backwards compatible syntax
                                // only the same form values can be merged
                                var hasComma = node.children.some(function(node) {
                                    return node.type === 'Operator' && node.value === ',';
                                });
                                if (!hasComma) {
                                    name = 'rect-backward';
                                }
                            }

                            special[name + '()'] = true;

                            // check nested tokens too
                            node.children.each(walk);

                            break;

                        case 'Dimension':
                            var unit = node.unit;

                            if (/\\[09]/.test(unit)) {
                                iehack = RegExp.lastMatch;
                            }

                            switch (unit) {
                                // is not supported until IE11
                                case 'rem':

                                // v* units is too buggy across browsers and better
                                // don't merge values with those units
                                case 'vw':
                                case 'vh':
                                case 'vmin':
                                case 'vmax':
                                case 'vm': // IE9 supporting "vm" instead of "vmin".
                                    special[unit] = true;
                                    break;
                            }
                            break;
                    }
                });

                fingerprint = raw
                    ? '!' + fingerprintId++
                    : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;
                break;

            case 'Raw':
                fingerprint = '!' + declaration.value.value;
                break;

            default:
                fingerprint = generate$1(declaration.value);
        }

        fingerprints[declarationId] = fingerprint;
    }

    return propertyName + fingerprint;
}

function needless(props, declaration, fingerprints) {
    var property = resolveProperty(declaration.property);

    if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        var table = NEEDLESS_TABLE[property.basename];

        for (var i = 0; i < table.length; i++) {
            var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
            var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

            if (prev && (!declaration.important || prev.item.data.important)) {
                return prev;
            }
        }
    }
}

function processRule$2(rule, item, list, props, fingerprints) {
    var declarations = rule.block.children;

    declarations.eachRight(function(declaration, declarationItem) {
        var property = declaration.property;
        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        var prev = props[fingerprint];

        if (prev && !dontRestructure.hasOwnProperty(property)) {
            if (declaration.important && !prev.item.data.important) {
                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };

                prev.block.remove(prev.item);

                // TODO: use it when we can refer to several points in source
                // declaration.loc = {
                //     primary: declaration.loc,
                //     merged: prev.item.data.loc
                // };
            } else {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            }
        } else {
            var prev = needless(props, declaration, fingerprints);

            if (prev) {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            } else {
                declaration.fingerprint = fingerprint;

                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };
            }
        }
    });

    if (declarations.isEmpty()) {
        list.remove(item);
    }
}

var _6RestructBlock = function restructBlock(ast) {
    var stylesheetMap = {};
    var fingerprints = Object.create(null);

    walk$3(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node, item, list) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var props;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {};
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                props = ruleMap[ruleId];
            } else {
                props = {};
                ruleMap[ruleId] = props;
            }

            processRule$2.call(this, node, item, list, props, fingerprints);
        }
    });
};

var walk$2 = libExports.walk;
var utils$1 = utils$3;

/*
    At this step all rules has single simple selector. We try to join by equal
    declaration blocks to first rule, e.g.

    .a { color: red }
    b { ... }
    .b { color: red }
    ->
    .a, .b { color: red }
    b { ... }
*/

function processRule$1(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;
    var nodeCompareMarker = selectors.first().compareMarker;
    var skippedCompareMarkers = {};

    list.nextUntil(item.next, function(next, nextItem) {
        // skip non-ruleset node if safe
        if (next.type !== 'Rule') {
            return utils$1.unsafeToSkipNode.call(selectors, next);
        }

        if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
        }

        var nextFirstSelector = next.prelude.children.head;
        var nextDeclarations = next.block.children;
        var nextCompareMarker = nextFirstSelector.data.compareMarker;

        // if next ruleset has same marked as one of skipped then stop joining
        if (nextCompareMarker in skippedCompareMarkers) {
            return true;
        }

        // try to join by selectors
        if (selectors.head === selectors.tail) {
            if (selectors.first().id === nextFirstSelector.data.id) {
                declarations.appendList(nextDeclarations);
                list.remove(nextItem);
                return;
            }
        }

        // try to join by properties
        if (utils$1.isEqualDeclarations(declarations, nextDeclarations)) {
            var nextStr = nextFirstSelector.data.id;

            selectors.some(function(data, item) {
                var curStr = data.id;

                if (nextStr < curStr) {
                    selectors.insert(nextFirstSelector, item);
                    return true;
                }

                if (!item.next) {
                    selectors.insert(nextFirstSelector);
                    return true;
                }
            });

            list.remove(nextItem);
            return;
        }

        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
        if (nextCompareMarker === nodeCompareMarker) {
            return true;
        }

        skippedCompareMarkers[nextCompareMarker] = true;
    });
}

var _7MergeRuleset = function mergeRule(ast) {
    walk$2(ast, {
        visit: 'Rule',
        enter: processRule$1
    });
};

var List$1 = libExports.List;
var walk$1 = libExports.walk;
var utils = utils$3;

function calcSelectorLength(list) {
    var length = 0;

    list.each(function(data) {
        length += data.id.length + 1;
    });

    return length - 1;
}

function calcDeclarationsLength(tokens) {
    var length = 0;

    for (var i = 0; i < tokens.length; i++) {
        length += tokens[i].length;
    }

    return (
        length +          // declarations
        tokens.length - 1 // delimeters
    );
}

function processRule(node, item, list) {
    var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
    var selectors = node.prelude.children;
    var block = node.block;
    var disallowDownMarkers = Object.create(null);
    var allowMergeUp = true;
    var allowMergeDown = true;

    list.prevUntil(item.prev, function(prev, prevItem) {
        var prevBlock = prev.block;
        var prevType = prev.type;

        if (prevType !== 'Rule') {
            var unsafe = utils.unsafeToSkipNode.call(selectors, prev);

            if (!unsafe && prevType === 'Atrule' && prevBlock) {
                walk$1(prevBlock, {
                    visit: 'Rule',
                    enter: function(node) {
                        node.prelude.children.each(function(data) {
                            disallowDownMarkers[data.compareMarker] = true;
                        });
                    }
                });
            }

            return unsafe;
        }

        var prevSelectors = prev.prelude.children;

        if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
        }

        allowMergeDown = !prevSelectors.some(function(selector) {
            return selector.compareMarker in disallowDownMarkers;
        });

        // try prev ruleset if simpleselectors has no equal specifity and element selector
        if (!allowMergeDown && !allowMergeUp) {
            return true;
        }

        // try to join by selectors
        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
            prevBlock.children.appendList(block.children);
            list.remove(item);
            return true;
        }

        // try to join by properties
        var diff = utils.compareDeclarations(block.children, prevBlock.children);

        // console.log(diff.eq, diff.ne1, diff.ne2);

        if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
                // equal blocks
                if (allowMergeDown) {
                    utils.addSelectors(selectors, prevSelectors);
                    list.remove(prevItem);
                }

                return true;
            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes
                                              TODO: need to be checked */

                if (diff.ne1.length && !diff.ne2.length) {
                    // prevBlock is subset block
                    var selectorLength = calcSelectorLength(selectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeUp && selectorLength < blockLength) {
                        utils.addSelectors(prevSelectors, selectors);
                        block.children = new List$1().fromArray(diff.ne1);
                    }
                } else if (!diff.ne1.length && diff.ne2.length) {
                    // node is subset of prevBlock
                    var selectorLength = calcSelectorLength(prevSelectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeDown && selectorLength < blockLength) {
                        utils.addSelectors(selectors, prevSelectors);
                        prevBlock.children = new List$1().fromArray(diff.ne2);
                    }
                } else {
                    // diff.ne1.length && diff.ne2.length
                    // extract equal block
                    var newSelector = {
                        type: 'SelectorList',
                        loc: null,
                        children: utils.addSelectors(prevSelectors.copy(), selectors)
                    };
                    var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    // create new ruleset if declarations length greater than
                    // ruleset description overhead
                    if (blockLength >= newBlockLength) {
                        var newItem = list.createItem({
                            type: 'Rule',
                            loc: null,
                            prelude: newSelector,
                            block: {
                                type: 'Block',
                                loc: null,
                                children: new List$1().fromArray(diff.eq)
                            },
                            pseudoSignature: node.pseudoSignature
                        });

                        block.children = new List$1().fromArray(diff.ne1);
                        prevBlock.children = new List$1().fromArray(diff.ne2overrided);

                        if (allowMergeUp) {
                            list.insert(newItem, prevItem);
                        } else {
                            list.insert(newItem, item);
                        }

                        return true;
                    }
                }
            }
        }

        if (allowMergeUp) {
            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
            // await property families to find property interception correctly
            allowMergeUp = !prevSelectors.some(function(prevSelector) {
                return selectors.some(function(selector) {
                    return selector.compareMarker === prevSelector.compareMarker;
                });
            });
        }

        prevSelectors.each(function(data) {
            disallowDownMarkers[data.compareMarker] = true;
        });
    });
}

var _8RestructRuleset = function restructRule(ast) {
    walk$1(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule
    });
};

var prepare = prepare$1;
var mergeAtrule = _1MergeAtrule;
var initialMergeRuleset = _2InitialMergeRuleset;
var disjoinRuleset = _3DisjoinRuleset;
var restructShorthand = _4RestructShorthand;
var restructBlock = _6RestructBlock;
var mergeRuleset = _7MergeRuleset;
var restructRuleset = _8RestructRuleset;

var restructure$1 = function(ast, options) {
    // prepare ast for restructing
    var indexer = prepare(ast, options);
    options.logger('prepare', ast);

    mergeAtrule(ast, options);
    options.logger('mergeAtrule', ast);

    initialMergeRuleset(ast);
    options.logger('initialMergeRuleset', ast);

    disjoinRuleset(ast);
    options.logger('disjoinRuleset', ast);

    restructShorthand(ast, indexer);
    options.logger('restructShorthand', ast);

    restructBlock(ast);
    options.logger('restructBlock', ast);

    mergeRuleset(ast);
    options.logger('mergeRuleset', ast);

    restructRuleset(ast);
    options.logger('restructRuleset', ast);
};

var List = libExports.List;
var clone = libExports.clone;
var usageUtils = usage;
var clean = clean$1;
var replace = replace$1;
var restructure = restructure$1;
var walk = libExports.walk;

function readChunk(children, specialComments) {
    var buffer = new List();
    var nonSpaceTokenInBuffer = false;
    var protectedComment;

    children.nextUntil(children.head, function(node, item, list) {
        if (node.type === 'Comment') {
            if (!specialComments || node.value.charAt(0) !== '!') {
                list.remove(item);
                return;
            }

            if (nonSpaceTokenInBuffer || protectedComment) {
                return true;
            }

            list.remove(item);
            protectedComment = node;
            return;
        }

        if (node.type !== 'WhiteSpace') {
            nonSpaceTokenInBuffer = true;
        }

        buffer.insert(list.remove(item));
    });

    return {
        comment: protectedComment,
        stylesheet: {
            type: 'StyleSheet',
            loc: null,
            children: buffer
        }
    };
}

function compressChunk(ast, firstAtrulesAllowed, num, options) {
    options.logger('Compress block #' + num, null, true);

    var seed = 1;

    if (ast.type === 'StyleSheet') {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
    }

    walk(ast, {
        visit: 'Atrule',
        enter: function markScopes(node) {
            if (node.block !== null) {
                node.block.id = seed++;
            }
        }
    });
    options.logger('init', ast);

    // remove redundant
    clean(ast, options);
    options.logger('clean', ast);

    // replace nodes for shortened forms
    replace(ast);
    options.logger('replace', ast);

    // structure optimisations
    if (options.restructuring) {
        restructure(ast, options);
    }

    return ast;
}

function getCommentsOption(options) {
    var comments = 'comments' in options ? options.comments : 'exclamation';

    if (typeof comments === 'boolean') {
        comments = comments ? 'exclamation' : false;
    } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
        comments = false;
    }

    return comments;
}

function getRestructureOption(options) {
    if ('restructure' in options) {
        return options.restructure;
    }

    return 'restructuring' in options ? options.restructuring : true;
}

function wrapBlock(block) {
    return new List().appendData({
        type: 'Rule',
        loc: null,
        prelude: {
            type: 'SelectorList',
            loc: null,
            children: new List().appendData({
                type: 'Selector',
                loc: null,
                children: new List().appendData({
                    type: 'TypeSelector',
                    loc: null,
                    name: 'x'
                })
            })
        },
        block: block
    });
}

var compress$1 = function compress(ast, options) {
    ast = ast || { type: 'StyleSheet', loc: null, children: new List() };
    options = options || {};

    var compressOptions = {
        logger: typeof options.logger === 'function' ? options.logger : function() {},
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? usageUtils.buildIndex(options.usage) : false
    };
    var specialComments = getCommentsOption(options);
    var firstAtrulesAllowed = true;
    var input;
    var output = new List();
    var chunk;
    var chunkNum = 1;
    var chunkChildren;

    if (options.clone) {
        ast = clone(ast);
    }

    if (ast.type === 'StyleSheet') {
        input = ast.children;
        ast.children = output;
    } else {
        input = wrapBlock(ast);
    }

    do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;

        if (chunk.comment) {
            // add \n before comment if there is another content in output
            if (!output.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }

            output.insert(List.createItem(chunk.comment));

            // add \n after comment if chunk is not empty
            if (!chunkChildren.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }
        }

        if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
            var lastRule = chunkChildren.last();

            if (lastRule.type !== 'Atrule' ||
               (lastRule.name !== 'import' && lastRule.name !== 'charset')) {
                firstAtrulesAllowed = false;
            }
        }

        if (specialComments !== 'exclamation') {
            specialComments = false;
        }

        output.appendList(chunkChildren);
    } while (!input.isEmpty());

    return {
        ast: ast
    };
};

const name = "csso";
const version = "4.2.0";
const description = "CSS minifier with structural optimisations";
const homepage = "https://github.com/css/csso";
const author = "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)";
const maintainers = [
	{
		name: "Roman Dvornov",
		email: "rdvornov@gmail.com",
		"github-username": "lahmatiy"
	}
];
const license = "MIT";
const repository = "css/csso";
const bugs = {
	url: "https://github.com/css/csso/issues"
};
const keywords = [
	"css",
	"compress",
	"minifier",
	"minify",
	"optimise",
	"optimisation",
	"csstree"
];
const main = "./lib/index";
const scripts = {
	test: "mocha --reporter dot",
	lint: "eslint lib test",
	"lint-and-test": "npm run lint && npm test",
	build: "rollup --config && terser dist/csso.js --compress --mangle -o dist/csso.min.js",
	coverage: "nyc npm test",
	coveralls: "nyc report --reporter=text-lcov | coveralls",
	travis: "nyc npm run lint-and-test && npm run coveralls",
	hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
	prepublishOnly: "npm run build"
};
const dependencies = {
	"css-tree": "^1.1.2"
};
const browser = {
	"css-tree": "css-tree/dist/csstree.min.js"
};
const devDependencies = {
	"@rollup/plugin-commonjs": "^11.0.1",
	"@rollup/plugin-json": "^4.0.1",
	"@rollup/plugin-node-resolve": "^7.0.0",
	coveralls: "^3.0.11",
	eslint: "^6.8.0",
	mocha: "^7.1.1",
	nyc: "^15.0.0",
	rollup: "^1.29.0",
	"source-map": "^0.6.1",
	terser: "^4.6.3"
};
const engines = {
	node: ">=8.0.0"
};
const files = [
	"dist",
	"lib"
];
const require$$2 = {
	name: name,
	version: version,
	description: description,
	homepage: homepage,
	author: author,
	maintainers: maintainers,
	license: license,
	repository: repository,
	bugs: bugs,
	keywords: keywords,
	main: main,
	scripts: scripts,
	dependencies: dependencies,
	browser: browser,
	devDependencies: devDependencies,
	engines: engines,
	files: files
};

var csstree$2 = libExports;
var parse = csstree$2.parse;
var compress = compress$1;
var generate = csstree$2.generate;

function debugOutput(name, options, startTime, data) {
    if (options.debug) {
        console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
    }

    return data;
}

function createDefaultLogger(level) {
    var lastDebug;

    return function logger(title, ast) {
        var line = title;

        if (ast) {
            line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
        }

        if (level > 1 && ast) {
            var css = generate(ast);

            // when level 2, limit css to 256 symbols
            if (level === 2 && css.length > 256) {
                css = css.substr(0, 256) + '...';
            }

            line += '\n  ' + css + '\n';
        }

        console.error(line);
        lastDebug = Date.now();
    };
}

function copy(obj) {
    var result = {};

    for (var key in obj) {
        result[key] = obj[key];
    }

    return result;
}

function buildCompressOptions(options) {
    options = copy(options);

    if (typeof options.logger !== 'function' && options.debug) {
        options.logger = createDefaultLogger(options.debug);
    }

    return options;
}

function runHandler(ast, options, handlers) {
    if (!Array.isArray(handlers)) {
        handlers = [handlers];
    }

    handlers.forEach(function(fn) {
        fn(ast, options);
    });
}

function minify(context, source, options) {
    options = options || {};

    var filename = options.filename || '<unknown>';
    var result;

    // parse
    var ast = debugOutput('parsing', options, Date.now(),
        parse(source, {
            context: context,
            filename: filename,
            positions: Boolean(options.sourceMap)
        })
    );

    // before compress handlers
    if (options.beforeCompress) {
        debugOutput('beforeCompress', options, Date.now(),
            runHandler(ast, options, options.beforeCompress)
        );
    }

    // compress
    var compressResult = debugOutput('compress', options, Date.now(),
        compress(ast, buildCompressOptions(options))
    );

    // after compress handlers
    if (options.afterCompress) {
        debugOutput('afterCompress', options, Date.now(),
            runHandler(compressResult, options, options.afterCompress)
        );
    }

    // generate
    if (options.sourceMap) {
        result = debugOutput('generate(sourceMap: true)', options, Date.now(), (function() {
            var tmp = generate(compressResult.ast, { sourceMap: true });
            tmp.map._file = filename; // since other tools can relay on file in source map transform chain
            tmp.map.setSourceContent(filename, source);
            return tmp;
        }()));
    } else {
        result = debugOutput('generate', options, Date.now(), {
            css: generate(compressResult.ast),
            map: null
        });
    }

    return result;
}

function minifyStylesheet(source, options) {
    return minify('stylesheet', source, options);
}

function minifyBlock(source, options) {
    return minify('declarationList', source, options);
}

var lib = {
    version: require$$2.version,

    // main methods
    minify: minifyStylesheet,
    minifyBlock: minifyBlock,

    // css syntax parser/walkers/generator/etc
    syntax: Object.assign({
        compress: compress
    }, csstree$2)
};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const csso = lib;

minifyStyles$1.type = 'visitor';
minifyStyles$1.name = 'minifyStyles';
minifyStyles$1.active = true;
minifyStyles$1.description =
  'minifies styles and removes unused styles based on usage data';

/**
 * Minifies styles (<style> element + style attribute) using CSSO
 *
 * @author strarsis <strarsis@gmail.com>
 *
 * @type {import('../lib/types').Plugin<csso.MinifyOptions & Omit<csso.CompressOptions, 'usage'> & {
 *   usage?: boolean | {
 *     force?: boolean,
 *     ids?: boolean,
 *     classes?: boolean,
 *     tags?: boolean
 *   }
 * }>}
 */
minifyStyles$1.fn = (_root, { usage, ...params }) => {
  let enableTagsUsage = true;
  let enableIdsUsage = true;
  let enableClassesUsage = true;
  // force to use usage data even if it unsafe (document contains <script> or on* attributes)
  let forceUsageDeoptimized = false;
  if (typeof usage === 'boolean') {
    enableTagsUsage = usage;
    enableIdsUsage = usage;
    enableClassesUsage = usage;
  } else if (usage) {
    enableTagsUsage = usage.tags == null ? true : usage.tags;
    enableIdsUsage = usage.ids == null ? true : usage.ids;
    enableClassesUsage = usage.classes == null ? true : usage.classes;
    forceUsageDeoptimized = usage.force == null ? false : usage.force;
  }
  /**
   * @type {Array<XastElement>}
   */
  const styleElements = [];
  /**
   * @type {Array<XastElement>}
   */
  const elementsWithStyleAttributes = [];
  let deoptimized = false;
  /**
   * @type {Set<string>}
   */
  const tagsUsage = new Set();
  /**
   * @type {Set<string>}
   */
  const idsUsage = new Set();
  /**
   * @type {Set<string>}
   */
  const classesUsage = new Set();

  return {
    element: {
      enter: (node) => {
        // detect deoptimisations
        if (node.name === 'script') {
          deoptimized = true;
        }
        for (const name of Object.keys(node.attributes)) {
          if (name.startsWith('on')) {
            deoptimized = true;
          }
        }
        // collect tags, ids and classes usage
        tagsUsage.add(node.name);
        if (node.attributes.id != null) {
          idsUsage.add(node.attributes.id);
        }
        if (node.attributes.class != null) {
          for (const className of node.attributes.class.split(/\s+/)) {
            classesUsage.add(className);
          }
        }
        // collect style elements or elements with style attribute
        if (node.name === 'style' && node.children.length !== 0) {
          styleElements.push(node);
        } else if (node.attributes.style != null) {
          elementsWithStyleAttributes.push(node);
        }
      },
    },

    root: {
      exit: () => {
        /**
         * @type {csso.Usage}
         */
        const cssoUsage = {};
        if (deoptimized === false || forceUsageDeoptimized === true) {
          if (enableTagsUsage && tagsUsage.size !== 0) {
            cssoUsage.tags = Array.from(tagsUsage);
          }
          if (enableIdsUsage && idsUsage.size !== 0) {
            cssoUsage.ids = Array.from(idsUsage);
          }
          if (enableClassesUsage && classesUsage.size !== 0) {
            cssoUsage.classes = Array.from(classesUsage);
          }
        }
        // minify style elements
        for (const node of styleElements) {
          if (
            node.children[0].type === 'text' ||
            node.children[0].type === 'cdata'
          ) {
            const cssText = node.children[0].value;
            const minified = csso.minify(cssText, {
              ...params,
              usage: cssoUsage,
            }).css;
            // preserve cdata if necessary
            // TODO split cdata -> text optimisation into separate plugin
            if (cssText.indexOf('>') >= 0 || cssText.indexOf('<') >= 0) {
              node.children[0].type = 'cdata';
              node.children[0].value = minified;
            } else {
              node.children[0].type = 'text';
              node.children[0].value = minified;
            }
          }
        }
        // minify style attributes
        for (const node of elementsWithStyleAttributes) {
          // style attribute
          const elemStyle = node.attributes.style;
          node.attributes.style = csso.minifyBlock(elemStyle, {
            ...params,
          }).css;
        }
      },
    },
  };
};

var cleanupIDs$1 = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { visitSkip: visitSkip$3 } = xast;
const { referencesProps: referencesProps$3 } = _collections;

cleanupIDs$1.type = 'visitor';
cleanupIDs$1.name = 'cleanupIDs';
cleanupIDs$1.active = true;
cleanupIDs$1.description = 'removes unused IDs and minifies used';

const regReferencesUrl = /\burl\(("|')?#(.+?)\1\)/;
const regReferencesHref = /^#(.+?)$/;
const regReferencesBegin = /(\w+)\./;
const generateIDchars = [
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'h',
  'i',
  'j',
  'k',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
];
const maxIDindex = generateIDchars.length - 1;

/**
 * Check if an ID starts with any one of a list of strings.
 *
 * @type {(string: string, prefixes: Array<string>) => boolean}
 */
const hasStringPrefix = (string, prefixes) => {
  for (const prefix of prefixes) {
    if (string.startsWith(prefix)) {
      return true;
    }
  }
  return false;
};

/**
 * Generate unique minimal ID.
 *
 * @type {(currentID: null | Array<number>) => Array<number>}
 */
const generateID = (currentID) => {
  if (currentID == null) {
    return [0];
  }
  currentID[currentID.length - 1] += 1;
  for (let i = currentID.length - 1; i > 0; i--) {
    if (currentID[i] > maxIDindex) {
      currentID[i] = 0;
      if (currentID[i - 1] !== undefined) {
        currentID[i - 1]++;
      }
    }
  }
  if (currentID[0] > maxIDindex) {
    currentID[0] = 0;
    currentID.unshift(0);
  }
  return currentID;
};

/**
 * Get string from generated ID array.
 *
 * @type {(arr: Array<number>, prefix: string) => string}
 */
const getIDstring = (arr, prefix) => {
  return prefix + arr.map((i) => generateIDchars[i]).join('');
};

/**
 * Remove unused and minify used IDs
 * (only if there are no any <style> or <script>).
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   remove?: boolean,
 *   minify?: boolean,
 *   prefix?: string,
 *   preserve?: Array<string>,
 *   preservePrefixes?: Array<string>,
 *   force?: boolean,
 * }>}
 */
cleanupIDs$1.fn = (_root, params) => {
  const {
    remove = true,
    minify = true,
    prefix = '',
    preserve = [],
    preservePrefixes = [],
    force = false,
  } = params;
  const preserveIDs = new Set(
    Array.isArray(preserve) ? preserve : preserve ? [preserve] : []
  );
  const preserveIDPrefixes = Array.isArray(preservePrefixes)
    ? preservePrefixes
    : preservePrefixes
    ? [preservePrefixes]
    : [];
  /**
   * @type {Map<string, XastElement>}
   */
  const nodeById = new Map();
  /**
   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}
   */
  const referencesById = new Map();
  let deoptimized = false;

  return {
    element: {
      enter: (node) => {
        if (force == false) {
          // deoptimize if style or script elements are present
          if (
            (node.name === 'style' || node.name === 'script') &&
            node.children.length !== 0
          ) {
            deoptimized = true;
            return;
          }

          // avoid removing IDs if the whole SVG consists only of defs
          if (node.name === 'svg') {
            let hasDefsOnly = true;
            for (const child of node.children) {
              if (child.type !== 'element' || child.name !== 'defs') {
                hasDefsOnly = false;
                break;
              }
            }
            if (hasDefsOnly) {
              return visitSkip$3;
            }
          }
        }

        for (const [name, value] of Object.entries(node.attributes)) {
          if (name === 'id') {
            // collect all ids
            const id = value;
            if (nodeById.has(id)) {
              delete node.attributes.id; // remove repeated id
            } else {
              nodeById.set(id, node);
            }
          } else {
            // collect all references
            /**
             * @type {null | string}
             */
            let id = null;
            if (referencesProps$3.includes(name)) {
              const match = value.match(regReferencesUrl);
              if (match != null) {
                id = match[2]; // url() reference
              }
            }
            if (name === 'href' || name.endsWith(':href')) {
              const match = value.match(regReferencesHref);
              if (match != null) {
                id = match[1]; // href reference
              }
            }
            if (name === 'begin') {
              const match = value.match(regReferencesBegin);
              if (match != null) {
                id = match[1]; // href reference
              }
            }
            if (id != null) {
              let refs = referencesById.get(id);
              if (refs == null) {
                refs = [];
                referencesById.set(id, refs);
              }
              refs.push({ element: node, name, value });
            }
          }
        }
      },
    },

    root: {
      exit: () => {
        if (deoptimized) {
          return;
        }
        /**
         * @type {(id: string) => boolean}
         **/
        const isIdPreserved = (id) =>
          preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);
        /**
         * @type {null | Array<number>}
         */
        let currentID = null;
        for (const [id, refs] of referencesById) {
          const node = nodeById.get(id);
          if (node != null) {
            // replace referenced IDs with the minified ones
            if (minify && isIdPreserved(id) === false) {
              /**
               * @type {null | string}
               */
              let currentIDString = null;
              do {
                currentID = generateID(currentID);
                currentIDString = getIDstring(currentID, prefix);
              } while (isIdPreserved(currentIDString));
              node.attributes.id = currentIDString;
              for (const { element, name, value } of refs) {
                if (value.includes('#')) {
                  // replace id in href and url()
                  element.attributes[name] = value.replace(
                    `#${id}`,
                    `#${currentIDString}`
                  );
                } else {
                  // replace id in begin attribute
                  element.attributes[name] = value.replace(
                    `${id}.`,
                    `${currentIDString}.`
                  );
                }
              }
            }
            // keep referenced node
            nodeById.delete(id);
          }
        }
        // remove non-referenced IDs attributes from elements
        if (remove) {
          for (const [id, node] of nodeById) {
            if (isIdPreserved(id) === false) {
              delete node.attributes.id;
            }
          }
        }
      },
    },
  };
};

var removeUselessDefs$1 = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { detachNodeFromParent: detachNodeFromParent$e } = xast;
const { elemsGroups: elemsGroups$4 } = _collections;

removeUselessDefs$1.type = 'visitor';
removeUselessDefs$1.name = 'removeUselessDefs';
removeUselessDefs$1.active = true;
removeUselessDefs$1.description = 'removes elements in <defs> without id';

/**
 * Removes content of defs and properties that aren't rendered directly without ids.
 *
 * @author Lev Solntsev
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeUselessDefs$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'defs') {
          /**
           * @type {Array<XastElement>}
           */
          const usefulNodes = [];
          collectUsefulNodes(node, usefulNodes);
          if (usefulNodes.length === 0) {
            detachNodeFromParent$e(node, parentNode);
          }
          // TODO remove in SVGO 3
          for (const usefulNode of usefulNodes) {
            // @ts-ignore parentNode is legacy
            usefulNode.parentNode = node;
          }
          node.children = usefulNodes;
        } else if (
          elemsGroups$4.nonRendering.includes(node.name) &&
          node.attributes.id == null
        ) {
          detachNodeFromParent$e(node, parentNode);
        }
      },
    },
  };
};

/**
 * @type {(node: XastElement, usefulNodes: Array<XastElement>) => void}
 */
const collectUsefulNodes = (node, usefulNodes) => {
  for (const child of node.children) {
    if (child.type === 'element') {
      if (child.attributes.id != null || child.name === 'style') {
        usefulNodes.push(child);
      } else {
        collectUsefulNodes(child, usefulNodes);
      }
    }
  }
};

var cleanupNumericValues$1 = {};

var tools = {};

/**
 * @typedef {import('../types').PathDataCommand} PathDataCommand
 */

/**
 * Encode plain SVG data string into Data URI string.
 *
 * @type {(str: string, type?: 'base64' | 'enc' | 'unenc') => string}
 */
tools.encodeSVGDatauri = (str, type) => {
  var prefix = 'data:image/svg+xml';
  if (!type || type === 'base64') {
    // base64
    prefix += ';base64,';
    str = prefix + Buffer.from(str).toString('base64');
  } else if (type === 'enc') {
    // URI encoded
    str = prefix + ',' + encodeURIComponent(str);
  } else if (type === 'unenc') {
    // unencoded
    str = prefix + ',' + str;
  }
  return str;
};

/**
 * Decode SVG Data URI string into plain SVG string.
 *
 * @type {(str: string) => string}
 */
tools.decodeSVGDatauri = (str) => {
  var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
  var match = regexp.exec(str);

  // plain string
  if (!match) return str;

  var data = match[3];

  if (match[2]) {
    // base64
    str = Buffer.from(data, 'base64').toString('utf8');
  } else if (data.charAt(0) === '%') {
    // URI encoded
    str = decodeURIComponent(data);
  } else if (data.charAt(0) === '<') {
    // unencoded
    str = data;
  }
  return str;
};

/**
 * @typedef {{
 *   noSpaceAfterFlags?: boolean,
 *   leadingZero?: boolean,
 *   negativeExtraSpace?: boolean
 * }} CleanupOutDataParams
 */

/**
 * Convert a row of numbers to an optimized string view.
 *
 * @example
 * [0, -1, .5, .5] â†’ "0-1 .5.5"
 *
 * @type {(data: Array<number>, params: CleanupOutDataParams, command?: PathDataCommand) => string}
 */
tools.cleanupOutData = (data, params, command) => {
  let str = '';
  let delimiter;
  /**
   * @type {number}
   */
  let prev;

  data.forEach((item, i) => {
    // space delimiter by default
    delimiter = ' ';

    // no extra space in front of first number
    if (i == 0) delimiter = '';

    // no extra space after 'arcto' command flags(large-arc and sweep flags)
    // a20 60 45 0 1 30 20 â†’ a20 60 45 0130 20
    if (params.noSpaceAfterFlags && (command == 'A' || command == 'a')) {
      var pos = i % 7;
      if (pos == 4 || pos == 5) delimiter = '';
    }

    // remove floating-point numbers leading zeros
    // 0.5 â†’ .5
    // -0.5 â†’ -.5
    const itemStr = params.leadingZero
      ? removeLeadingZero$3(item)
      : item.toString();

    // no extra space in front of negative number or
    // in front of a floating number if a previous number is floating too
    if (
      params.negativeExtraSpace &&
      delimiter != '' &&
      (item < 0 || (itemStr.charAt(0) === '.' && prev % 1 !== 0))
    ) {
      delimiter = '';
    }
    // save prev item value
    prev = item;
    str += delimiter + itemStr;
  });
  return str;
};

/**
 * Remove floating-point numbers leading zero.
 *
 * @example
 * 0.5 â†’ .5
 *
 * @example
 * -0.5 â†’ -.5
 *
 * @type {(num: number) => string}
 */
const removeLeadingZero$3 = (num) => {
  var strNum = num.toString();

  if (0 < num && num < 1 && strNum.charAt(0) === '0') {
    strNum = strNum.slice(1);
  } else if (-1 < num && num < 0 && strNum.charAt(1) === '0') {
    strNum = strNum.charAt(0) + strNum.slice(2);
  }
  return strNum;
};
tools.removeLeadingZero = removeLeadingZero$3;

const { removeLeadingZero: removeLeadingZero$2 } = tools;

cleanupNumericValues$1.name = 'cleanupNumericValues';
cleanupNumericValues$1.type = 'visitor';
cleanupNumericValues$1.active = true;
cleanupNumericValues$1.description =
  'rounds numeric values to the fixed precision, removes default â€˜pxâ€™ units';

const regNumericValues$3 =
  /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;

const absoluteLengths$1 = {
  // relative to px
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  in: 96,
  pt: 4 / 3,
  pc: 16,
  px: 1,
};

/**
 * Round numeric values to the fixed precision,
 * remove default 'px' units.
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   floatPrecision?: number,
 *   leadingZero?: boolean,
 *   defaultPx?: boolean,
 *   convertToPx?: boolean
 * }>}
 */
cleanupNumericValues$1.fn = (_root, params) => {
  const {
    floatPrecision = 3,
    leadingZero = true,
    defaultPx = true,
    convertToPx = true,
  } = params;

  return {
    element: {
      enter: (node) => {
        if (node.attributes.viewBox != null) {
          const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
          node.attributes.viewBox = nums
            .map((value) => {
              const num = Number(value);
              return Number.isNaN(num)
                ? value
                : Number(num.toFixed(floatPrecision));
            })
            .join(' ');
        }

        for (const [name, value] of Object.entries(node.attributes)) {
          // The `version` attribute is a text string and cannot be rounded
          if (name === 'version') {
            continue;
          }

          const match = value.match(regNumericValues$3);

          // if attribute value matches regNumericValues
          if (match) {
            // round it to the fixed precision
            let num = Number(Number(match[1]).toFixed(floatPrecision));
            /**
             * @type {any}
             */
            let matchedUnit = match[3] || '';
            /**
             * @type{'' | keyof typeof absoluteLengths}
             */
            let units = matchedUnit;

            // convert absolute values to pixels
            if (convertToPx && units !== '' && units in absoluteLengths$1) {
              const pxNum = Number(
                (absoluteLengths$1[units] * Number(match[1])).toFixed(
                  floatPrecision
                )
              );
              if (pxNum.toString().length < match[0].length) {
                num = pxNum;
                units = 'px';
              }
            }

            // and remove leading zero
            let str;
            if (leadingZero) {
              str = removeLeadingZero$2(num);
            } else {
              str = num.toString();
            }

            // remove default 'px' units
            if (defaultPx && units === 'px') {
              units = '';
            }

            node.attributes[name] = str + units;
          }
        }
      },
    },
  };
};

var convertColors$1 = {};

const collections = _collections;

convertColors$1.type = 'visitor';
convertColors$1.name = 'convertColors';
convertColors$1.active = true;
convertColors$1.description = 'converts colors: rgb() to #rrggbb and #rrggbb to #rgb';

const rNumber = '([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)';
const rComma = '\\s*,\\s*';
const regRGB = new RegExp(
  '^rgb\\(\\s*' + rNumber + rComma + rNumber + rComma + rNumber + '\\s*\\)$'
);
const regHEX = /^#(([a-fA-F0-9])\2){3}$/;

/**
 * Convert [r, g, b] to #rrggbb.
 *
 * @see https://gist.github.com/983535
 *
 * @example
 * rgb2hex([255, 255, 255]) // '#ffffff'
 *
 * @author Jed Schmidt
 *
 * @type {(rgb: Array<number>) => string}
 */
const convertRgbToHex = ([r, g, b]) => {
  // combine the octets into a 32-bit integer as: [1][r][g][b]
  const hexNumber =
    // operator precedence is (+) > (<<) > (|)
    ((((256 + // [1][0]
      r) << // [1][r]
      8) | // [1][r][0]
      g) << // [1][r][g]
      8) | // [1][r][g][0]
    b;
  // serialize [1][r][g][b] to a hex string, and
  // remove the 1 to get the number with 0s intact
  return '#' + hexNumber.toString(16).slice(1).toUpperCase();
};

/**
 * Convert different colors formats in element attributes to hex.
 *
 * @see https://www.w3.org/TR/SVG11/types.html#DataTypeColor
 * @see https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
 *
 * @example
 * Convert color name keyword to long hex:
 * fuchsia âž¡ #ff00ff
 *
 * Convert rgb() to long hex:
 * rgb(255, 0, 255) âž¡ #ff00ff
 * rgb(50%, 100, 100%) âž¡ #7f64ff
 *
 * Convert long hex to short hex:
 * #aabbcc âž¡ #abc
 *
 * Convert hex to short name
 * #000080 âž¡ navy
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   currentColor?: boolean | string | RegExp,
 *   names2hex?: boolean,
 *   rgb2hex?: boolean,
 *   shorthex?: boolean,
 *   shortname?: boolean,
 * }>}
 */
convertColors$1.fn = (_root, params) => {
  const {
    currentColor = false,
    names2hex = true,
    rgb2hex = true,
    shorthex = true,
    shortname = true,
  } = params;

  return {
    element: {
      enter: (node) => {
        for (const [name, value] of Object.entries(node.attributes)) {
          if (collections.colorsProps.includes(name)) {
            let val = value;

            // convert colors to currentColor
            if (currentColor) {
              let matched;
              if (typeof currentColor === 'string') {
                matched = val === currentColor;
              } else if (currentColor instanceof RegExp) {
                matched = currentColor.exec(val) != null;
              } else {
                matched = val !== 'none';
              }
              if (matched) {
                val = 'currentColor';
              }
            }

            // convert color name keyword to long hex
            if (names2hex) {
              const colorName = val.toLowerCase();
              if (collections.colorsNames[colorName] != null) {
                val = collections.colorsNames[colorName];
              }
            }

            // convert rgb() to long hex
            if (rgb2hex) {
              let match = val.match(regRGB);
              if (match != null) {
                let nums = match.slice(1, 4).map((m) => {
                  let n;
                  if (m.indexOf('%') > -1) {
                    n = Math.round(parseFloat(m) * 2.55);
                  } else {
                    n = Number(m);
                  }
                  return Math.max(0, Math.min(n, 255));
                });
                val = convertRgbToHex(nums);
              }
            }

            // convert long hex to short hex
            if (shorthex) {
              let match = val.match(regHEX);
              if (match != null) {
                val = '#' + match[0][1] + match[0][3] + match[0][5];
              }
            }

            // convert hex to short name
            if (shortname) {
              const colorName = val.toLowerCase();
              if (collections.colorsShortNames[colorName] != null) {
                val = collections.colorsShortNames[colorName];
              }
            }

            node.attributes[name] = val;
          }
        }
      },
    },
  };
};

var removeUnknownsAndDefaults$1 = {};

var style = {};

/**
 * @typedef {import('css-tree').Rule} CsstreeRule
 * @typedef {import('./types').Specificity} Specificity
 * @typedef {import('./types').Stylesheet} Stylesheet
 * @typedef {import('./types').StylesheetRule} StylesheetRule
 * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration
 * @typedef {import('./types').ComputedStyles} ComputedStyles
 * @typedef {import('./types').XastRoot} XastRoot
 * @typedef {import('./types').XastElement} XastElement
 * @typedef {import('./types').XastParent} XastParent
 * @typedef {import('./types').XastChild} XastChild
 */

const stable = stableExports;
const csstree$1 = libExports;
// @ts-ignore not defined in @types/csso
const specificity = specificity$4;
const { visit: visit$3, matches } = xast;
const {
  attrsGroups: attrsGroups$3,
  inheritableAttrs: inheritableAttrs$3,
  presentationNonInheritableGroupAttrs: presentationNonInheritableGroupAttrs$2,
} = _collections;

// @ts-ignore not defined in @types/csstree
const csstreeWalkSkip = csstree$1.walk.skip;

/**
 * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule}
 */
const parseRule = (ruleNode, dynamic) => {
  let selectors;
  let selectorsSpecificity;
  /**
   * @type {Array<StylesheetDeclaration>}
   */
  const declarations = [];
  csstree$1.walk(ruleNode, (cssNode) => {
    if (cssNode.type === 'SelectorList') {
      // compute specificity from original node to consider pseudo classes
      selectorsSpecificity = specificity(cssNode);
      const newSelectorsNode = csstree$1.clone(cssNode);
      csstree$1.walk(newSelectorsNode, (pseudoClassNode, item, list) => {
        if (pseudoClassNode.type === 'PseudoClassSelector') {
          dynamic = true;
          list.remove(item);
        }
      });
      selectors = csstree$1.generate(newSelectorsNode);
      return csstreeWalkSkip;
    }
    if (cssNode.type === 'Declaration') {
      declarations.push({
        name: cssNode.property,
        value: csstree$1.generate(cssNode.value),
        important: cssNode.important === true,
      });
      return csstreeWalkSkip;
    }
  });
  if (selectors == null || selectorsSpecificity == null) {
    throw Error('assert');
  }
  return {
    dynamic,
    selectors,
    specificity: selectorsSpecificity,
    declarations,
  };
};

/**
 * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}
 */
const parseStylesheet = (css, dynamic) => {
  /**
   * @type {Array<StylesheetRule>}
   */
  const rules = [];
  const ast = csstree$1.parse(css, {
    parseValue: false,
    parseAtrulePrelude: false,
  });
  csstree$1.walk(ast, (cssNode) => {
    if (cssNode.type === 'Rule') {
      rules.push(parseRule(cssNode, dynamic || false));
      return csstreeWalkSkip;
    }
    if (cssNode.type === 'Atrule') {
      if (cssNode.name === 'keyframes') {
        return csstreeWalkSkip;
      }
      csstree$1.walk(cssNode, (ruleNode) => {
        if (ruleNode.type === 'Rule') {
          rules.push(parseRule(ruleNode, dynamic || true));
          return csstreeWalkSkip;
        }
      });
      return csstreeWalkSkip;
    }
  });
  return rules;
};

/**
 * @type {(css: string) => Array<StylesheetDeclaration>}
 */
const parseStyleDeclarations = (css) => {
  /**
   * @type {Array<StylesheetDeclaration>}
   */
  const declarations = [];
  const ast = csstree$1.parse(css, {
    context: 'declarationList',
    parseValue: false,
  });
  csstree$1.walk(ast, (cssNode) => {
    if (cssNode.type === 'Declaration') {
      declarations.push({
        name: cssNode.property,
        value: csstree$1.generate(cssNode.value),
        important: cssNode.important === true,
      });
    }
  });
  return declarations;
};

/**
 * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}
 */
const computeOwnStyle = (stylesheet, node) => {
  /**
   * @type {ComputedStyles}
   */
  const computedStyle = {};
  const importantStyles = new Map();

  // collect attributes
  for (const [name, value] of Object.entries(node.attributes)) {
    if (attrsGroups$3.presentation.includes(name)) {
      computedStyle[name] = { type: 'static', inherited: false, value };
      importantStyles.set(name, false);
    }
  }

  // collect matching rules
  for (const { selectors, declarations, dynamic } of stylesheet.rules) {
    if (matches(node, selectors)) {
      for (const { name, value, important } of declarations) {
        const computed = computedStyle[name];
        if (computed && computed.type === 'dynamic') {
          continue;
        }
        if (dynamic) {
          computedStyle[name] = { type: 'dynamic', inherited: false };
          continue;
        }
        if (
          computed == null ||
          important === true ||
          importantStyles.get(name) === false
        ) {
          computedStyle[name] = { type: 'static', inherited: false, value };
          importantStyles.set(name, important);
        }
      }
    }
  }

  // collect inline styles
  const styleDeclarations =
    node.attributes.style == null
      ? []
      : parseStyleDeclarations(node.attributes.style);
  for (const { name, value, important } of styleDeclarations) {
    const computed = computedStyle[name];
    if (computed && computed.type === 'dynamic') {
      continue;
    }
    if (
      computed == null ||
      important === true ||
      importantStyles.get(name) === false
    ) {
      computedStyle[name] = { type: 'static', inherited: false, value };
      importantStyles.set(name, important);
    }
  }

  return computedStyle;
};

/**
 * Compares two selector specificities.
 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
 *
 * @type {(a: Specificity, b: Specificity) => number}
 */
const compareSpecificity = (a, b) => {
  for (var i = 0; i < 4; i += 1) {
    if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }

  return 0;
};

/**
 * @type {(root: XastRoot) => Stylesheet}
 */
const collectStylesheet$5 = (root) => {
  /**
   * @type {Array<StylesheetRule>}
   */
  const rules = [];
  /**
   * @type {Map<XastElement, XastParent>}
   */
  const parents = new Map();
  visit$3(root, {
    element: {
      enter: (node, parentNode) => {
        // store parents
        parents.set(node, parentNode);
        // find and parse all styles
        if (node.name === 'style') {
          const dynamic =
            node.attributes.media != null && node.attributes.media !== 'all';
          if (
            node.attributes.type == null ||
            node.attributes.type === '' ||
            node.attributes.type === 'text/css'
          ) {
            const children = node.children;
            for (const child of children) {
              if (child.type === 'text' || child.type === 'cdata') {
                rules.push(...parseStylesheet(child.value, dynamic));
              }
            }
          }
        }
      },
    },
  });
  // sort by selectors specificity
  stable.inplace(rules, (a, b) =>
    compareSpecificity(a.specificity, b.specificity)
  );
  return { rules, parents };
};
style.collectStylesheet = collectStylesheet$5;

/**
 * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}
 */
const computeStyle$5 = (stylesheet, node) => {
  const { parents } = stylesheet;
  // collect inherited styles
  const computedStyles = computeOwnStyle(stylesheet, node);
  let parent = parents.get(node);
  while (parent != null && parent.type !== 'root') {
    const inheritedStyles = computeOwnStyle(stylesheet, parent);
    for (const [name, computed] of Object.entries(inheritedStyles)) {
      if (
        computedStyles[name] == null &&
        // ignore not inheritable styles
        inheritableAttrs$3.includes(name) === true &&
        presentationNonInheritableGroupAttrs$2.includes(name) === false
      ) {
        computedStyles[name] = { ...computed, inherited: true };
      }
    }
    parent = parents.get(parent);
  }
  return computedStyles;
};
style.computeStyle = computeStyle$5;

const { visitSkip: visitSkip$2, detachNodeFromParent: detachNodeFromParent$d } = xast;
const { collectStylesheet: collectStylesheet$4, computeStyle: computeStyle$4 } = style;
const {
  elems,
  attrsGroups: attrsGroups$2,
  elemsGroups: elemsGroups$3,
  attrsGroupsDefaults: attrsGroupsDefaults$1,
  presentationNonInheritableGroupAttrs: presentationNonInheritableGroupAttrs$1,
} = _collections;

removeUnknownsAndDefaults$1.type = 'visitor';
removeUnknownsAndDefaults$1.name = 'removeUnknownsAndDefaults';
removeUnknownsAndDefaults$1.active = true;
removeUnknownsAndDefaults$1.description =
  'removes unknown elements content and attributes, removes attrs with default values';

// resolve all groups references

/**
 * @type {Map<string, Set<string>>}
 */
const allowedChildrenPerElement = new Map();
/**
 * @type {Map<string, Set<string>>}
 */
const allowedAttributesPerElement = new Map();
/**
 * @type {Map<string, Map<string, string>>}
 */
const attributesDefaultsPerElement = new Map();

for (const [name, config] of Object.entries(elems)) {
  /**
   * @type {Set<string>}
   */
  const allowedChildren = new Set();
  if (config.content) {
    for (const elementName of config.content) {
      allowedChildren.add(elementName);
    }
  }
  if (config.contentGroups) {
    for (const contentGroupName of config.contentGroups) {
      const elemsGroup = elemsGroups$3[contentGroupName];
      if (elemsGroup) {
        for (const elementName of elemsGroup) {
          allowedChildren.add(elementName);
        }
      }
    }
  }
  /**
   * @type {Set<string>}
   */
  const allowedAttributes = new Set();
  if (config.attrs) {
    for (const attrName of config.attrs) {
      allowedAttributes.add(attrName);
    }
  }
  /**
   * @type {Map<string, string>}
   */
  const attributesDefaults = new Map();
  if (config.defaults) {
    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
      attributesDefaults.set(attrName, defaultValue);
    }
  }
  for (const attrsGroupName of config.attrsGroups) {
    const attrsGroup = attrsGroups$2[attrsGroupName];
    if (attrsGroup) {
      for (const attrName of attrsGroup) {
        allowedAttributes.add(attrName);
      }
    }
    const groupDefaults = attrsGroupsDefaults$1[attrsGroupName];
    if (groupDefaults) {
      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
        attributesDefaults.set(attrName, defaultValue);
      }
    }
  }
  allowedChildrenPerElement.set(name, allowedChildren);
  allowedAttributesPerElement.set(name, allowedAttributes);
  attributesDefaultsPerElement.set(name, attributesDefaults);
}

/**
 * Remove unknown elements content and attributes,
 * remove attributes with default values.
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   unknownContent?: boolean,
 *   unknownAttrs?: boolean,
 *   defaultAttrs?: boolean,
 *   uselessOverrides?: boolean,
 *   keepDataAttrs?: boolean,
 *   keepAriaAttrs?: boolean,
 *   keepRoleAttr?: boolean,
 * }>}
 */
removeUnknownsAndDefaults$1.fn = (root, params) => {
  const {
    unknownContent = true,
    unknownAttrs = true,
    defaultAttrs = true,
    uselessOverrides = true,
    keepDataAttrs = true,
    keepAriaAttrs = true,
    keepRoleAttr = false,
  } = params;
  const stylesheet = collectStylesheet$4(root);

  return {
    element: {
      enter: (node, parentNode) => {
        // skip namespaced elements
        if (node.name.includes(':')) {
          return;
        }
        // skip visiting foreignObject subtree
        if (node.name === 'foreignObject') {
          return visitSkip$2;
        }

        // remove unknown element's content
        if (unknownContent && parentNode.type === 'element') {
          const allowedChildren = allowedChildrenPerElement.get(
            parentNode.name
          );
          if (allowedChildren == null || allowedChildren.size === 0) {
            // remove unknown elements
            if (allowedChildrenPerElement.get(node.name) == null) {
              detachNodeFromParent$d(node, parentNode);
              return;
            }
          } else {
            // remove not allowed children
            if (allowedChildren.has(node.name) === false) {
              detachNodeFromParent$d(node, parentNode);
              return;
            }
          }
        }

        const allowedAttributes = allowedAttributesPerElement.get(node.name);
        const attributesDefaults = attributesDefaultsPerElement.get(node.name);
        const computedParentStyle =
          parentNode.type === 'element'
            ? computeStyle$4(stylesheet, parentNode)
            : null;

        // remove element's unknown attrs and attrs with default values
        for (const [name, value] of Object.entries(node.attributes)) {
          if (keepDataAttrs && name.startsWith('data-')) {
            continue;
          }
          if (keepAriaAttrs && name.startsWith('aria-')) {
            continue;
          }
          if (keepRoleAttr && name === 'role') {
            continue;
          }
          // skip xmlns attribute
          if (name === 'xmlns') {
            continue;
          }
          // skip namespaced attributes except xml:* and xlink:*
          if (name.includes(':')) {
            const [prefix] = name.split(':');
            if (prefix !== 'xml' && prefix !== 'xlink') {
              continue;
            }
          }

          if (
            unknownAttrs &&
            allowedAttributes &&
            allowedAttributes.has(name) === false
          ) {
            delete node.attributes[name];
          }
          if (
            defaultAttrs &&
            node.attributes.id == null &&
            attributesDefaults &&
            attributesDefaults.get(name) === value
          ) {
            // keep defaults if parent has own or inherited style
            if (
              computedParentStyle == null ||
              computedParentStyle[name] == null
            ) {
              delete node.attributes[name];
            }
          }
          if (uselessOverrides && node.attributes.id == null) {
            const style =
              computedParentStyle == null ? null : computedParentStyle[name];
            if (
              presentationNonInheritableGroupAttrs$1.includes(name) === false &&
              style != null &&
              style.type === 'static' &&
              style.value === value
            ) {
              delete node.attributes[name];
            }
          }
        }
      },
    },
  };
};

var removeNonInheritableGroupAttrs$1 = {};

removeNonInheritableGroupAttrs$1.name = 'removeNonInheritableGroupAttrs';

removeNonInheritableGroupAttrs$1.type = 'perItem';

removeNonInheritableGroupAttrs$1.active = true;

removeNonInheritableGroupAttrs$1.description =
  'removes non-inheritable groupâ€™s presentational attributes';

const {
  inheritableAttrs: inheritableAttrs$2,
  attrsGroups: attrsGroups$1,
  presentationNonInheritableGroupAttrs,
} = _collections;

/**
 * Remove non-inheritable group's "presentation" attributes.
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeNonInheritableGroupAttrs$1.fn = function (item) {
  if (item.type === 'element' && item.name === 'g') {
    for (const name of Object.keys(item.attributes)) {
      if (
        attrsGroups$1.presentation.includes(name) === true &&
        inheritableAttrs$2.includes(name) === false &&
        presentationNonInheritableGroupAttrs.includes(name) === false
      ) {
        delete item.attributes[name];
      }
    }
  }
};

var removeUselessStrokeAndFill$1 = {};

const { visit: visit$2, visitSkip: visitSkip$1, detachNodeFromParent: detachNodeFromParent$c } = xast;
const { collectStylesheet: collectStylesheet$3, computeStyle: computeStyle$3 } = style;
const { elemsGroups: elemsGroups$2 } = _collections;

removeUselessStrokeAndFill$1.type = 'visitor';
removeUselessStrokeAndFill$1.name = 'removeUselessStrokeAndFill';
removeUselessStrokeAndFill$1.active = true;
removeUselessStrokeAndFill$1.description = 'removes useless stroke and fill attributes';

/**
 * Remove useless stroke and fill attrs.
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *  stroke?: boolean,
 *  fill?: boolean,
 *  removeNone?: boolean
 * }>}
 */
removeUselessStrokeAndFill$1.fn = (root, params) => {
  const {
    stroke: removeStroke = true,
    fill: removeFill = true,
    removeNone = false,
  } = params;

  // style and script elements deoptimise this plugin
  let hasStyleOrScript = false;
  visit$2(root, {
    element: {
      enter: (node) => {
        if (node.name === 'style' || node.name === 'script') {
          hasStyleOrScript = true;
        }
      },
    },
  });
  if (hasStyleOrScript) {
    return null;
  }

  const stylesheet = collectStylesheet$3(root);

  return {
    element: {
      enter: (node, parentNode) => {
        // id attribute deoptimise the whole subtree
        if (node.attributes.id != null) {
          return visitSkip$1;
        }
        if (elemsGroups$2.shape.includes(node.name) == false) {
          return;
        }
        const computedStyle = computeStyle$3(stylesheet, node);
        const stroke = computedStyle.stroke;
        const strokeOpacity = computedStyle['stroke-opacity'];
        const strokeWidth = computedStyle['stroke-width'];
        const markerEnd = computedStyle['marker-end'];
        const fill = computedStyle.fill;
        const fillOpacity = computedStyle['fill-opacity'];
        const computedParentStyle =
          parentNode.type === 'element'
            ? computeStyle$3(stylesheet, parentNode)
            : null;
        const parentStroke =
          computedParentStyle == null ? null : computedParentStyle.stroke;

        // remove stroke*
        if (removeStroke) {
          if (
            stroke == null ||
            (stroke.type === 'static' && stroke.value == 'none') ||
            (strokeOpacity != null &&
              strokeOpacity.type === 'static' &&
              strokeOpacity.value === '0') ||
            (strokeWidth != null &&
              strokeWidth.type === 'static' &&
              strokeWidth.value === '0')
          ) {
            // stroke-width may affect the size of marker-end
            // marker is not visible when stroke-width is 0
            if (
              (strokeWidth != null &&
                strokeWidth.type === 'static' &&
                strokeWidth.value === '0') ||
              markerEnd == null
            ) {
              for (const name of Object.keys(node.attributes)) {
                if (name.startsWith('stroke')) {
                  delete node.attributes[name];
                }
              }
              // set explicit none to not inherit from parent
              if (
                parentStroke != null &&
                parentStroke.type === 'static' &&
                parentStroke.value !== 'none'
              ) {
                node.attributes.stroke = 'none';
              }
            }
          }
        }

        // remove fill*
        if (removeFill) {
          if (
            (fill != null && fill.type === 'static' && fill.value === 'none') ||
            (fillOpacity != null &&
              fillOpacity.type === 'static' &&
              fillOpacity.value === '0')
          ) {
            for (const name of Object.keys(node.attributes)) {
              if (name.startsWith('fill-')) {
                delete node.attributes[name];
              }
            }
            if (
              fill == null ||
              (fill.type === 'static' && fill.value !== 'none')
            ) {
              node.attributes.fill = 'none';
            }
          }
        }

        if (removeNone) {
          if (
            (stroke == null || node.attributes.stroke === 'none') &&
            ((fill != null &&
              fill.type === 'static' &&
              fill.value === 'none') ||
              node.attributes.fill === 'none')
          ) {
            detachNodeFromParent$c(node, parentNode);
          }
        }
      },
    },
  };
};

var removeViewBox$1 = {};

removeViewBox$1.type = 'visitor';
removeViewBox$1.name = 'removeViewBox';
removeViewBox$1.active = true;
removeViewBox$1.description = 'removes viewBox attribute when possible';

const viewBoxElems = ['svg', 'pattern', 'symbol'];

/**
 * Remove viewBox attr which coincides with a width/height box.
 *
 * @see https://www.w3.org/TR/SVG11/coords.html#ViewBoxAttribute
 *
 * @example
 * <svg width="100" height="50" viewBox="0 0 100 50">
 *             â¬‡
 * <svg width="100" height="50">
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeViewBox$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (
          viewBoxElems.includes(node.name) &&
          node.attributes.viewBox != null &&
          node.attributes.width != null &&
          node.attributes.height != null
        ) {
          // TODO remove width/height for such case instead
          if (node.name === 'svg' && parentNode.type !== 'root') {
            return;
          }
          const nums = node.attributes.viewBox.split(/[ ,]+/g);
          if (
            nums[0] === '0' &&
            nums[1] === '0' &&
            node.attributes.width.replace(/px$/, '') === nums[2] && // could use parseFloat too
            node.attributes.height.replace(/px$/, '') === nums[3]
          ) {
            delete node.attributes.viewBox;
          }
        }
      },
    },
  };
};

var cleanupEnableBackground$1 = {};

const { visit: visit$1 } = xast;

cleanupEnableBackground$1.type = 'visitor';
cleanupEnableBackground$1.name = 'cleanupEnableBackground';
cleanupEnableBackground$1.active = true;
cleanupEnableBackground$1.description =
  'remove or cleanup enable-background attribute when possible';

/**
 * Remove or cleanup enable-background attr which coincides with a width/height box.
 *
 * @see https://www.w3.org/TR/SVG11/filters.html#EnableBackgroundProperty
 *
 * @example
 * <svg width="100" height="50" enable-background="new 0 0 100 50">
 *             â¬‡
 * <svg width="100" height="50">
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
cleanupEnableBackground$1.fn = (root) => {
  const regEnableBackground =
    /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;

  let hasFilter = false;
  visit$1(root, {
    element: {
      enter: (node) => {
        if (node.name === 'filter') {
          hasFilter = true;
        }
      },
    },
  });

  return {
    element: {
      enter: (node) => {
        if (node.attributes['enable-background'] == null) {
          return;
        }
        if (hasFilter) {
          if (
            (node.name === 'svg' ||
              node.name === 'mask' ||
              node.name === 'pattern') &&
            node.attributes.width != null &&
            node.attributes.height != null
          ) {
            const match =
              node.attributes['enable-background'].match(regEnableBackground);
            if (
              match != null &&
              node.attributes.width === match[1] &&
              node.attributes.height === match[3]
            ) {
              if (node.name === 'svg') {
                delete node.attributes['enable-background'];
              } else {
                node.attributes['enable-background'] = 'new';
              }
            }
          }
        } else {
          //we don't need 'enable-background' if we have no filters
          delete node.attributes['enable-background'];
        }
      },
    },
  };
};

var removeHiddenElems$1 = {};

var path = {};

/**
 * @typedef {import('./types').PathDataItem} PathDataItem
 * @typedef {import('./types').PathDataCommand} PathDataCommand
 */

// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF

const argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7,
};

/**
 * @type {(c: string) => c is PathDataCommand}
 */
const isCommand = (c) => {
  return c in argsCountPerCommand;
};

/**
 * @type {(c: string) => boolean}
 */
const isWsp = (c) => {
  const codePoint = c.codePointAt(0);
  return (
    codePoint === 0x20 ||
    codePoint === 0x9 ||
    codePoint === 0xd ||
    codePoint === 0xa
  );
};

/**
 * @type {(c: string) => boolean}
 */
const isDigit = (c) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};

/**
 * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState
 */

/**
 * @type {(string: string, cursor: number) => [number, number | null]}
 */
const readNumber = (string, cursor) => {
  let i = cursor;
  let value = '';
  let state = /** @type {ReadNumberState} */ ('none');
  for (; i < string.length; i += 1) {
    const c = string[i];
    if (c === '+' || c === '-') {
      if (state === 'none') {
        state = 'sign';
        value += c;
        continue;
      }
      if (state === 'e') {
        state = 'exponent_sign';
        value += c;
        continue;
      }
    }
    if (isDigit(c)) {
      if (state === 'none' || state === 'sign' || state === 'whole') {
        state = 'whole';
        value += c;
        continue;
      }
      if (state === 'decimal_point' || state === 'decimal') {
        state = 'decimal';
        value += c;
        continue;
      }
      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {
        state = 'exponent';
        value += c;
        continue;
      }
    }
    if (c === '.') {
      if (state === 'none' || state === 'sign' || state === 'whole') {
        state = 'decimal_point';
        value += c;
        continue;
      }
    }
    if (c === 'E' || c == 'e') {
      if (
        state === 'whole' ||
        state === 'decimal_point' ||
        state === 'decimal'
      ) {
        state = 'e';
        value += c;
        continue;
      }
    }
    break;
  }
  const number = Number.parseFloat(value);
  if (Number.isNaN(number)) {
    return [cursor, null];
  } else {
    // step back to delegate iteration to parent loop
    return [i - 1, number];
  }
};

/**
 * @type {(string: string) => Array<PathDataItem>}
 */
const parsePathData$3 = (string) => {
  /**
   * @type {Array<PathDataItem>}
   */
  const pathData = [];
  /**
   * @type {null | PathDataCommand}
   */
  let command = null;
  let args = /** @type {number[]} */ ([]);
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i = 0; i < string.length; i += 1) {
    const c = string.charAt(i);
    if (isWsp(c)) {
      continue;
    }
    // allow comma only between arguments
    if (canHaveComma && c === ',') {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        // moveto should be leading command
        if (c !== 'M' && c !== 'm') {
          return pathData;
        }
      } else {
        // stop if previous command arguments are not flushed
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      // flush command without arguments
      if (argsCount === 0) {
        pathData.push({ command, args });
      }
      continue;
    }
    // avoid parsing arguments if no command detected
    if (command == null) {
      return pathData;
    }
    // read next argument
    let newCursor = i;
    let number = null;
    if (command === 'A' || command === 'a') {
      const position = args.length;
      if (position === 0 || position === 1) {
        // allow only positive number without sign as first two arguments
        if (c !== '+' && c !== '-') {
          [newCursor, number] = readNumber(string, i);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number] = readNumber(string, i);
      }
      if (position === 3 || position === 4) {
        // read flags
        if (c === '0') {
          number = 0;
        }
        if (c === '1') {
          number = 1;
        }
      }
    } else {
      [newCursor, number] = readNumber(string, i);
    }
    if (number == null) {
      return pathData;
    }
    args.push(number);
    canHaveComma = true;
    hadComma = false;
    i = newCursor;
    // flush arguments when necessary count is reached
    if (args.length === argsCount) {
      pathData.push({ command, args });
      // subsequent moveto coordinates are threated as implicit lineto commands
      if (command === 'M') {
        command = 'L';
      }
      if (command === 'm') {
        command = 'l';
      }
      args = [];
    }
  }
  return pathData;
};
path.parsePathData = parsePathData$3;

/**
 * @type {(number: number, precision?: number) => string}
 */
const stringifyNumber = (number, precision) => {
  if (precision != null) {
    const ratio = 10 ** precision;
    number = Math.round(number * ratio) / ratio;
  }
  // remove zero whole from decimal number
  return number.toString().replace(/^0\./, '.').replace(/^-0\./, '-.');
};

/**
 * Elliptical arc large-arc and sweep flags are rendered with spaces
 * because many non-browser environments are not able to parse such paths
 *
 * @type {(
 *   command: string,
 *   args: number[],
 *   precision?: number,
 *   disableSpaceAfterFlags?: boolean
 * ) => string}
 */
const stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {
  let result = '';
  let prev = '';
  for (let i = 0; i < args.length; i += 1) {
    const number = args[i];
    const numberString = stringifyNumber(number, precision);
    if (
      disableSpaceAfterFlags &&
      (command === 'A' || command === 'a') &&
      // consider combined arcs
      (i % 7 === 4 || i % 7 === 5)
    ) {
      result += numberString;
    } else if (i === 0 || numberString.startsWith('-')) {
      // avoid space before first and negative numbers
      result += numberString;
    } else if (prev.includes('.') && numberString.startsWith('.')) {
      // remove space before decimal with zero whole
      // only when previous number is also decimal
      result += numberString;
    } else {
      result += ` ${numberString}`;
    }
    prev = numberString;
  }
  return result;
};

/**
 * @typedef {{
 *   pathData: Array<PathDataItem>;
 *   precision?: number;
 *   disableSpaceAfterFlags?: boolean;
 * }} StringifyPathDataOptions
 */

/**
 * @type {(options: StringifyPathDataOptions) => string}
 */
const stringifyPathData$2 = ({ pathData, precision, disableSpaceAfterFlags }) => {
  // combine sequence of the same commands
  let combined = [];
  for (let i = 0; i < pathData.length; i += 1) {
    const { command, args } = pathData[i];
    if (i === 0) {
      combined.push({ command, args });
    } else {
      /**
       * @type {PathDataItem}
       */
      const last = combined[combined.length - 1];
      // match leading moveto with following lineto
      if (i === 1) {
        if (command === 'L') {
          last.command = 'M';
        }
        if (command === 'l') {
          last.command = 'm';
        }
      }
      if (
        (last.command === command &&
          last.command !== 'M' &&
          last.command !== 'm') ||
        // combine matching moveto and lineto sequences
        (last.command === 'M' && command === 'L') ||
        (last.command === 'm' && command === 'l')
      ) {
        last.args = [...last.args, ...args];
      } else {
        combined.push({ command, args });
      }
    }
  }
  let result = '';
  for (const { command, args } of combined) {
    result +=
      command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
  }
  return result;
};
path.stringifyPathData = stringifyPathData$2;

const {
  querySelector,
  closestByName,
  detachNodeFromParent: detachNodeFromParent$b,
} = xast;
const { collectStylesheet: collectStylesheet$2, computeStyle: computeStyle$2 } = style;
const { parsePathData: parsePathData$2 } = path;

removeHiddenElems$1.name = 'removeHiddenElems';
removeHiddenElems$1.type = 'visitor';
removeHiddenElems$1.active = true;
removeHiddenElems$1.description =
  'removes hidden elements (zero sized, with absent attributes)';

/**
 * Remove hidden elements with disabled rendering:
 * - display="none"
 * - opacity="0"
 * - circle with zero radius
 * - ellipse with zero x-axis or y-axis radius
 * - rectangle with zero width or height
 * - pattern with zero width or height
 * - image with zero width or height
 * - path with empty data
 * - polyline with empty points
 * - polygon with empty points
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   isHidden: boolean,
 *   displayNone: boolean,
 *   opacity0: boolean,
 *   circleR0: boolean,
 *   ellipseRX0: boolean,
 *   ellipseRY0: boolean,
 *   rectWidth0: boolean,
 *   rectHeight0: boolean,
 *   patternWidth0: boolean,
 *   patternHeight0: boolean,
 *   imageWidth0: boolean,
 *   imageHeight0: boolean,
 *   pathEmptyD: boolean,
 *   polylineEmptyPoints: boolean,
 *   polygonEmptyPoints: boolean,
 * }>}
 */
removeHiddenElems$1.fn = (root, params) => {
  const {
    isHidden = true,
    displayNone = true,
    opacity0 = true,
    circleR0 = true,
    ellipseRX0 = true,
    ellipseRY0 = true,
    rectWidth0 = true,
    rectHeight0 = true,
    patternWidth0 = true,
    patternHeight0 = true,
    imageWidth0 = true,
    imageHeight0 = true,
    pathEmptyD = true,
    polylineEmptyPoints = true,
    polygonEmptyPoints = true,
  } = params;
  const stylesheet = collectStylesheet$2(root);

  return {
    element: {
      enter: (node, parentNode) => {
        // Removes hidden elements
        // https://www.w3schools.com/cssref/pr_class_visibility.asp
        const computedStyle = computeStyle$2(stylesheet, node);
        if (
          isHidden &&
          computedStyle.visibility &&
          computedStyle.visibility.type === 'static' &&
          computedStyle.visibility.value === 'hidden' &&
          // keep if any descendant enables visibility
          querySelector(node, '[visibility=visible]') == null
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // display="none"
        //
        // https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
        // "A value of display: none indicates that the given element
        // and its children shall not be rendered directly"
        if (
          displayNone &&
          computedStyle.display &&
          computedStyle.display.type === 'static' &&
          computedStyle.display.value === 'none' &&
          // markers with display: none still rendered
          node.name !== 'marker'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // opacity="0"
        //
        // https://www.w3.org/TR/SVG11/masking.html#ObjectAndGroupOpacityProperties
        if (
          opacity0 &&
          computedStyle.opacity &&
          computedStyle.opacity.type === 'static' &&
          computedStyle.opacity.value === '0' &&
          // transparent element inside clipPath still affect clipped elements
          closestByName(node, 'clipPath') == null
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Circles with zero radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#CircleElementRAttribute
        // "A value of zero disables rendering of the element"
        //
        // <circle r="0">
        if (
          circleR0 &&
          node.name === 'circle' &&
          node.children.length === 0 &&
          node.attributes.r === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Ellipse with zero x-axis radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRXAttribute
        // "A value of zero disables rendering of the element"
        //
        // <ellipse rx="0">
        if (
          ellipseRX0 &&
          node.name === 'ellipse' &&
          node.children.length === 0 &&
          node.attributes.rx === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Ellipse with zero y-axis radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRYAttribute
        // "A value of zero disables rendering of the element"
        //
        // <ellipse ry="0">
        if (
          ellipseRY0 &&
          node.name === 'ellipse' &&
          node.children.length === 0 &&
          node.attributes.ry === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Rectangle with zero width
        //
        // https://www.w3.org/TR/SVG11/shapes.html#RectElementWidthAttribute
        // "A value of zero disables rendering of the element"
        //
        // <rect width="0">
        if (
          rectWidth0 &&
          node.name === 'rect' &&
          node.children.length === 0 &&
          node.attributes.width === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Rectangle with zero height
        //
        // https://www.w3.org/TR/SVG11/shapes.html#RectElementHeightAttribute
        // "A value of zero disables rendering of the element"
        //
        // <rect height="0">
        if (
          rectHeight0 &&
          rectWidth0 &&
          node.name === 'rect' &&
          node.children.length === 0 &&
          node.attributes.height === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Pattern with zero width
        //
        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementWidthAttribute
        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
        //
        // <pattern width="0">
        if (
          patternWidth0 &&
          node.name === 'pattern' &&
          node.attributes.width === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Pattern with zero height
        //
        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementHeightAttribute
        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
        //
        // <pattern height="0">
        if (
          patternHeight0 &&
          node.name === 'pattern' &&
          node.attributes.height === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Image with zero width
        //
        // https://www.w3.org/TR/SVG11/struct.html#ImageElementWidthAttribute
        // "A value of zero disables rendering of the element"
        //
        // <image width="0">
        if (
          imageWidth0 &&
          node.name === 'image' &&
          node.attributes.width === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Image with zero height
        //
        // https://www.w3.org/TR/SVG11/struct.html#ImageElementHeightAttribute
        // "A value of zero disables rendering of the element"
        //
        // <image height="0">
        if (
          imageHeight0 &&
          node.name === 'image' &&
          node.attributes.height === '0'
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Path with empty data
        //
        // https://www.w3.org/TR/SVG11/paths.html#DAttribute
        //
        // <path d=""/>
        if (pathEmptyD && node.name === 'path') {
          if (node.attributes.d == null) {
            detachNodeFromParent$b(node, parentNode);
            return;
          }
          const pathData = parsePathData$2(node.attributes.d);
          if (pathData.length === 0) {
            detachNodeFromParent$b(node, parentNode);
            return;
          }
          // keep single point paths for markers
          if (
            pathData.length === 1 &&
            computedStyle['marker-start'] == null &&
            computedStyle['marker-end'] == null
          ) {
            detachNodeFromParent$b(node, parentNode);
            return;
          }
          return;
        }

        // Polyline with empty points
        //
        // https://www.w3.org/TR/SVG11/shapes.html#PolylineElementPointsAttribute
        //
        // <polyline points="">
        if (
          polylineEmptyPoints &&
          node.name === 'polyline' &&
          node.attributes.points == null
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }

        // Polygon with empty points
        //
        // https://www.w3.org/TR/SVG11/shapes.html#PolygonElementPointsAttribute
        //
        // <polygon points="">
        if (
          polygonEmptyPoints &&
          node.name === 'polygon' &&
          node.attributes.points == null
        ) {
          detachNodeFromParent$b(node, parentNode);
          return;
        }
      },
    },
  };
};

var removeEmptyText$1 = {};

const { detachNodeFromParent: detachNodeFromParent$a } = xast;

removeEmptyText$1.name = 'removeEmptyText';
removeEmptyText$1.type = 'visitor';
removeEmptyText$1.active = true;
removeEmptyText$1.description = 'removes empty <text> elements';

/**
 * Remove empty Text elements.
 *
 * @see https://www.w3.org/TR/SVG11/text.html
 *
 * @example
 * Remove empty text element:
 * <text/>
 *
 * Remove empty tspan element:
 * <tspan/>
 *
 * Remove tref with empty xlink:href attribute:
 * <tref xlink:href=""/>
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   text?: boolean,
 *   tspan?: boolean,
 *   tref?: boolean
 * }>}
 */
removeEmptyText$1.fn = (root, params) => {
  const { text = true, tspan = true, tref = true } = params;
  return {
    element: {
      enter: (node, parentNode) => {
        // Remove empty text element
        if (text && node.name === 'text' && node.children.length === 0) {
          detachNodeFromParent$a(node, parentNode);
        }
        // Remove empty tspan element
        if (tspan && node.name === 'tspan' && node.children.length === 0) {
          detachNodeFromParent$a(node, parentNode);
        }
        // Remove tref with empty xlink:href attribute
        if (
          tref &&
          node.name === 'tref' &&
          node.attributes['xlink:href'] == null
        ) {
          detachNodeFromParent$a(node, parentNode);
        }
      },
    },
  };
};

var convertShapeToPath$1 = {};

/**
 * @typedef {import('../lib/types').PathDataItem} PathDataItem
 */

const { stringifyPathData: stringifyPathData$1 } = path;
const { detachNodeFromParent: detachNodeFromParent$9 } = xast;

convertShapeToPath$1.name = 'convertShapeToPath';
convertShapeToPath$1.type = 'visitor';
convertShapeToPath$1.active = true;
convertShapeToPath$1.description = 'converts basic shapes to more compact path form';

const regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

/**
 * Converts basic shape to more compact path.
 * It also allows further optimizations like
 * combining paths with similar attributes.
 *
 * @see https://www.w3.org/TR/SVG11/shapes.html
 *
 * @author Lev Solntsev
 *
 * @type {import('../lib/types').Plugin<{
 *   convertArcs?: boolean,
 *   floatPrecision?: number
 * }>}
 */
convertShapeToPath$1.fn = (root, params) => {
  const { convertArcs = false, floatPrecision: precision } = params;

  return {
    element: {
      enter: (node, parentNode) => {
        // convert rect to path
        if (
          node.name === 'rect' &&
          node.attributes.width != null &&
          node.attributes.height != null &&
          node.attributes.rx == null &&
          node.attributes.ry == null
        ) {
          const x = Number(node.attributes.x || '0');
          const y = Number(node.attributes.y || '0');
          const width = Number(node.attributes.width);
          const height = Number(node.attributes.height);
          // Values like '100%' compute to NaN, thus running after
          // cleanupNumericValues when 'px' units has already been removed.
          // TODO: Calculate sizes from % and non-px units if possible.
          if (Number.isNaN(x - y + width - height)) return;
          /**
           * @type {Array<PathDataItem>}
           */
          const pathData = [
            { command: 'M', args: [x, y] },
            { command: 'H', args: [x + width] },
            { command: 'V', args: [y + height] },
            { command: 'H', args: [x] },
            { command: 'z', args: [] },
          ];
          node.name = 'path';
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.x;
          delete node.attributes.y;
          delete node.attributes.width;
          delete node.attributes.height;
        }

        // convert line to path
        if (node.name === 'line') {
          const x1 = Number(node.attributes.x1 || '0');
          const y1 = Number(node.attributes.y1 || '0');
          const x2 = Number(node.attributes.x2 || '0');
          const y2 = Number(node.attributes.y2 || '0');
          if (Number.isNaN(x1 - y1 + x2 - y2)) return;
          /**
           * @type {Array<PathDataItem>}
           */
          const pathData = [
            { command: 'M', args: [x1, y1] },
            { command: 'L', args: [x2, y2] },
          ];
          node.name = 'path';
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.x1;
          delete node.attributes.y1;
          delete node.attributes.x2;
          delete node.attributes.y2;
        }

        // convert polyline and polygon to path
        if (
          (node.name === 'polyline' || node.name === 'polygon') &&
          node.attributes.points != null
        ) {
          const coords = (node.attributes.points.match(regNumber) || []).map(
            Number
          );
          if (coords.length < 4) {
            detachNodeFromParent$9(node, parentNode);
            return;
          }
          /**
           * @type {Array<PathDataItem>}
           */
          const pathData = [];
          for (let i = 0; i < coords.length; i += 2) {
            pathData.push({
              command: i === 0 ? 'M' : 'L',
              args: coords.slice(i, i + 2),
            });
          }
          if (node.name === 'polygon') {
            pathData.push({ command: 'z', args: [] });
          }
          node.name = 'path';
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.points;
        }

        //  optionally convert circle
        if (node.name === 'circle' && convertArcs) {
          const cx = Number(node.attributes.cx || '0');
          const cy = Number(node.attributes.cy || '0');
          const r = Number(node.attributes.r || '0');
          if (Number.isNaN(cx - cy + r)) {
            return;
          }
          /**
           * @type {Array<PathDataItem>}
           */
          const pathData = [
            { command: 'M', args: [cx, cy - r] },
            { command: 'A', args: [r, r, 0, 1, 0, cx, cy + r] },
            { command: 'A', args: [r, r, 0, 1, 0, cx, cy - r] },
            { command: 'z', args: [] },
          ];
          node.name = 'path';
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.cx;
          delete node.attributes.cy;
          delete node.attributes.r;
        }

        // optionally covert ellipse
        if (node.name === 'ellipse' && convertArcs) {
          const ecx = Number(node.attributes.cx || '0');
          const ecy = Number(node.attributes.cy || '0');
          const rx = Number(node.attributes.rx || '0');
          const ry = Number(node.attributes.ry || '0');
          if (Number.isNaN(ecx - ecy + rx - ry)) {
            return;
          }
          /**
           * @type {Array<PathDataItem>}
           */
          const pathData = [
            { command: 'M', args: [ecx, ecy - ry] },
            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
            { command: 'z', args: [] },
          ];
          node.name = 'path';
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.cx;
          delete node.attributes.cy;
          delete node.attributes.rx;
          delete node.attributes.ry;
        }
      },
    },
  };
};

var convertEllipseToCircle$1 = {};

convertEllipseToCircle$1.name = 'convertEllipseToCircle';
convertEllipseToCircle$1.type = 'visitor';
convertEllipseToCircle$1.active = true;
convertEllipseToCircle$1.description = 'converts non-eccentric <ellipse>s to <circle>s';

/**
 * Converts non-eccentric <ellipse>s to <circle>s.
 *
 * @see https://www.w3.org/TR/SVG11/shapes.html
 *
 * @author Taylor Hunt
 *
 * @type {import('../lib/types').Plugin<void>}
 */
convertEllipseToCircle$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        if (node.name === 'ellipse') {
          const rx = node.attributes.rx || '0';
          const ry = node.attributes.ry || '0';
          if (
            rx === ry ||
            rx === 'auto' ||
            ry === 'auto' // SVG2
          ) {
            node.name = 'circle';
            const radius = rx === 'auto' ? ry : rx;
            delete node.attributes.rx;
            delete node.attributes.ry;
            node.attributes.r = radius;
          }
        }
      },
    },
  };
};

var moveElemsAttrsToGroup$1 = {};

const { visit } = xast;
const { inheritableAttrs: inheritableAttrs$1, pathElems: pathElems$2 } = _collections;

moveElemsAttrsToGroup$1.type = 'visitor';
moveElemsAttrsToGroup$1.name = 'moveElemsAttrsToGroup';
moveElemsAttrsToGroup$1.active = true;
moveElemsAttrsToGroup$1.description = 'Move common attributes of group children to the group';

/**
 * Move common attributes of group children to the group
 *
 * @example
 * <g attr1="val1">
 *     <g attr2="val2">
 *         text
 *     </g>
 *     <circle attr2="val2" attr3="val3"/>
 * </g>
 *              â¬‡
 * <g attr1="val1" attr2="val2">
 *     <g>
 *         text
 *     </g>
 *    <circle attr3="val3"/>
 * </g>
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
moveElemsAttrsToGroup$1.fn = (root) => {
  // find if any style element is present
  let deoptimizedWithStyles = false;
  visit(root, {
    element: {
      enter: (node) => {
        if (node.name === 'style') {
          deoptimizedWithStyles = true;
        }
      },
    },
  });

  return {
    element: {
      exit: (node) => {
        // process only groups with more than 1 children
        if (node.name !== 'g' || node.children.length <= 1) {
          return;
        }

        // deoptimize the plugin when style elements are present
        // selectors may rely on id, classes or tag names
        if (deoptimizedWithStyles) {
          return;
        }

        /**
         * find common attributes in group children
         * @type {Map<string, string>}
         */
        const commonAttributes = new Map();
        let initial = true;
        let everyChildIsPath = true;
        for (const child of node.children) {
          if (child.type === 'element') {
            if (pathElems$2.includes(child.name) === false) {
              everyChildIsPath = false;
            }
            if (initial) {
              initial = false;
              // collect all inheritable attributes from first child element
              for (const [name, value] of Object.entries(child.attributes)) {
                // consider only inheritable attributes
                if (inheritableAttrs$1.includes(name)) {
                  commonAttributes.set(name, value);
                }
              }
            } else {
              // exclude uncommon attributes from initial list
              for (const [name, value] of commonAttributes) {
                if (child.attributes[name] !== value) {
                  commonAttributes.delete(name);
                }
              }
            }
          }
        }

        // preserve transform on children when group has clip-path or mask
        if (
          node.attributes['clip-path'] != null ||
          node.attributes.mask != null
        ) {
          commonAttributes.delete('transform');
        }

        // preserve transform when all children are paths
        // so the transform could be applied to path data by other plugins
        if (everyChildIsPath) {
          commonAttributes.delete('transform');
        }

        // add common children attributes to group
        for (const [name, value] of commonAttributes) {
          if (name === 'transform') {
            if (node.attributes.transform != null) {
              node.attributes.transform = `${node.attributes.transform} ${value}`;
            } else {
              node.attributes.transform = value;
            }
          } else {
            node.attributes[name] = value;
          }
        }

        // delete common attributes from children
        for (const child of node.children) {
          if (child.type === 'element') {
            for (const [name] of commonAttributes) {
              delete child.attributes[name];
            }
          }
        }
      },
    },
  };
};

var moveGroupAttrsToElems$1 = {};

const { pathElems: pathElems$1, referencesProps: referencesProps$2 } = _collections;

moveGroupAttrsToElems$1.name = 'moveGroupAttrsToElems';

moveGroupAttrsToElems$1.type = 'perItem';

moveGroupAttrsToElems$1.active = true;

moveGroupAttrsToElems$1.description = 'moves some group attributes to the content elements';

const pathElemsWithGroupsAndText = [...pathElems$1, 'g', 'text'];

/**
 * Move group attrs to the content elements.
 *
 * @example
 * <g transform="scale(2)">
 *     <path transform="rotate(45)" d="M0,0 L10,20"/>
 *     <path transform="translate(10, 20)" d="M0,10 L20,30"/>
 * </g>
 *                          â¬‡
 * <g>
 *     <path transform="scale(2) rotate(45)" d="M0,0 L10,20"/>
 *     <path transform="scale(2) translate(10, 20)" d="M0,10 L20,30"/>
 * </g>
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
moveGroupAttrsToElems$1.fn = function (item) {
  // move group transform attr to content's pathElems
  if (
    item.type === 'element' &&
    item.name === 'g' &&
    item.children.length !== 0 &&
    item.attributes.transform != null &&
    Object.entries(item.attributes).some(
      ([name, value]) =>
        referencesProps$2.includes(name) && value.includes('url(')
    ) === false &&
    item.children.every(
      (inner) =>
        pathElemsWithGroupsAndText.includes(inner.name) &&
        inner.attributes.id == null
    )
  ) {
    for (const inner of item.children) {
      const value = item.attributes.transform;
      if (inner.attributes.transform != null) {
        inner.attributes.transform = value + ' ' + inner.attributes.transform;
      } else {
        inner.attributes.transform = value;
      }
    }

    delete item.attributes.transform;
  }
};

var collapseGroups$1 = {};

/**
 * @typedef {import('../lib/types').XastNode} XastNode
 */

const { inheritableAttrs, elemsGroups: elemsGroups$1 } = _collections;

collapseGroups$1.type = 'visitor';
collapseGroups$1.name = 'collapseGroups';
collapseGroups$1.active = true;
collapseGroups$1.description = 'collapses useless groups';

/**
 * @type {(node: XastNode, name: string) => boolean}
 */
const hasAnimatedAttr = (node, name) => {
  if (node.type === 'element') {
    if (
      elemsGroups$1.animation.includes(node.name) &&
      node.attributes.attributeName === name
    ) {
      return true;
    }
    for (const child of node.children) {
      if (hasAnimatedAttr(child, name)) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Collapse useless groups.
 *
 * @example
 * <g>
 *     <g attr1="val1">
 *         <path d="..."/>
 *     </g>
 * </g>
 *         â¬‡
 * <g>
 *     <g>
 *         <path attr1="val1" d="..."/>
 *     </g>
 * </g>
 *         â¬‡
 * <path attr1="val1" d="..."/>
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
collapseGroups$1.fn = () => {
  return {
    element: {
      exit: (node, parentNode) => {
        if (parentNode.type === 'root' || parentNode.name === 'switch') {
          return;
        }
        // non-empty groups
        if (node.name !== 'g' || node.children.length === 0) {
          return;
        }

        // move group attibutes to the single child element
        if (
          Object.keys(node.attributes).length !== 0 &&
          node.children.length === 1
        ) {
          const firstChild = node.children[0];
          // TODO untangle this mess
          if (
            firstChild.type === 'element' &&
            firstChild.attributes.id == null &&
            node.attributes.filter == null &&
            (node.attributes.class == null ||
              firstChild.attributes.class == null) &&
            ((node.attributes['clip-path'] == null &&
              node.attributes.mask == null) ||
              (firstChild.name === 'g' &&
                node.attributes.transform == null &&
                firstChild.attributes.transform == null))
          ) {
            for (const [name, value] of Object.entries(node.attributes)) {
              // avoid copying to not conflict with animated attribute
              if (hasAnimatedAttr(firstChild, name)) {
                return;
              }
              if (firstChild.attributes[name] == null) {
                firstChild.attributes[name] = value;
              } else if (name === 'transform') {
                firstChild.attributes[name] =
                  value + ' ' + firstChild.attributes[name];
              } else if (firstChild.attributes[name] === 'inherit') {
                firstChild.attributes[name] = value;
              } else if (
                inheritableAttrs.includes(name) === false &&
                firstChild.attributes[name] !== value
              ) {
                return;
              }
              delete node.attributes[name];
            }
          }
        }

        // collapse groups without attributes
        if (Object.keys(node.attributes).length === 0) {
          // animation elements "add" attributes to group
          // group should be preserved
          for (const child of node.children) {
            if (
              child.type === 'element' &&
              elemsGroups$1.animation.includes(child.name)
            ) {
              return;
            }
          }
          // replace current node with all its children
          const index = parentNode.children.indexOf(node);
          parentNode.children.splice(index, 1, ...node.children);
          // TODO remove in v3
          for (const child of node.children) {
            // @ts-ignore parentNode is forbidden for public usage
            // and will be moved in v3
            child.parentNode = parentNode;
          }
        }
      },
    },
  };
};

var convertPathData$1 = {};

var _path = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').PathDataItem} PathDataItem
 */

const { parsePathData: parsePathData$1, stringifyPathData } = path;

/**
 * @type {[number, number]}
 */
var prevCtrlPoint;

/**
 * Convert path string to JS representation.
 *
 * @type {(path: XastElement) => Array<PathDataItem>}
 */
const path2js$2 = (path) => {
  // @ts-ignore legacy
  if (path.pathJS) return path.pathJS;
  /**
   * @type {Array<PathDataItem>}
   */
  const pathData = []; // JS representation of the path data
  const newPathData = parsePathData$1(path.attributes.d);
  for (const { command, args } of newPathData) {
    pathData.push({ command, args });
  }
  // First moveto is actually absolute. Subsequent coordinates were separated above.
  if (pathData.length && pathData[0].command == 'm') {
    pathData[0].command = 'M';
  }
  // @ts-ignore legacy
  path.pathJS = pathData;
  return pathData;
};
_path.path2js = path2js$2;

/**
 * Convert relative Path data to absolute.
 *
 * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}
 *
 */
const convertRelativeToAbsolute = (data) => {
  /**
   * @type {Array<PathDataItem>}
   */
  const newData = [];
  let start = [0, 0];
  let cursor = [0, 0];

  for (let { command, args } of data) {
    args = args.slice();

    // moveto (x y)
    if (command === 'm') {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = 'M';
    }
    if (command === 'M') {
      cursor[0] = args[0];
      cursor[1] = args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }

    // horizontal lineto (x)
    if (command === 'h') {
      args[0] += cursor[0];
      command = 'H';
    }
    if (command === 'H') {
      cursor[0] = args[0];
    }

    // vertical lineto (y)
    if (command === 'v') {
      args[0] += cursor[1];
      command = 'V';
    }
    if (command === 'V') {
      cursor[1] = args[0];
    }

    // lineto (x y)
    if (command === 'l') {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = 'L';
    }
    if (command === 'L') {
      cursor[0] = args[0];
      cursor[1] = args[1];
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === 'c') {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      args[4] += cursor[0];
      args[5] += cursor[1];
      command = 'C';
    }
    if (command === 'C') {
      cursor[0] = args[4];
      cursor[1] = args[5];
    }

    // smooth curveto (x2 y2 x y)
    if (command === 's') {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      command = 'S';
    }
    if (command === 'S') {
      cursor[0] = args[2];
      cursor[1] = args[3];
    }

    // quadratic BÃ©zier curveto (x1 y1 x y)
    if (command === 'q') {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      command = 'Q';
    }
    if (command === 'Q') {
      cursor[0] = args[2];
      cursor[1] = args[3];
    }

    // smooth quadratic BÃ©zier curveto (x y)
    if (command === 't') {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = 'T';
    }
    if (command === 'T') {
      cursor[0] = args[0];
      cursor[1] = args[1];
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === 'a') {
      args[5] += cursor[0];
      args[6] += cursor[1];
      command = 'A';
    }
    if (command === 'A') {
      cursor[0] = args[5];
      cursor[1] = args[6];
    }

    // closepath
    if (command === 'z' || command === 'Z') {
      cursor[0] = start[0];
      cursor[1] = start[1];
      command = 'z';
    }

    newData.push({ command, args });
  }
  return newData;
};

/**
 * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams
 */

/**
 * Convert path array to string.
 *
 * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}
 */
_path.js2path = function (path, data, params) {
  // @ts-ignore legacy
  path.pathJS = data;

  const pathData = [];
  for (const item of data) {
    // remove moveto commands which are followed by moveto commands
    if (
      pathData.length !== 0 &&
      (item.command === 'M' || item.command === 'm')
    ) {
      const last = pathData[pathData.length - 1];
      if (last.command === 'M' || last.command === 'm') {
        pathData.pop();
      }
    }
    pathData.push({
      command: item.command,
      args: item.args,
    });
  }

  path.attributes.d = stringifyPathData({
    pathData,
    precision: params.floatPrecision,
    disableSpaceAfterFlags: params.noSpaceAfterFlags,
  });
};

/**
 * @type {(dest: Array<number>, source: Array<number>) => Array<number>}
 */
function set(dest, source) {
  dest[0] = source[source.length - 2];
  dest[1] = source[source.length - 1];
  return dest;
}

/**
 * Checks if two paths have an intersection by checking convex hulls
 * collision using Gilbert-Johnson-Keerthi distance algorithm
 * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/
 *
 * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}
 */
_path.intersects = function (path1, path2) {
  // Collect points of every subpath.
  const points1 = gatherPoints(convertRelativeToAbsolute(path1));
  const points2 = gatherPoints(convertRelativeToAbsolute(path2));

  // Axis-aligned bounding box check.
  if (
    points1.maxX <= points2.minX ||
    points2.maxX <= points1.minX ||
    points1.maxY <= points2.minY ||
    points2.maxY <= points1.minY ||
    points1.list.every((set1) => {
      return points2.list.every((set2) => {
        return (
          set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||
          set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||
          set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||
          set2.list[set2.maxY][1] <= set1.list[set1.minY][1]
        );
      });
    })
  )
    return false;

  // Get a convex hull from points of each subpath. Has the most complexity O(nÂ·log n).
  const hullNest1 = points1.list.map(convexHull);
  const hullNest2 = points2.list.map(convexHull);

  // Check intersection of every subpath of the first path with every subpath of the second.
  return hullNest1.some(function (hull1) {
    if (hull1.list.length < 3) return false;

    return hullNest2.some(function (hull2) {
      if (hull2.list.length < 3) return false;

      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex
        direction = minus(simplex[0]); // set the direction to point towards the origin

      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough
      // eslint-disable-next-line no-constant-condition
      while (true) {
        // eslint-disable-next-line no-constant-condition
        if (iterations-- == 0) {
          console.error(
            'Error: infinite loop while processing mergePaths plugin.'
          );
          return true; // true is the safe value that means â€œdo nothing with pathsâ€
        }
        // add a new point
        simplex.push(getSupport(hull1, hull2, direction));
        // see if the new point was on the correct side of the origin
        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;
        // process the simplex
        if (processSimplex(simplex, direction)) return true;
      }
    });
  });

  /**
   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}
   */
  function getSupport(a, b, direction) {
    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
  }

  // Computes farthest polygon point in particular direction.
  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.
  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.
  /**
   * @type {(polygon: Point, direction: Array<number>) => Array<number>}
   */
  function supportPoint(polygon, direction) {
    var index =
        direction[1] >= 0
          ? direction[0] < 0
            ? polygon.maxY
            : polygon.maxX
          : direction[0] < 0
          ? polygon.minX
          : polygon.minY,
      max = -Infinity,
      value;
    while ((value = dot(polygon.list[index], direction)) > max) {
      max = value;
      index = ++index % polygon.list.length;
    }
    return polygon.list[(index || polygon.list.length) - 1];
  }
};

/**
 * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}
 */
function processSimplex(simplex, direction) {
  // we only need to handle to 1-simplex and 2-simplex
  if (simplex.length == 2) {
    // 1-simplex
    let a = simplex[1],
      b = simplex[0],
      AO = minus(simplex[1]),
      AB = sub(b, a);
    // AO is in the same direction as AB
    if (dot(AO, AB) > 0) {
      // get the vector perpendicular to AB facing O
      set(direction, orth(AB, a));
    } else {
      set(direction, AO);
      // only A remains in the simplex
      simplex.shift();
    }
  } else {
    // 2-simplex
    let a = simplex[2], // [a, b, c] = simplex
      b = simplex[1],
      c = simplex[0],
      AB = sub(b, a),
      AC = sub(c, a),
      AO = minus(a),
      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C
      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B

    if (dot(ACB, AO) > 0) {
      if (dot(AB, AO) > 0) {
        // region 4
        set(direction, ACB);
        simplex.shift(); // simplex = [b, a]
      } else {
        // region 5
        set(direction, AO);
        simplex.splice(0, 2); // simplex = [a]
      }
    } else if (dot(ABC, AO) > 0) {
      if (dot(AC, AO) > 0) {
        // region 6
        set(direction, ABC);
        simplex.splice(1, 1); // simplex = [c, a]
      } else {
        // region 5 (again)
        set(direction, AO);
        simplex.splice(0, 2); // simplex = [a]
      }
    } // region 7
    else return true;
  }
  return false;
}

/**
 * @type {(v: Array<number>) => Array<number>}
 */
function minus(v) {
  return [-v[0], -v[1]];
}

/**
 * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}
 */
function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}

/**
 * @type {(v1: Array<number>, v2: Array<number>) => number}
 */
function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}

/**
 * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}
 */
function orth(v, from) {
  var o = [-v[1], v[0]];
  return dot(o, minus(from)) < 0 ? minus(o) : o;
}

/**
 * @typedef {{
 *   list: Array<Array<number>>,
 *   minX: number,
 *   minY: number,
 *   maxX: number,
 *   maxY: number
 * }} Point
 */

/**
 * @typedef {{
 *   list: Array<Point>,
 *   minX: number,
 *   minY: number,
 *   maxX: number,
 *   maxY: number
 * }} Points
 */

/**
 * @type {(pathData: Array<PathDataItem>) => Points}
 */
function gatherPoints(pathData) {
  /**
   * @type {Points}
   */
  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };

  // Writes data about the extreme points on each axle
  /**
   * @type {(path: Point, point: Array<number>) => void}
   */
  const addPoint = (path, point) => {
    if (!path.list.length || point[1] > path.list[path.maxY][1]) {
      path.maxY = path.list.length;
      points.maxY = points.list.length
        ? Math.max(point[1], points.maxY)
        : point[1];
    }
    if (!path.list.length || point[0] > path.list[path.maxX][0]) {
      path.maxX = path.list.length;
      points.maxX = points.list.length
        ? Math.max(point[0], points.maxX)
        : point[0];
    }
    if (!path.list.length || point[1] < path.list[path.minY][1]) {
      path.minY = path.list.length;
      points.minY = points.list.length
        ? Math.min(point[1], points.minY)
        : point[1];
    }
    if (!path.list.length || point[0] < path.list[path.minX][0]) {
      path.minX = path.list.length;
      points.minX = points.list.length
        ? Math.min(point[0], points.minX)
        : point[0];
    }
    path.list.push(point);
  };

  for (let i = 0; i < pathData.length; i += 1) {
    const pathDataItem = pathData[i];
    let subPath =
      points.list.length === 0
        ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }
        : points.list[points.list.length - 1];
    let prev = i === 0 ? null : pathData[i - 1];
    let basePoint =
      subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
    let data = pathDataItem.args;
    let ctrlPoint = basePoint;

    /**
     * @type {(n: number, i: number) => number}
     * TODO fix null hack
     */
    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);

    switch (pathDataItem.command) {
      case 'M':
        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
        points.list.push(subPath);
        break;

      case 'H':
        if (basePoint != null) {
          addPoint(subPath, [data[0], basePoint[1]]);
        }
        break;

      case 'V':
        if (basePoint != null) {
          addPoint(subPath, [basePoint[0], data[0]]);
        }
        break;

      case 'Q':
        addPoint(subPath, data.slice(0, 2));
        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand
        break;

      case 'T':
        if (
          basePoint != null &&
          prev != null &&
          (prev.command == 'Q' || prev.command == 'T')
        ) {
          ctrlPoint = [
            basePoint[0] + prevCtrlPoint[0],
            basePoint[1] + prevCtrlPoint[1],
          ];
          addPoint(subPath, ctrlPoint);
          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
        }
        break;

      case 'C':
        if (basePoint != null) {
          // Approximate quibic Bezier curve with middle points between control points
          addPoint(subPath, [
            0.5 * (basePoint[0] + data[0]),
            0.5 * (basePoint[1] + data[1]),
          ]);
        }
        addPoint(subPath, [
          0.5 * (data[0] + data[2]),
          0.5 * (data[1] + data[3]),
        ]);
        addPoint(subPath, [
          0.5 * (data[2] + data[4]),
          0.5 * (data[3] + data[5]),
        ]);
        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand
        break;

      case 'S':
        if (
          basePoint != null &&
          prev != null &&
          (prev.command == 'C' || prev.command == 'S')
        ) {
          addPoint(subPath, [
            basePoint[0] + 0.5 * prevCtrlPoint[0],
            basePoint[1] + 0.5 * prevCtrlPoint[1],
          ]);
          ctrlPoint = [
            basePoint[0] + prevCtrlPoint[0],
            basePoint[1] + prevCtrlPoint[1],
          ];
        }
        if (ctrlPoint != null) {
          addPoint(subPath, [
            0.5 * (ctrlPoint[0] + data[0]),
            0.5 * (ctrlPoint[1] + data[1]),
          ]);
        }
        addPoint(subPath, [
          0.5 * (data[0] + data[2]),
          0.5 * (data[1] + data[3]),
        ]);
        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
        break;

      case 'A':
        if (basePoint != null) {
          // Convert the arc to bezier curves and use the same approximation
          // @ts-ignore no idea what's going on here
          var curves = a2c.apply(0, basePoint.concat(data));
          for (
            var cData;
            (cData = curves.splice(0, 6).map(toAbsolute)).length;

          ) {
            if (basePoint != null) {
              addPoint(subPath, [
                0.5 * (basePoint[0] + cData[0]),
                0.5 * (basePoint[1] + cData[1]),
              ]);
            }
            addPoint(subPath, [
              0.5 * (cData[0] + cData[2]),
              0.5 * (cData[1] + cData[3]),
            ]);
            addPoint(subPath, [
              0.5 * (cData[2] + cData[4]),
              0.5 * (cData[3] + cData[5]),
            ]);
            if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));
          }
        }
        break;
    }

    // Save final command coordinates
    if (data.length >= 2) addPoint(subPath, data.slice(-2));
  }

  return points;
}

/**
 * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.
 * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
 *
 * @type {(points: Point) => Point}
 */
function convexHull(points) {
  points.list.sort(function (a, b) {
    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
  });

  var lower = [],
    minY = 0,
    bottom = 0;
  for (let i = 0; i < points.list.length; i++) {
    while (
      lower.length >= 2 &&
      cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <=
        0
    ) {
      lower.pop();
    }
    if (points.list[i][1] < points.list[minY][1]) {
      minY = i;
      bottom = lower.length;
    }
    lower.push(points.list[i]);
  }

  var upper = [],
    maxY = points.list.length - 1,
    top = 0;
  for (let i = points.list.length; i--; ) {
    while (
      upper.length >= 2 &&
      cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <=
        0
    ) {
      upper.pop();
    }
    if (points.list[i][1] > points.list[maxY][1]) {
      maxY = i;
      top = upper.length;
    }
    upper.push(points.list[i]);
  }

  // last points are equal to starting points of the other part
  upper.pop();
  lower.pop();

  const hullList = lower.concat(upper);

  /**
   * @type {Point}
   */
  const hull = {
    list: hullList,
    minX: 0, // by sorting
    maxX: lower.length,
    minY: bottom,
    maxY: (lower.length + top) % hullList.length,
  };

  return hull;
}

/**
 * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}
 */
function cross(o, a, b) {
  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}

/**
 * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/
 * Thanks to Dmitry Baranovskiy for his great work!
 *
 * @type {(
 *  x1: number,
 *  y1: number,
 *  rx: number,
 *  ry: number,
 *  angle: number,
 *  large_arc_flag: number,
 *  sweep_flag: number,
 *  x2: number,
 *  y2: number,
 *  recursive: Array<number>
 * ) => Array<number>}
 */
const a2c = (
  x1,
  y1,
  rx,
  ry,
  angle,
  large_arc_flag,
  sweep_flag,
  x2,
  y2,
  recursive
) => {
  // for more information of where this Math came from visit:
  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  const _120 = (Math.PI * 120) / 180;
  const rad = (Math.PI / 180) * (+angle || 0);
  /**
   * @type {Array<number>}
   */
  let res = [];
  /**
   * @type {(x: number, y: number, rad: number) => number}
   */
  const rotateX = (x, y, rad) => {
    return x * Math.cos(rad) - y * Math.sin(rad);
  };
  /**
   * @type {(x: number, y: number, rad: number) => number}
   */
  const rotateY = (x, y, rad) => {
    return x * Math.sin(rad) + y * Math.cos(rad);
  };
  if (!recursive) {
    x1 = rotateX(x1, y1, -rad);
    y1 = rotateY(x1, y1, -rad);
    x2 = rotateX(x2, y2, -rad);
    y2 = rotateY(x2, y2, -rad);
    var x = (x1 - x2) / 2,
      y = (y1 - y2) / 2;
    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k =
      (large_arc_flag == sweep_flag ? -1 : 1) *
      Math.sqrt(
        Math.abs(
          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)
        )
      );
    var cx = (k * rx * y) / ry + (x1 + x2) / 2;
    var cy = (k * -ry * x) / rx + (y1 + y2) / 2;
    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));

    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2,
      x2old = x2,
      y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
      f2,
      f2old,
      cx,
      cy,
    ]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1),
    s1 = Math.sin(f1),
    c2 = Math.cos(f2),
    s2 = Math.sin(f2),
    t = Math.tan(df / 4),
    hx = (4 / 3) * rx * t,
    hy = (4 / 3) * ry * t,
    m = [
      -hx * s1,
      hy * c1,
      x2 + hx * s2 - x1,
      y2 - hy * c2 - y1,
      x2 - x1,
      y2 - y1,
    ];
  if (recursive) {
    return m.concat(res);
  } else {
    res = m.concat(res);
    var newres = [];
    for (var i = 0, n = res.length; i < n; i++) {
      newres[i] =
        i % 2
          ? rotateY(res[i - 1], res[i], rad)
          : rotateX(res[i], res[i + 1], rad);
    }
    return newres;
  }
};

var _applyTransforms = {};

var _transforms = {};

const regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;
const regTransformSplit =
  /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
const regNumericValues$2 = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

/**
 * @typedef {{ name: string, data: Array<number> }} TransformItem
 */

/**
 * Convert transform string to JS representation.
 *
 * @type {(transformString: string) => Array<TransformItem>}
 */
_transforms.transform2js = (transformString) => {
  // JS representation of the transform data
  /**
   * @type {Array<TransformItem>}
   */
  const transforms = [];
  // current transform context
  /**
   * @type {null | TransformItem}
   */
  let current = null;
  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']
  for (const item of transformString.split(regTransformSplit)) {
    var num;
    if (item) {
      // if item is a translate function
      if (regTransformTypes.test(item)) {
        // then collect it and change current context
        current = { name: item, data: [] };
        transforms.push(current);
        // else if item is data
      } else {
        // then split it into [10, 50] and collect as context.data
        // eslint-disable-next-line no-cond-assign
        while ((num = regNumericValues$2.exec(item))) {
          num = Number(num);
          if (current != null) {
            current.data.push(num);
          }
        }
      }
    }
  }
  // return empty array if broken transform (no data)
  return current == null || current.data.length == 0 ? [] : transforms;
};

/**
 * Multiply transforms into one.
 *
 * @type {(transforms: Array<TransformItem>) => TransformItem}
 */
_transforms.transformsMultiply = (transforms) => {
  // convert transforms objects to the matrices
  const matrixData = transforms.map((transform) => {
    if (transform.name === 'matrix') {
      return transform.data;
    }
    return transformToMatrix(transform);
  });
  // multiply all matrices into one
  const matrixTransform = {
    name: 'matrix',
    data:
      matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : [],
  };
  return matrixTransform;
};

/**
 * math utilities in radians.
 */
const mth = {
  /**
   * @type {(deg: number) => number}
   */
  rad: (deg) => {
    return (deg * Math.PI) / 180;
  },

  /**
   * @type {(rad: number) => number}
   */
  deg: (rad) => {
    return (rad * 180) / Math.PI;
  },

  /**
   * @type {(deg: number) => number}
   */
  cos: (deg) => {
    return Math.cos(mth.rad(deg));
  },

  /**
   * @type {(val: number, floatPrecision: number) => number}
   */
  acos: (val, floatPrecision) => {
    return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));
  },

  /**
   * @type {(deg: number) => number}
   */
  sin: (deg) => {
    return Math.sin(mth.rad(deg));
  },

  /**
   * @type {(val: number, floatPrecision: number) => number}
   */
  asin: (val, floatPrecision) => {
    return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));
  },

  /**
   * @type {(deg: number) => number}
   */
  tan: (deg) => {
    return Math.tan(mth.rad(deg));
  },

  /**
   * @type {(val: number, floatPrecision: number) => number}
   */
  atan: (val, floatPrecision) => {
    return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));
  },
};

/**
 * @typedef {{
 *   convertToShorts: boolean,
 *   floatPrecision: number,
 *   transformPrecision: number,
 *   matrixToTransform: boolean,
 *   shortTranslate: boolean,
 *   shortScale: boolean,
 *   shortRotate: boolean,
 *   removeUseless: boolean,
 *   collapseIntoOne: boolean,
 *   leadingZero: boolean,
 *   negativeExtraSpace: boolean,
 * }} TransformParams
 */

/**
 * Decompose matrix into simple transforms. See
 * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html
 *
 * @type {(transform: TransformItem, params: TransformParams) => Array<TransformItem>}
 */
_transforms.matrixToTransform = (transform, params) => {
  let floatPrecision = params.floatPrecision;
  let data = transform.data;
  let transforms = [];
  let sx = Number(
    Math.hypot(data[0], data[1]).toFixed(params.transformPrecision)
  );
  let sy = Number(
    ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(
      params.transformPrecision
    )
  );
  let colsSum = data[0] * data[2] + data[1] * data[3];
  let rowsSum = data[0] * data[1] + data[2] * data[3];
  let scaleBefore = rowsSum != 0 || sx == sy;

  // [..., ..., ..., ..., tx, ty] â†’ translate(tx, ty)
  if (data[4] || data[5]) {
    transforms.push({
      name: 'translate',
      data: data.slice(4, data[5] ? 6 : 5),
    });
  }

  // [sx, 0, tan(a)Â·sy, sy, 0, 0] â†’ skewX(a)Â·scale(sx, sy)
  if (!data[1] && data[2]) {
    transforms.push({
      name: 'skewX',
      data: [mth.atan(data[2] / sy, floatPrecision)],
    });

    // [sx, sxÂ·tan(a), 0, sy, 0, 0] â†’ skewY(a)Â·scale(sx, sy)
  } else if (data[1] && !data[2]) {
    transforms.push({
      name: 'skewY',
      data: [mth.atan(data[1] / data[0], floatPrecision)],
    });
    sx = data[0];
    sy = data[3];

    // [sxÂ·cos(a), sxÂ·sin(a), syÂ·-sin(a), syÂ·cos(a), x, y] â†’ rotate(a[, cx, cy])Â·(scale or skewX) or
    // [sxÂ·cos(a), syÂ·sin(a), sxÂ·-sin(a), syÂ·cos(a), x, y] â†’ scale(sx, sy)Â·rotate(a[, cx, cy]) (if !scaleBefore)
  } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {
    if (!scaleBefore) {
      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);
      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);
      transforms.push({ name: 'scale', data: [sx, sy] });
    }
    var angle = Math.min(Math.max(-1, data[0] / sx), 1),
      rotate = [
        mth.acos(angle, floatPrecision) *
          ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),
      ];

    if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });

    if (rowsSum && colsSum)
      transforms.push({
        name: 'skewX',
        data: [mth.atan(colsSum / (sx * sx), floatPrecision)],
      });

    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)
    if (rotate[0] && (data[4] || data[5])) {
      transforms.shift();
      var cos = data[0] / sx,
        sin = data[1] / (scaleBefore ? sx : sy),
        x = data[4] * (scaleBefore ? 1 : sy),
        y = data[5] * (scaleBefore ? 1 : sx),
        denom =
          (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) *
          (scaleBefore ? 1 : sx * sy);
      rotate.push(((1 - cos) * x - sin * y) / denom);
      rotate.push(((1 - cos) * y + sin * x) / denom);
    }

    // Too many transformations, return original matrix if it isn't just a scale/translate
  } else if (data[1] || data[2]) {
    return [transform];
  }

  if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length)
    transforms.push({
      name: 'scale',
      data: sx == sy ? [sx] : [sx, sy],
    });

  return transforms;
};

/**
 * Convert transform to the matrix data.
 *
 * @type {(transform: TransformItem) => Array<number> }
 */
const transformToMatrix = (transform) => {
  if (transform.name === 'matrix') {
    return transform.data;
  }
  switch (transform.name) {
    case 'translate':
      // [1, 0, 0, 1, tx, ty]
      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
    case 'scale':
      // [sx, 0, 0, sy, 0, 0]
      return [
        transform.data[0],
        0,
        0,
        transform.data[1] || transform.data[0],
        0,
        0,
      ];
    case 'rotate':
      // [cos(a), sin(a), -sin(a), cos(a), x, y]
      var cos = mth.cos(transform.data[0]),
        sin = mth.sin(transform.data[0]),
        cx = transform.data[1] || 0,
        cy = transform.data[2] || 0;
      return [
        cos,
        sin,
        -sin,
        cos,
        (1 - cos) * cx + sin * cy,
        (1 - cos) * cy - sin * cx,
      ];
    case 'skewX':
      // [1, 0, tan(a), 1, 0, 0]
      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
    case 'skewY':
      // [1, tan(a), 0, 1, 0, 0]
      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
    default:
      throw Error(`Unknown transform ${transform.name}`);
  }
};

/**
 * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it
 * by the transformation matrix and use a singular value decomposition to represent in a form
 * rotate(Î¸)Â·scale(a b)Â·rotate(Ï†). This gives us new ellipse params a, b and Î¸.
 * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})
 *
 * @type {(
 *   cursor: [x: number, y: number],
 *   arc: Array<number>,
 *   transform: Array<number>
 * ) => Array<number>}
 */
_transforms.transformArc = (cursor, arc, transform) => {
  const x = arc[5] - cursor[0];
  const y = arc[6] - cursor[1];
  let a = arc[0];
  let b = arc[1];
  const rot = (arc[2] * Math.PI) / 180;
  const cos = Math.cos(rot);
  const sin = Math.sin(rot);
  // skip if radius is 0
  if (a > 0 && b > 0) {
    let h =
      Math.pow(x * cos + y * sin, 2) / (4 * a * a) +
      Math.pow(y * cos - x * sin, 2) / (4 * b * b);
    if (h > 1) {
      h = Math.sqrt(h);
      a *= h;
      b *= h;
    }
  }
  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
  const m = multiplyTransformMatrices(transform, ellipse);
  // Decompose the new ellipse matrix
  const lastCol = m[2] * m[2] + m[3] * m[3];
  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
  const root =
    Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);

  if (!root) {
    // circle
    arc[0] = arc[1] = Math.sqrt(squareSum / 2);
    arc[2] = 0;
  } else {
    const majorAxisSqr = (squareSum + root) / 2;
    const minorAxisSqr = (squareSum - root) / 2;
    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
    const rowsSum = m[0] * m[2] + m[1] * m[3];
    const term1 = m[0] * sub + m[2] * rowsSum;
    const term2 = m[1] * sub + m[3] * rowsSum;
    arc[0] = Math.sqrt(majorAxisSqr);
    arc[1] = Math.sqrt(minorAxisSqr);
    arc[2] =
      (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *
        Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *
        180) /
      Math.PI;
  }

  if (transform[0] < 0 !== transform[3] < 0) {
    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically
    arc[4] = 1 - arc[4];
  }

  return arc;
};

/**
 * Multiply transformation matrices.
 *
 * @type {(a: Array<number>, b: Array<number>) => Array<number>}
 */
const multiplyTransformMatrices = (a, b) => {
  return [
    a[0] * b[0] + a[2] * b[1],
    a[1] * b[0] + a[3] * b[1],
    a[0] * b[2] + a[2] * b[3],
    a[1] * b[2] + a[3] * b[3],
    a[0] * b[4] + a[2] * b[5] + a[4],
    a[1] * b[4] + a[3] * b[5] + a[5],
  ];
};

// TODO implement as separate plugin

const {
  transformsMultiply: transformsMultiply$1,
  transform2js: transform2js$1,
  transformArc,
} = _transforms;
const { removeLeadingZero: removeLeadingZero$1 } = tools;
const { referencesProps: referencesProps$1, attrsGroupsDefaults } = _collections;

const regNumericValues$1 = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
const defaultStrokeWidth = attrsGroupsDefaults.presentation['stroke-width'];

/**
 * Apply transformation(s) to the Path data.
 *
 * @param {Object} elem current element
 * @param {Array} path input path data
 * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)
 * @return {Array} output path data
 */
const applyTransforms$1 = (elem, pathData, params) => {
  // if there are no 'stroke' attr and references to other objects such as
  // gradiends or clip-path which are also subjects to transform.
  if (
    elem.attributes.transform == null ||
    elem.attributes.transform === '' ||
    // styles are not considered when applying transform
    // can be fixed properly with new style engine
    elem.attributes.style != null ||
    Object.entries(elem.attributes).some(
      ([name, value]) =>
        referencesProps$1.includes(name) && value.includes('url(')
    )
  ) {
    return;
  }

  const matrix = transformsMultiply$1(transform2js$1(elem.attributes.transform));
  const stroke = elem.computedAttr('stroke');
  const id = elem.computedAttr('id');
  const transformPrecision = params.transformPrecision;

  if (stroke && stroke != 'none') {
    if (
      !params.applyTransformsStroked ||
      ((matrix.data[0] != matrix.data[3] ||
        matrix.data[1] != -matrix.data[2]) &&
        (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))
    )
      return;

    // "stroke-width" should be inside the part with ID, otherwise it can be overrided in <use>
    if (id) {
      let idElem = elem;
      let hasStrokeWidth = false;

      do {
        if (idElem.attributes['stroke-width']) {
          hasStrokeWidth = true;
        }
      } while (
        idElem.attributes.id !== id &&
        !hasStrokeWidth &&
        (idElem = idElem.parentNode)
      );

      if (!hasStrokeWidth) return;
    }

    const scale = +Math.sqrt(
      matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]
    ).toFixed(transformPrecision);

    if (scale !== 1) {
      const strokeWidth =
        elem.computedAttr('stroke-width') || defaultStrokeWidth;

      if (
        elem.attributes['vector-effect'] == null ||
        elem.attributes['vector-effect'] !== 'non-scaling-stroke'
      ) {
        if (elem.attributes['stroke-width'] != null) {
          elem.attributes['stroke-width'] = elem.attributes['stroke-width']
            .trim()
            .replace(regNumericValues$1, (num) => removeLeadingZero$1(num * scale));
        } else {
          elem.attributes['stroke-width'] = strokeWidth.replace(
            regNumericValues$1,
            (num) => removeLeadingZero$1(num * scale)
          );
        }

        if (elem.attributes['stroke-dashoffset'] != null) {
          elem.attributes['stroke-dashoffset'] = elem.attributes[
            'stroke-dashoffset'
          ]
            .trim()
            .replace(regNumericValues$1, (num) => removeLeadingZero$1(num * scale));
        }

        if (elem.attributes['stroke-dasharray'] != null) {
          elem.attributes['stroke-dasharray'] = elem.attributes[
            'stroke-dasharray'
          ]
            .trim()
            .replace(regNumericValues$1, (num) => removeLeadingZero$1(num * scale));
        }
      }
    }
  } else if (id) {
    // Stroke and stroke-width can be redefined with <use>
    return;
  }

  applyMatrixToPathData(pathData, matrix.data);

  // remove transform attr
  delete elem.attributes.transform;

  return;
};
_applyTransforms.applyTransforms = applyTransforms$1;

const transformAbsolutePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y + matrix[4];
  const newY = matrix[1] * x + matrix[3] * y + matrix[5];
  return [newX, newY];
};

const transformRelativePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y;
  const newY = matrix[1] * x + matrix[3] * y;
  return [newX, newY];
};

const applyMatrixToPathData = (pathData, matrix) => {
  const start = [0, 0];
  const cursor = [0, 0];

  for (const pathItem of pathData) {
    let { command, args } = pathItem;

    // moveto (x y)
    if (command === 'M') {
      cursor[0] = args[0];
      cursor[1] = args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === 'm') {
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // horizontal lineto (x)
    // convert to lineto to handle two-dimentional transforms
    if (command === 'H') {
      command = 'L';
      args = [args[0], cursor[1]];
    }
    if (command === 'h') {
      command = 'l';
      args = [args[0], 0];
    }

    // vertical lineto (y)
    // convert to lineto to handle two-dimentional transforms
    if (command === 'V') {
      command = 'L';
      args = [cursor[0], args[0]];
    }
    if (command === 'v') {
      command = 'l';
      args = [0, args[0]];
    }

    // lineto (x y)
    if (command === 'L') {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === 'l') {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === 'C') {
      cursor[0] = args[4];
      cursor[1] = args[5];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }
    if (command === 'c') {
      cursor[0] += args[4];
      cursor[1] += args[5];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }

    // smooth curveto (x2 y2 x y)
    if (command === 'S') {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }
    if (command === 's') {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }

    // quadratic BÃ©zier curveto (x1 y1 x y)
    if (command === 'Q') {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }
    if (command === 'q') {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }

    // smooth quadratic BÃ©zier curveto (x y)
    if (command === 'T') {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === 't') {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === 'A') {
      transformArc(cursor, args, matrix);
      cursor[0] = args[5];
      cursor[1] = args[6];
      // reduce number of digits in rotation angle
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }
    if (command === 'a') {
      transformArc([0, 0], args, matrix);
      cursor[0] += args[5];
      cursor[1] += args[6];
      // reduce number of digits in rotation angle
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }

    // closepath
    if (command === 'z' || command === 'Z') {
      cursor[0] = start[0];
      cursor[1] = start[1];
    }

    pathItem.command = command;
    pathItem.args = args;
  }
};

const { collectStylesheet: collectStylesheet$1, computeStyle: computeStyle$1 } = style;
const { pathElems } = _collections;
const { path2js: path2js$1, js2path: js2path$1 } = _path;
const { applyTransforms } = _applyTransforms;
const { cleanupOutData: cleanupOutData$1 } = tools;

convertPathData$1.name = 'convertPathData';
convertPathData$1.type = 'visitor';
convertPathData$1.active = true;
convertPathData$1.description =
  'optimizes path data: writes in shorter form, applies transformations';

convertPathData$1.params = {
  applyTransforms: true,
  applyTransformsStroked: true,
  makeArcs: {
    threshold: 2.5, // coefficient of rounding error
    tolerance: 0.5, // percentage of radius
  },
  straightCurves: true,
  lineShorthands: true,
  curveSmoothShorthands: true,
  floatPrecision: 3,
  transformPrecision: 5,
  removeUseless: true,
  collapseRepeated: true,
  utilizeAbsolute: true,
  leadingZero: true,
  negativeExtraSpace: true,
  noSpaceAfterFlags: false, // a20 60 45 0 1 30 20 â†’ a20 60 45 0130 20
  forceAbsolutePath: false,
};

let roundData;
let precision;
let error;
let arcThreshold;
let arcTolerance;

/**
 * Convert absolute Path to relative,
 * collapse repeated instructions,
 * detect and convert Lineto shorthands,
 * remove useless instructions like "l0,0",
 * trim useless delimiters and leading zeros,
 * decrease accuracy of floating-point numbers.
 *
 * @see https://www.w3.org/TR/SVG11/paths.html#PathData
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
convertPathData$1.fn = (root, params) => {
  const stylesheet = collectStylesheet$1(root);
  return {
    element: {
      enter: (node) => {
        if (pathElems.includes(node.name) && node.attributes.d != null) {
          const computedStyle = computeStyle$1(stylesheet, node);
          precision = params.floatPrecision;
          error =
            precision !== false
              ? +Math.pow(0.1, precision).toFixed(precision)
              : 1e-2;
          roundData = precision > 0 && precision < 20 ? strongRound : round$1;
          if (params.makeArcs) {
            arcThreshold = params.makeArcs.threshold;
            arcTolerance = params.makeArcs.tolerance;
          }
          const hasMarkerMid = computedStyle['marker-mid'] != null;

          const maybeHasStroke =
            computedStyle.stroke &&
            (computedStyle.stroke.type === 'dynamic' ||
              computedStyle.stroke.value !== 'none');
          const maybeHasLinecap =
            computedStyle['stroke-linecap'] &&
            (computedStyle['stroke-linecap'].type === 'dynamic' ||
              computedStyle['stroke-linecap'].value !== 'butt');
          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;

          var data = path2js$1(node);

          // TODO: get rid of functions returns
          if (data.length) {
            if (params.applyTransforms) {
              applyTransforms(node, data, params);
            }

            convertToRelative(data);

            data = filters(data, params, {
              maybeHasStrokeAndLinecap,
              hasMarkerMid,
            });

            if (params.utilizeAbsolute) {
              data = convertToMixed(data, params);
            }

            js2path$1(node, data, params);
          }
        }
      },
    },
  };
};

/**
 * Convert absolute path data coordinates to relative.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
const convertToRelative = (pathData) => {
  let start = [0, 0];
  let cursor = [0, 0];
  let prevCoords = [0, 0];

  for (let i = 0; i < pathData.length; i += 1) {
    const pathItem = pathData[i];
    let { command, args } = pathItem;

    // moveto (x y)
    if (command === 'm') {
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }
    if (command === 'M') {
      // M â†’ m
      // skip first moveto
      if (i !== 0) {
        command = 'm';
      }
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }

    // lineto (x y)
    if (command === 'l') {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === 'L') {
      // L â†’ l
      command = 'l';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // horizontal lineto (x)
    if (command === 'h') {
      cursor[0] += args[0];
    }
    if (command === 'H') {
      // H â†’ h
      command = 'h';
      args[0] -= cursor[0];
      cursor[0] += args[0];
    }

    // vertical lineto (y)
    if (command === 'v') {
      cursor[1] += args[0];
    }
    if (command === 'V') {
      // V â†’ v
      command = 'v';
      args[0] -= cursor[1];
      cursor[1] += args[0];
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === 'c') {
      cursor[0] += args[4];
      cursor[1] += args[5];
    }
    if (command === 'C') {
      // C â†’ c
      command = 'c';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      args[4] -= cursor[0];
      args[5] -= cursor[1];
      cursor[0] += args[4];
      cursor[1] += args[5];
    }

    // smooth curveto (x2 y2 x y)
    if (command === 's') {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === 'S') {
      // S â†’ s
      command = 's';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // quadratic BÃ©zier curveto (x1 y1 x y)
    if (command === 'q') {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === 'Q') {
      // Q â†’ q
      command = 'q';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // smooth quadratic BÃ©zier curveto (x y)
    if (command === 't') {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === 'T') {
      // T â†’ t
      command = 't';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === 'a') {
      cursor[0] += args[5];
      cursor[1] += args[6];
    }
    if (command === 'A') {
      // A â†’ a
      command = 'a';
      args[5] -= cursor[0];
      args[6] -= cursor[1];
      cursor[0] += args[5];
      cursor[1] += args[6];
    }

    // closepath
    if (command === 'Z' || command === 'z') {
      // reset cursor
      cursor[0] = start[0];
      cursor[1] = start[1];
    }

    pathItem.command = command;
    pathItem.args = args;
    // store absolute coordinates for later use
    // base should preserve reference from other element
    pathItem.base = prevCoords;
    pathItem.coords = [cursor[0], cursor[1]];
    prevCoords = pathItem.coords;
  }

  return pathData;
};

/**
 * Main filters loop.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
function filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {
  var stringify = data2Path.bind(null, params),
    relSubpoint = [0, 0],
    pathBase = [0, 0],
    prev = {};

  path = path.filter(function (item, index, path) {
    let command = item.command;
    let data = item.args;
    let next = path[index + 1];

    if (command !== 'Z' && command !== 'z') {
      var sdata = data,
        circle;

      if (command === 's') {
        sdata = [0, 0].concat(data);

        if (command === 'c' || command === 's') {
          var pdata = prev.args,
            n = pdata.length;

          // (-x, -y) of the prev tangent point relative to the current point
          sdata[0] = pdata[n - 2] - pdata[n - 4];
          sdata[1] = pdata[n - 1] - pdata[n - 3];
        }
      }

      // convert curves to arcs if possible
      if (
        params.makeArcs &&
        (command == 'c' || command == 's') &&
        isConvex(sdata) &&
        (circle = findCircle(sdata))
      ) {
        var r = roundData([circle.radius])[0],
          angle = findArcAngle(sdata, circle),
          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
          arc = {
            command: 'a',
            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
            coords: item.coords.slice(),
            base: item.base,
          },
          output = [arc],
          // relative coordinates to adjust the found circle
          relCenter = [
            circle.center[0] - sdata[4],
            circle.center[1] - sdata[5],
          ],
          relCircle = { center: relCenter, radius: circle.radius },
          arcCurves = [item],
          hasPrev = 0,
          suffix = '',
          nextLonghand;

        if (
          (prev.command == 'c' &&
            isConvex(prev.args) &&
            isArcPrev(prev.args, circle)) ||
          (prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle))
        ) {
          arcCurves.unshift(prev);
          arc.base = prev.base;
          arc.args[5] = arc.coords[0] - arc.base[0];
          arc.args[6] = arc.coords[1] - arc.base[1];
          var prevData = prev.command == 'a' ? prev.sdata : prev.args;
          var prevAngle = findArcAngle(prevData, {
            center: [
              prevData[4] + circle.center[0],
              prevData[5] + circle.center[1],
            ],
            radius: circle.radius,
          });
          angle += prevAngle;
          if (angle > Math.PI) arc.args[3] = 1;
          hasPrev = 1;
        }

        // check if next curves are fitting the arc
        for (
          var j = index;
          (next = path[++j]) && ~'cs'.indexOf(next.command);

        ) {
          var nextData = next.args;
          if (next.command == 's') {
            nextLonghand = makeLonghand(
              { command: 's', args: next.args.slice() },
              path[j - 1].args
            );
            nextData = nextLonghand.args;
            nextLonghand.args = nextData.slice(0, 2);
            suffix = stringify([nextLonghand]);
          }
          if (isConvex(nextData) && isArc(nextData, relCircle)) {
            angle += findArcAngle(nextData, relCircle);
            if (angle - 2 * Math.PI > 1e-3) break; // more than 360Â°
            if (angle > Math.PI) arc.args[3] = 1;
            arcCurves.push(next);
            if (2 * Math.PI - angle > 1e-3) {
              // less than 360Â°
              arc.coords = next.coords;
              arc.args[5] = arc.coords[0] - arc.base[0];
              arc.args[6] = arc.coords[1] - arc.base[1];
            } else {
              // full circle, make a half-circle arc and add a second one
              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
              arc.coords = [
                arc.base[0] + arc.args[5],
                arc.base[1] + arc.args[6],
              ];
              arc = {
                command: 'a',
                args: [
                  r,
                  r,
                  0,
                  0,
                  sweep,
                  next.coords[0] - arc.coords[0],
                  next.coords[1] - arc.coords[1],
                ],
                coords: next.coords,
                base: arc.coords,
              };
              output.push(arc);
              j++;
              break;
            }
            relCenter[0] -= nextData[4];
            relCenter[1] -= nextData[5];
          } else break;
        }

        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
          if (path[j] && path[j].command == 's') {
            makeLonghand(path[j], path[j - 1].args);
          }
          if (hasPrev) {
            var prevArc = output.shift();
            roundData(prevArc.args);
            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
            prev.command = 'a';
            prev.args = prevArc.args;
            item.base = prev.coords = prevArc.coords;
          }
          arc = output.shift();
          if (arcCurves.length == 1) {
            item.sdata = sdata.slice(); // preserve curve data for future checks
          } else if (arcCurves.length - 1 - hasPrev > 0) {
            // filter out consumed next items
            path.splice.apply(
              path,
              [index + 1, arcCurves.length - 1 - hasPrev].concat(output)
            );
          }
          if (!arc) return false;
          command = 'a';
          data = arc.args;
          item.coords = arc.coords;
        }
      }

      // Rounding relative coordinates, taking in account accummulating error
      // to get closer to absolute coordinates. Sum of rounded value remains same:
      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2
      if (precision !== false) {
        if (
          command === 'm' ||
          command === 'l' ||
          command === 't' ||
          command === 'q' ||
          command === 's' ||
          command === 'c'
        ) {
          for (var i = data.length; i--; ) {
            data[i] += item.base[i % 2] - relSubpoint[i % 2];
          }
        } else if (command == 'h') {
          data[0] += item.base[0] - relSubpoint[0];
        } else if (command == 'v') {
          data[0] += item.base[1] - relSubpoint[1];
        } else if (command == 'a') {
          data[5] += item.base[0] - relSubpoint[0];
          data[6] += item.base[1] - relSubpoint[1];
        }
        roundData(data);

        if (command == 'h') relSubpoint[0] += data[0];
        else if (command == 'v') relSubpoint[1] += data[0];
        else {
          relSubpoint[0] += data[data.length - 2];
          relSubpoint[1] += data[data.length - 1];
        }
        roundData(relSubpoint);

        if (command === 'M' || command === 'm') {
          pathBase[0] = relSubpoint[0];
          pathBase[1] = relSubpoint[1];
        }
      }

      // convert straight curves into lines segments
      if (params.straightCurves) {
        if (
          (command === 'c' && isCurveStraightLine(data)) ||
          (command === 's' && isCurveStraightLine(sdata))
        ) {
          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve
          command = 'l';
          data = data.slice(-2);
        } else if (command === 'q' && isCurveStraightLine(data)) {
          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve
          command = 'l';
          data = data.slice(-2);
        } else if (
          command === 't' &&
          prev.command !== 'q' &&
          prev.command !== 't'
        ) {
          command = 'l';
          data = data.slice(-2);
        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {
          command = 'l';
          data = data.slice(-2);
        }
      }

      // horizontal and vertical line shorthands
      // l 50 0 â†’ h 50
      // l 0 50 â†’ v 50
      if (params.lineShorthands && command === 'l') {
        if (data[1] === 0) {
          command = 'h';
          data.pop();
        } else if (data[0] === 0) {
          command = 'v';
          data.shift();
        }
      }

      // collapse repeated commands
      // h 20 h 30 -> h 50
      if (
        params.collapseRepeated &&
        hasMarkerMid === false &&
        (command === 'm' || command === 'h' || command === 'v') &&
        prev.command &&
        command == prev.command.toLowerCase() &&
        ((command != 'h' && command != 'v') ||
          prev.args[0] >= 0 == data[0] >= 0)
      ) {
        prev.args[0] += data[0];
        if (command != 'h' && command != 'v') {
          prev.args[1] += data[1];
        }
        prev.coords = item.coords;
        path[index] = prev;
        return false;
      }

      // convert curves into smooth shorthands
      if (params.curveSmoothShorthands && prev.command) {
        // curveto
        if (command === 'c') {
          // c + c â†’ c + s
          if (
            prev.command === 'c' &&
            data[0] === -(prev.args[2] - prev.args[4]) &&
            data[1] === -(prev.args[3] - prev.args[5])
          ) {
            command = 's';
            data = data.slice(2);
          }

          // s + c â†’ s + s
          else if (
            prev.command === 's' &&
            data[0] === -(prev.args[0] - prev.args[2]) &&
            data[1] === -(prev.args[1] - prev.args[3])
          ) {
            command = 's';
            data = data.slice(2);
          }

          // [^cs] + c â†’ [^cs] + s
          else if (
            prev.command !== 'c' &&
            prev.command !== 's' &&
            data[0] === 0 &&
            data[1] === 0
          ) {
            command = 's';
            data = data.slice(2);
          }
        }

        // quadratic BÃ©zier curveto
        else if (command === 'q') {
          // q + q â†’ q + t
          if (
            prev.command === 'q' &&
            data[0] === prev.args[2] - prev.args[0] &&
            data[1] === prev.args[3] - prev.args[1]
          ) {
            command = 't';
            data = data.slice(2);
          }

          // t + q â†’ t + t
          else if (
            prev.command === 't' &&
            data[2] === prev.args[0] &&
            data[3] === prev.args[1]
          ) {
            command = 't';
            data = data.slice(2);
          }
        }
      }

      // remove useless non-first path segments
      if (params.removeUseless && !maybeHasStrokeAndLinecap) {
        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0
        if (
          (command === 'l' ||
            command === 'h' ||
            command === 'v' ||
            command === 'q' ||
            command === 't' ||
            command === 'c' ||
            command === 's') &&
          data.every(function (i) {
            return i === 0;
          })
        ) {
          path[index] = prev;
          return false;
        }

        // a 25,25 -30 0,1 0,0
        if (command === 'a' && data[5] === 0 && data[6] === 0) {
          path[index] = prev;
          return false;
        }
      }

      item.command = command;
      item.args = data;

      prev = item;
    } else {
      // z resets coordinates
      relSubpoint[0] = pathBase[0];
      relSubpoint[1] = pathBase[1];
      if (prev.command === 'Z' || prev.command === 'z') return false;
      prev = item;
    }

    return true;
  });

  return path;
}

/**
 * Writes data in shortest form using absolute or relative coordinates.
 *
 * @param {Array} data input path data
 * @return {Boolean} output
 */
function convertToMixed(path, params) {
  var prev = path[0];

  path = path.filter(function (item, index) {
    if (index == 0) return true;
    if (item.command === 'Z' || item.command === 'z') {
      prev = item;
      return true;
    }

    var command = item.command,
      data = item.args,
      adata = data.slice();

    if (
      command === 'm' ||
      command === 'l' ||
      command === 't' ||
      command === 'q' ||
      command === 's' ||
      command === 'c'
    ) {
      for (var i = adata.length; i--; ) {
        adata[i] += item.base[i % 2];
      }
    } else if (command == 'h') {
      adata[0] += item.base[0];
    } else if (command == 'v') {
      adata[0] += item.base[1];
    } else if (command == 'a') {
      adata[5] += item.base[0];
      adata[6] += item.base[1];
    }

    roundData(adata);

    var absoluteDataStr = cleanupOutData$1(adata, params),
      relativeDataStr = cleanupOutData$1(data, params);

    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.
    // v-20 -> V0
    // Don't convert if it fits following previous command.
    // l20 30-10-50 instead of l20 30L20 30
    if (
      params.forceAbsolutePath ||
      (absoluteDataStr.length < relativeDataStr.length &&
        !(
          params.negativeExtraSpace &&
          command == prev.command &&
          prev.command.charCodeAt(0) > 96 &&
          absoluteDataStr.length == relativeDataStr.length - 1 &&
          (data[0] < 0 ||
            (/^0\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))
        ))
    ) {
      item.command = command.toUpperCase();
      item.args = adata;
    }

    prev = item;

    return true;
  });

  return path;
}

/**
 * Checks if curve is convex. Control points of such a curve must form
 * a convex quadrilateral with diagonals crosspoint inside of it.
 *
 * @param {Array} data input path data
 * @return {Boolean} output
 */
function isConvex(data) {
  var center = getIntersection([
    0,
    0,
    data[2],
    data[3],
    data[0],
    data[1],
    data[4],
    data[5],
  ]);

  return (
    center &&
    data[2] < center[0] == center[0] < 0 &&
    data[3] < center[1] == center[1] < 0 &&
    data[4] < center[0] == center[0] < data[0] &&
    data[5] < center[1] == center[1] < data[1]
  );
}

/**
 * Computes lines equations by two points and returns their intersection point.
 *
 * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)
 * @return {Array|undefined} output coordinate of lines' crosspoint
 */
function getIntersection(coords) {
  // Prev line equation parameters.
  var a1 = coords[1] - coords[3], // y1 - y2
    b1 = coords[2] - coords[0], // x2 - x1
    c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1
    // Next line equation parameters
    a2 = coords[5] - coords[7], // y1 - y2
    b2 = coords[6] - coords[4], // x2 - x1
    c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1
    denom = a1 * b2 - a2 * b1;

  if (!denom) return; // parallel lines havn't an intersection

  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
  if (
    !isNaN(cross[0]) &&
    !isNaN(cross[1]) &&
    isFinite(cross[0]) &&
    isFinite(cross[1])
  ) {
    return cross;
  }
}

/**
 * Decrease accuracy of floating-point numbers
 * in path data keeping a specified number of decimals.
 * Smart rounds values like 2.3491 to 2.35 instead of 2.349.
 * Doesn't apply "smartness" if the number precision fits already.
 *
 * @param {Array} data input data array
 * @return {Array} output data array
 */
function strongRound(data) {
  for (var i = data.length; i-- > 0; ) {
    if (data[i].toFixed(precision) != data[i]) {
      var rounded = +data[i].toFixed(precision - 1);
      data[i] =
        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error
          ? +data[i].toFixed(precision)
          : rounded;
    }
  }
  return data;
}

/**
 * Simple rounding function if precision is 0.
 *
 * @param {Array} data input data array
 * @return {Array} output data array
 */
function round$1(data) {
  for (var i = data.length; i-- > 0; ) {
    data[i] = Math.round(data[i]);
  }
  return data;
}

/**
 * Checks if a curve is a straight line by measuring distance
 * from middle points to the line formed by end points.
 *
 * @param {Array} xs array of curve points x-coordinates
 * @param {Array} ys array of curve points y-coordinates
 * @return {Boolean}
 */

function isCurveStraightLine(data) {
  // Get line equation aÂ·x + bÂ·y + c = 0 coefficients a, b (c = 0) by start and end points.
  var i = data.length - 2,
    a = -data[i + 1], // y1 âˆ’ y2 (y1 = 0)
    b = data[i], // x2 âˆ’ x1 (x1 = 0)
    d = 1 / (a * a + b * b); // same part for all points

  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case

  // Distance from point (x0, y0) to the line is sqrt((c âˆ’ aÂ·x0 âˆ’ bÂ·y0)Â² / (aÂ² + bÂ²))
  while ((i -= 2) >= 0) {
    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
      return false;
  }

  return true;
}

/**
 * Converts next curve from shorthand to full form using the current curve data.
 *
 * @param {Object} item curve to convert
 * @param {Array} data current curve data
 */

function makeLonghand(item, data) {
  switch (item.command) {
    case 's':
      item.command = 'c';
      break;
    case 't':
      item.command = 'q';
      break;
  }
  item.args.unshift(
    data[data.length - 2] - data[data.length - 4],
    data[data.length - 1] - data[data.length - 3]
  );
  return item;
}

/**
 * Returns distance between two points
 *
 * @param {Array} point1 first point coordinates
 * @param {Array} point2 second point coordinates
 * @return {Number} distance
 */

function getDistance(point1, point2) {
  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);
}

/**
 * Returns coordinates of the curve point corresponding to the certain t
 * aÂ·(1 - t)Â³Â·p1 + bÂ·(1 - t)Â²Â·tÂ·p2 + cÂ·(1 - t)Â·tÂ²Â·p3 + dÂ·tÂ³Â·p4,
 * where pN are control points and p1 is zero due to relative coordinates.
 *
 * @param {Array} curve array of curve points coordinates
 * @param {Number} t parametric position from 0 to 1
 * @return {Array} Point coordinates
 */

function getCubicBezierPoint(curve, t) {
  var sqrT = t * t,
    cubT = sqrT * t,
    mt = 1 - t,
    sqrMt = mt * mt;

  return [
    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],
  ];
}

/**
 * Finds circle by 3 points of the curve and checks if the curve fits the found circle.
 *
 * @param {Array} curve
 * @return {Object|undefined} circle
 */

function findCircle(curve) {
  var midPoint = getCubicBezierPoint(curve, 1 / 2),
    m1 = [midPoint[0] / 2, midPoint[1] / 2],
    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],
    center = getIntersection([
      m1[0],
      m1[1],
      m1[0] + m1[1],
      m1[1] - m1[0],
      m2[0],
      m2[1],
      m2[0] + (m2[1] - midPoint[1]),
      m2[1] - (m2[0] - midPoint[0]),
    ]),
    radius = center && getDistance([0, 0], center),
    tolerance = Math.min(arcThreshold * error, (arcTolerance * radius) / 100);

  if (
    center &&
    radius < 1e15 &&
    [1 / 4, 3 / 4].every(function (point) {
      return (
        Math.abs(
          getDistance(getCubicBezierPoint(curve, point), center) - radius
        ) <= tolerance
      );
    })
  )
    return { center: center, radius: radius };
}

/**
 * Checks if a curve fits the given circle.
 *
 * @param {Object} circle
 * @param {Array} curve
 * @return {Boolean}
 */

function isArc(curve, circle) {
  var tolerance = Math.min(
    arcThreshold * error,
    (arcTolerance * circle.radius) / 100
  );

  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {
    return (
      Math.abs(
        getDistance(getCubicBezierPoint(curve, point), circle.center) -
          circle.radius
      ) <= tolerance
    );
  });
}

/**
 * Checks if a previous curve fits the given circle.
 *
 * @param {Object} circle
 * @param {Array} curve
 * @return {Boolean}
 */

function isArcPrev(curve, circle) {
  return isArc(curve, {
    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
    radius: circle.radius,
  });
}

/**
 * Finds angle of a curve fitting the given arc.

 * @param {Array} curve
 * @param {Object} relCircle
 * @return {Number} angle
 */

function findArcAngle(curve, relCircle) {
  var x1 = -relCircle.center[0],
    y1 = -relCircle.center[1],
    x2 = curve[4] - relCircle.center[0],
    y2 = curve[5] - relCircle.center[1];

  return Math.acos(
    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
  );
}

/**
 * Converts given path data to string.
 *
 * @param {Object} params
 * @param {Array} pathData
 * @return {String}
 */

function data2Path(params, pathData) {
  return pathData.reduce(function (pathString, item) {
    var strData = '';
    if (item.args) {
      strData = cleanupOutData$1(roundData(item.args.slice()), params);
    }
    return pathString + item.command + strData;
  }, '');
}

var convertTransform$2 = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { cleanupOutData } = tools;
const {
  transform2js,
  transformsMultiply,
  matrixToTransform,
} = _transforms;

convertTransform$2.type = 'visitor';
convertTransform$2.name = 'convertTransform';
convertTransform$2.active = true;
convertTransform$2.description = 'collapses multiple transformations and optimizes it';

/**
 * Convert matrices to the short aliases,
 * convert long translate, scale or rotate transform notations to the shorts ones,
 * convert transforms to the matrices and multiply them all into one,
 * remove useless transforms.
 *
 * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<{
 *   convertToShorts?: boolean,
 *   degPrecision?: number,
 *   floatPrecision?: number,
 *   transformPrecision?: number,
 *   matrixToTransform?: boolean,
 *   shortTranslate?: boolean,
 *   shortScale?: boolean,
 *   shortRotate?: boolean,
 *   removeUseless?: boolean,
 *   collapseIntoOne?: boolean,
 *   leadingZero?: boolean,
 *   negativeExtraSpace?: boolean,
 * }>}
 */
convertTransform$2.fn = (_root, params) => {
  const {
    convertToShorts = true,
    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default
    degPrecision,
    floatPrecision = 3,
    transformPrecision = 5,
    matrixToTransform = true,
    shortTranslate = true,
    shortScale = true,
    shortRotate = true,
    removeUseless = true,
    collapseIntoOne = true,
    leadingZero = true,
    negativeExtraSpace = false,
  } = params;
  const newParams = {
    convertToShorts,
    degPrecision,
    floatPrecision,
    transformPrecision,
    matrixToTransform,
    shortTranslate,
    shortScale,
    shortRotate,
    removeUseless,
    collapseIntoOne,
    leadingZero,
    negativeExtraSpace,
  };
  return {
    element: {
      enter: (node) => {
        // transform
        if (node.attributes.transform != null) {
          convertTransform$1(node, 'transform', newParams);
        }
        // gradientTransform
        if (node.attributes.gradientTransform != null) {
          convertTransform$1(node, 'gradientTransform', newParams);
        }
        // patternTransform
        if (node.attributes.patternTransform != null) {
          convertTransform$1(node, 'patternTransform', newParams);
        }
      },
    },
  };
};

/**
 * @typedef {{
 *   convertToShorts: boolean,
 *   degPrecision?: number,
 *   floatPrecision: number,
 *   transformPrecision: number,
 *   matrixToTransform: boolean,
 *   shortTranslate: boolean,
 *   shortScale: boolean,
 *   shortRotate: boolean,
 *   removeUseless: boolean,
 *   collapseIntoOne: boolean,
 *   leadingZero: boolean,
 *   negativeExtraSpace: boolean,
 * }} TransformParams
 */

/**
 * @typedef {{ name: string, data: Array<number> }} TransformItem
 */

/**
 * Main function.
 *
 * @type {(item: XastElement, attrName: string, params: TransformParams) => void}
 */
const convertTransform$1 = (item, attrName, params) => {
  let data = transform2js(item.attributes[attrName]);
  params = definePrecision(data, params);

  if (params.collapseIntoOne && data.length > 1) {
    data = [transformsMultiply(data)];
  }

  if (params.convertToShorts) {
    data = convertToShorts(data, params);
  } else {
    data.forEach((item) => roundTransform(item, params));
  }

  if (params.removeUseless) {
    data = removeUseless(data);
  }

  if (data.length) {
    item.attributes[attrName] = js2transform(data, params);
  } else {
    delete item.attributes[attrName];
  }
};

/**
 * Defines precision to work with certain parts.
 * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),
 * floatPrecision - for translate including two last matrix and rotate parameters,
 * degPrecision - for rotate and skew. By default it's equal to (rougly)
 * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.
 *
 * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}
 *
 * clone params so it don't affect other elements transformations.
 */
const definePrecision = (data, { ...newParams }) => {
  const matrixData = [];
  for (const item of data) {
    if (item.name == 'matrix') {
      matrixData.push(...item.data.slice(0, 4));
    }
  }
  let significantDigits = newParams.transformPrecision;
  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.
  if (matrixData.length) {
    newParams.transformPrecision = Math.min(
      newParams.transformPrecision,
      Math.max.apply(Math, matrixData.map(floatDigits)) ||
        newParams.transformPrecision
    );
    significantDigits = Math.max.apply(
      Math,
      matrixData.map(
        (n) => n.toString().replace(/\D+/g, '').length // Number of digits in a number. 123.45 â†’ 5
      )
    );
  }
  // No sense in angle precision more then number of significant digits in matrix.
  if (newParams.degPrecision == null) {
    newParams.degPrecision = Math.max(
      0,
      Math.min(newParams.floatPrecision, significantDigits - 2)
    );
  }
  return newParams;
};

/**
 * @type {(data: Array<number>, params: TransformParams) => Array<number>}
 */
const degRound = (data, params) => {
  if (
    params.degPrecision != null &&
    params.degPrecision >= 1 &&
    params.floatPrecision < 20
  ) {
    return smartRound(params.degPrecision, data);
  } else {
    return round(data);
  }
};
/**
 * @type {(data: Array<number>, params: TransformParams) => Array<number>}
 */
const floatRound = (data, params) => {
  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
    return smartRound(params.floatPrecision, data);
  } else {
    return round(data);
  }
};

/**
 * @type {(data: Array<number>, params: TransformParams) => Array<number>}
 */
const transformRound = (data, params) => {
  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
    return smartRound(params.transformPrecision, data);
  } else {
    return round(data);
  }
};

/**
 * Returns number of digits after the point. 0.125 â†’ 3
 *
 * @type {(n: number) => number}
 */
const floatDigits = (n) => {
  const str = n.toString();
  return str.slice(str.indexOf('.')).length - 1;
};

/**
 * Convert transforms to the shorthand alternatives.
 *
 * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}
 */
const convertToShorts = (transforms, params) => {
  for (var i = 0; i < transforms.length; i++) {
    var transform = transforms[i];

    // convert matrix to the short aliases
    if (params.matrixToTransform && transform.name === 'matrix') {
      var decomposed = matrixToTransform(transform, params);
      if (
        js2transform(decomposed, params).length <=
        js2transform([transform], params).length
      ) {
        transforms.splice(i, 1, ...decomposed);
      }
      transform = transforms[i];
    }

    // fixed-point numbers
    // 12.754997 â†’ 12.755
    roundTransform(transform, params);

    // convert long translate transform notation to the shorts one
    // translate(10 0) â†’ translate(10)
    if (
      params.shortTranslate &&
      transform.name === 'translate' &&
      transform.data.length === 2 &&
      !transform.data[1]
    ) {
      transform.data.pop();
    }

    // convert long scale transform notation to the shorts one
    // scale(2 2) â†’ scale(2)
    if (
      params.shortScale &&
      transform.name === 'scale' &&
      transform.data.length === 2 &&
      transform.data[0] === transform.data[1]
    ) {
      transform.data.pop();
    }

    // convert long rotate transform notation to the short one
    // translate(cx cy) rotate(a) translate(-cx -cy) â†’ rotate(a cx cy)
    if (
      params.shortRotate &&
      transforms[i - 2] &&
      transforms[i - 2].name === 'translate' &&
      transforms[i - 1].name === 'rotate' &&
      transforms[i].name === 'translate' &&
      transforms[i - 2].data[0] === -transforms[i].data[0] &&
      transforms[i - 2].data[1] === -transforms[i].data[1]
    ) {
      transforms.splice(i - 2, 3, {
        name: 'rotate',
        data: [
          transforms[i - 1].data[0],
          transforms[i - 2].data[0],
          transforms[i - 2].data[1],
        ],
      });

      // splice compensation
      i -= 2;
    }
  }

  return transforms;
};

/**
 * Remove useless transforms.
 *
 * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}
 */
const removeUseless = (transforms) => {
  return transforms.filter((transform) => {
    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)
    if (
      (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&
        (transform.data.length == 1 || transform.name == 'rotate') &&
        !transform.data[0]) ||
      // translate(0, 0)
      (transform.name == 'translate' &&
        !transform.data[0] &&
        !transform.data[1]) ||
      // scale(1)
      (transform.name == 'scale' &&
        transform.data[0] == 1 &&
        (transform.data.length < 2 || transform.data[1] == 1)) ||
      // matrix(1 0 0 1 0 0)
      (transform.name == 'matrix' &&
        transform.data[0] == 1 &&
        transform.data[3] == 1 &&
        !(
          transform.data[1] ||
          transform.data[2] ||
          transform.data[4] ||
          transform.data[5]
        ))
    ) {
      return false;
    }

    return true;
  });
};

/**
 * Convert transforms JS representation to string.
 *
 * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}
 */
const js2transform = (transformJS, params) => {
  var transformString = '';

  // collect output value string
  transformJS.forEach((transform) => {
    roundTransform(transform, params);
    transformString +=
      (transformString && ' ') +
      transform.name +
      '(' +
      cleanupOutData(transform.data, params) +
      ')';
  });

  return transformString;
};

/**
 * @type {(transform: TransformItem, params: TransformParams) => TransformItem}
 */
const roundTransform = (transform, params) => {
  switch (transform.name) {
    case 'translate':
      transform.data = floatRound(transform.data, params);
      break;
    case 'rotate':
      transform.data = [
        ...degRound(transform.data.slice(0, 1), params),
        ...floatRound(transform.data.slice(1), params),
      ];
      break;
    case 'skewX':
    case 'skewY':
      transform.data = degRound(transform.data, params);
      break;
    case 'scale':
      transform.data = transformRound(transform.data, params);
      break;
    case 'matrix':
      transform.data = [
        ...transformRound(transform.data.slice(0, 4), params),
        ...floatRound(transform.data.slice(4), params),
      ];
      break;
  }
  return transform;
};

/**
 * Rounds numbers in array.
 *
 * @type {(data: Array<number>) => Array<number>}
 */
const round = (data) => {
  return data.map(Math.round);
};

/**
 * Decrease accuracy of floating-point numbers
 * in transforms keeping a specified number of decimals.
 * Smart rounds values like 2.349 to 2.35.
 *
 * @type {(precision: number, data: Array<number>) => Array<number>}
 */
const smartRound = (precision, data) => {
  for (
    var i = data.length,
      tolerance = +Math.pow(0.1, precision).toFixed(precision);
    i--;

  ) {
    if (Number(data[i].toFixed(precision)) !== data[i]) {
      var rounded = +data[i].toFixed(precision - 1);
      data[i] =
        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance
          ? +data[i].toFixed(precision)
          : rounded;
    }
  }
  return data;
};

var removeEmptyAttrs$1 = {};

const { attrsGroups } = _collections;

removeEmptyAttrs$1.type = 'visitor';
removeEmptyAttrs$1.name = 'removeEmptyAttrs';
removeEmptyAttrs$1.active = true;
removeEmptyAttrs$1.description = 'removes empty attributes';

/**
 * Remove attributes with empty values.
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeEmptyAttrs$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        for (const [name, value] of Object.entries(node.attributes)) {
          if (
            value === '' &&
            // empty conditional processing attributes prevents elements from rendering
            attrsGroups.conditionalProcessing.includes(name) === false
          ) {
            delete node.attributes[name];
          }
        }
      },
    },
  };
};

var removeEmptyContainers$1 = {};

const { detachNodeFromParent: detachNodeFromParent$8 } = xast;
const { elemsGroups } = _collections;

removeEmptyContainers$1.type = 'visitor';
removeEmptyContainers$1.name = 'removeEmptyContainers';
removeEmptyContainers$1.active = true;
removeEmptyContainers$1.description = 'removes empty container elements';

/**
 * Remove empty containers.
 *
 * @see https://www.w3.org/TR/SVG11/intro.html#TermContainerElement
 *
 * @example
 * <defs/>
 *
 * @example
 * <g><marker><a/></marker></g>
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeEmptyContainers$1.fn = () => {
  return {
    element: {
      exit: (node, parentNode) => {
        // remove only empty non-svg containers
        if (
          node.name === 'svg' ||
          elemsGroups.container.includes(node.name) === false ||
          node.children.length !== 0
        ) {
          return;
        }
        // empty patterns may contain reusable configuration
        if (
          node.name === 'pattern' &&
          Object.keys(node.attributes).length !== 0
        ) {
          return;
        }
        // The <g> may not have content, but the filter may cause a rectangle
        // to be created and filled with pattern.
        if (node.name === 'g' && node.attributes.filter != null) {
          return;
        }
        // empty <mask> hides masked element
        if (node.name === 'mask' && node.attributes.id != null) {
          return;
        }
        detachNodeFromParent$8(node, parentNode);
      },
    },
  };
};

var mergePaths$1 = {};

const { detachNodeFromParent: detachNodeFromParent$7 } = xast;
const { collectStylesheet, computeStyle } = style;
const { path2js, js2path, intersects: intersects$1 } = _path;

mergePaths$1.type = 'visitor';
mergePaths$1.name = 'mergePaths';
mergePaths$1.active = true;
mergePaths$1.description = 'merges multiple paths in one if possible';

/**
 * Merge multiple Paths into one.
 *
 * @author Kir Belevich, Lev Solntsev
 *
 * @type {import('../lib/types').Plugin<{
 *   force?: boolean,
 *   floatPrecision?: number,
 *   noSpaceAfterFlags?: boolean
 * }>}
 */
mergePaths$1.fn = (root, params) => {
  const {
    force = false,
    floatPrecision,
    noSpaceAfterFlags = false, // a20 60 45 0 1 30 20 â†’ a20 60 45 0130 20
  } = params;
  const stylesheet = collectStylesheet(root);

  return {
    element: {
      enter: (node) => {
        let prevChild = null;

        for (const child of node.children) {
          // skip if previous element is not path or contains animation elements
          if (
            prevChild == null ||
            prevChild.type !== 'element' ||
            prevChild.name !== 'path' ||
            prevChild.children.length !== 0 ||
            prevChild.attributes.d == null
          ) {
            prevChild = child;
            continue;
          }

          // skip if element is not path or contains animation elements
          if (
            child.type !== 'element' ||
            child.name !== 'path' ||
            child.children.length !== 0 ||
            child.attributes.d == null
          ) {
            prevChild = child;
            continue;
          }

          // preserve paths with markers
          const computedStyle = computeStyle(stylesheet, child);
          if (
            computedStyle['marker-start'] ||
            computedStyle['marker-mid'] ||
            computedStyle['marker-end']
          ) {
            prevChild = child;
            continue;
          }

          const prevChildAttrs = Object.keys(prevChild.attributes);
          const childAttrs = Object.keys(child.attributes);
          let attributesAreEqual = prevChildAttrs.length === childAttrs.length;
          for (const name of childAttrs) {
            if (name !== 'd') {
              if (
                prevChild.attributes[name] == null ||
                prevChild.attributes[name] !== child.attributes[name]
              ) {
                attributesAreEqual = false;
              }
            }
          }
          const prevPathJS = path2js(prevChild);
          const curPathJS = path2js(child);

          if (
            attributesAreEqual &&
            (force || !intersects$1(prevPathJS, curPathJS))
          ) {
            js2path(prevChild, prevPathJS.concat(curPathJS), {
              floatPrecision,
              noSpaceAfterFlags,
            });
            detachNodeFromParent$7(child, node);
            continue;
          }

          prevChild = child;
        }
      },
    },
  };
};

var removeUnusedNS$1 = {};

removeUnusedNS$1.type = 'visitor';
removeUnusedNS$1.name = 'removeUnusedNS';
removeUnusedNS$1.active = true;
removeUnusedNS$1.description = 'removes unused namespaces declaration';

/**
 * Remove unused namespaces declaration from svg element
 * which are not used in elements or attributes
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeUnusedNS$1.fn = () => {
  /**
   * @type {Set<string>}
   */
  const unusedNamespaces = new Set();
  return {
    element: {
      enter: (node, parentNode) => {
        // collect all namespaces from svg element
        // (such as xmlns:xlink="http://www.w3.org/1999/xlink")
        if (node.name === 'svg' && parentNode.type === 'root') {
          for (const name of Object.keys(node.attributes)) {
            if (name.startsWith('xmlns:')) {
              const local = name.slice('xmlns:'.length);
              unusedNamespaces.add(local);
            }
          }
        }
        if (unusedNamespaces.size !== 0) {
          // preserve namespace used in nested elements names
          if (node.name.includes(':')) {
            const [ns] = node.name.split(':');
            if (unusedNamespaces.has(ns)) {
              unusedNamespaces.delete(ns);
            }
          }
          // preserve namespace used in nested elements attributes
          for (const name of Object.keys(node.attributes)) {
            if (name.includes(':')) {
              const [ns] = name.split(':');
              unusedNamespaces.delete(ns);
            }
          }
        }
      },
      exit: (node, parentNode) => {
        // remove unused namespace attributes from svg element
        if (node.name === 'svg' && parentNode.type === 'root') {
          for (const name of unusedNamespaces) {
            delete node.attributes[`xmlns:${name}`];
          }
        }
      },
    },
  };
};

var sortDefsChildren$1 = {};

sortDefsChildren$1.type = 'visitor';
sortDefsChildren$1.name = 'sortDefsChildren';
sortDefsChildren$1.active = true;
sortDefsChildren$1.description = 'Sorts children of <defs> to improve compression';

/**
 * Sorts children of defs in order to improve compression.
 * Sorted first by frequency then by element name length then by element name (to ensure grouping).
 *
 * @author David Leston
 *
 * @type {import('../lib/types').Plugin<void>}
 */
sortDefsChildren$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        if (node.name === 'defs') {
          /**
           * @type {Map<string, number>}
           */
          const frequencies = new Map();
          for (const child of node.children) {
            if (child.type === 'element') {
              const frequency = frequencies.get(child.name);
              if (frequency == null) {
                frequencies.set(child.name, 1);
              } else {
                frequencies.set(child.name, frequency + 1);
              }
            }
          }
          node.children.sort((a, b) => {
            if (a.type !== 'element' || b.type !== 'element') {
              return 0;
            }
            const aFrequency = frequencies.get(a.name);
            const bFrequency = frequencies.get(b.name);
            if (aFrequency != null && bFrequency != null) {
              const frequencyComparison = bFrequency - aFrequency;
              if (frequencyComparison !== 0) {
                return frequencyComparison;
              }
            }
            const lengthComparison = b.name.length - a.name.length;
            if (lengthComparison !== 0) {
              return lengthComparison;
            }
            if (a.name !== b.name) {
              return a.name > b.name ? -1 : 1;
            }
            return 0;
          });
        }
      },
    },
  };
};

var removeTitle$1 = {};

const { detachNodeFromParent: detachNodeFromParent$6 } = xast;

removeTitle$1.name = 'removeTitle';
removeTitle$1.type = 'visitor';
removeTitle$1.active = true;
removeTitle$1.description = 'removes <title>';

/**
 * Remove <title>.
 *
 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/title
 *
 * @author Igor Kalashnikov
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeTitle$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'title') {
          detachNodeFromParent$6(node, parentNode);
        }
      },
    },
  };
};

var removeDesc$1 = {};

const { detachNodeFromParent: detachNodeFromParent$5 } = xast;

removeDesc$1.name = 'removeDesc';
removeDesc$1.type = 'visitor';
removeDesc$1.active = true;
removeDesc$1.description = 'removes <desc>';

const standardDescs = /^(Created with|Created using)/;

/**
 * Removes <desc>.
 * Removes only standard editors content or empty elements 'cause it can be used for accessibility.
 * Enable parameter 'removeAny' to remove any description.
 *
 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/desc
 *
 * @author Daniel Wabyick
 *
 * @type {import('../lib/types').Plugin<{ removeAny?: boolean }>}
 */
removeDesc$1.fn = (root, params) => {
  const { removeAny = true } = params;
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'desc') {
          if (
            removeAny ||
            node.children.length === 0 ||
            (node.children[0].type === 'text' &&
              standardDescs.test(node.children[0].value))
          ) {
            detachNodeFromParent$5(node, parentNode);
          }
        }
      },
    },
  };
};

const { createPreset } = plugins;

const removeDoctype = removeDoctype$1;
const removeXMLProcInst = removeXMLProcInst$1;
const removeComments = removeComments$1;
const removeMetadata = removeMetadata$1;
const removeEditorsNSData = removeEditorsNSData$1;
const cleanupAttrs = cleanupAttrs$1;
const mergeStyles = mergeStyles$1;
const inlineStyles = inlineStyles$1;
const minifyStyles = minifyStyles$1;
const cleanupIDs = cleanupIDs$1;
const removeUselessDefs = removeUselessDefs$1;
const cleanupNumericValues = cleanupNumericValues$1;
const convertColors = convertColors$1;
const removeUnknownsAndDefaults = removeUnknownsAndDefaults$1;
const removeNonInheritableGroupAttrs = removeNonInheritableGroupAttrs$1;
const removeUselessStrokeAndFill = removeUselessStrokeAndFill$1;
const removeViewBox = removeViewBox$1;
const cleanupEnableBackground = cleanupEnableBackground$1;
const removeHiddenElems = removeHiddenElems$1;
const removeEmptyText = removeEmptyText$1;
const convertShapeToPath = convertShapeToPath$1;
const convertEllipseToCircle = convertEllipseToCircle$1;
const moveElemsAttrsToGroup = moveElemsAttrsToGroup$1;
const moveGroupAttrsToElems = moveGroupAttrsToElems$1;
const collapseGroups = collapseGroups$1;
const convertPathData = convertPathData$1;
const convertTransform = convertTransform$2;
const removeEmptyAttrs = removeEmptyAttrs$1;
const removeEmptyContainers = removeEmptyContainers$1;
const mergePaths = mergePaths$1;
const removeUnusedNS = removeUnusedNS$1;
const sortDefsChildren = sortDefsChildren$1;
const removeTitle = removeTitle$1;
const removeDesc = removeDesc$1;

const presetDefault = createPreset({
  name: 'presetDefault',
  plugins: [
    removeDoctype,
    removeXMLProcInst,
    removeComments,
    removeMetadata,
    removeEditorsNSData,
    cleanupAttrs,
    mergeStyles,
    inlineStyles,
    minifyStyles,
    cleanupIDs,
    removeUselessDefs,
    cleanupNumericValues,
    convertColors,
    removeUnknownsAndDefaults,
    removeNonInheritableGroupAttrs,
    removeUselessStrokeAndFill,
    removeViewBox,
    cleanupEnableBackground,
    removeHiddenElems,
    removeEmptyText,
    convertShapeToPath,
    convertEllipseToCircle,
    moveElemsAttrsToGroup,
    moveGroupAttrsToElems,
    collapseGroups,
    convertPathData,
    convertTransform,
    removeEmptyAttrs,
    removeEmptyContainers,
    mergePaths,
    removeUnusedNS,
    sortDefsChildren,
    removeTitle,
    removeDesc,
  ],
});

var presetDefault_1 = presetDefault;

var addAttributesToSVGElement = {};

addAttributesToSVGElement.name = 'addAttributesToSVGElement';
addAttributesToSVGElement.type = 'visitor';
addAttributesToSVGElement.active = false;
addAttributesToSVGElement.description = 'adds attributes to an outer <svg> element';

var ENOCLS$1 = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;

/**
 * Add attributes to an outer <svg> element. Example config:
 *
 * @author April Arcus
 *
 * @type {import('../lib/types').Plugin<{
 *   attribute?: string | Record<string, null | string>,
 *   attributes?: Array<string | Record<string, null | string>>
 * }>}
 */
addAttributesToSVGElement.fn = (root, params) => {
  if (!Array.isArray(params.attributes) && !params.attribute) {
    console.error(ENOCLS$1);
    return null;
  }
  const attributes = params.attributes || [params.attribute];
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'svg' && parentNode.type === 'root') {
          for (const attribute of attributes) {
            if (typeof attribute === 'string') {
              if (node.attributes[attribute] == null) {
                // @ts-ignore disallow explicit nullable attribute value
                node.attributes[attribute] = undefined;
              }
            }
            if (typeof attribute === 'object') {
              for (const key of Object.keys(attribute)) {
                if (node.attributes[key] == null) {
                  // @ts-ignore disallow explicit nullable attribute value
                  node.attributes[key] = attribute[key];
                }
              }
            }
          }
        }
      },
    },
  };
};

var addClassesToSVGElement = {};

addClassesToSVGElement.name = 'addClassesToSVGElement';
addClassesToSVGElement.type = 'visitor';
addClassesToSVGElement.active = false;
addClassesToSVGElement.description = 'adds classnames to an outer <svg> element';

var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;

/**
 * Add classnames to an outer <svg> element. Example config:
 *
 * plugins: [
 *   {
 *     name: "addClassesToSVGElement",
 *     params: {
 *       className: "mySvg"
 *     }
 *   }
 * ]
 *
 * plugins: [
 *   {
 *     name: "addClassesToSVGElement",
 *     params: {
 *       classNames: ["mySvg", "size-big"]
 *     }
 *   }
 * ]
 *
 * @author April Arcus
 *
 * @type {import('../lib/types').Plugin<{
 *   className?: string,
 *   classNames?: Array<string>
 * }>}
 */
addClassesToSVGElement.fn = (root, params) => {
  if (
    !(Array.isArray(params.classNames) && params.classNames.some(String)) &&
    !params.className
  ) {
    console.error(ENOCLS);
    return null;
  }
  const classNames = params.classNames || [params.className];
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'svg' && parentNode.type === 'root') {
          const classList = new Set(
            node.attributes.class == null
              ? null
              : node.attributes.class.split(' ')
          );
          for (const className of classNames) {
            if (className != null) {
              classList.add(className);
            }
          }
          node.attributes.class = Array.from(classList).join(' ');
        }
      },
    },
  };
};

var cleanupListOfValues = {};

const { removeLeadingZero } = tools;

cleanupListOfValues.name = 'cleanupListOfValues';
cleanupListOfValues.type = 'visitor';
cleanupListOfValues.active = false;
cleanupListOfValues.description = 'rounds list of values to the fixed precision';

const regNumericValues =
  /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
const regSeparator = /\s+,?\s*|,\s*/;
const absoluteLengths = {
  // relative to px
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  in: 96,
  pt: 4 / 3,
  pc: 16,
  px: 1,
};

/**
 * Round list of values to the fixed precision.
 *
 * @example
 * <svg viewBox="0 0 200.28423 200.28423" enable-background="new 0 0 200.28423 200.28423">
 *         â¬‡
 * <svg viewBox="0 0 200.284 200.284" enable-background="new 0 0 200.284 200.284">
 *
 * <polygon points="208.250977 77.1308594 223.069336 ... "/>
 *         â¬‡
 * <polygon points="208.251 77.131 223.069 ... "/>
 *
 * @author kiyopikko
 *
 * @type {import('../lib/types').Plugin<{
 *   floatPrecision?: number,
 *   leadingZero?: boolean,
 *   defaultPx?: boolean,
 *   convertToPx?: boolean
 * }>}
 */
cleanupListOfValues.fn = (_root, params) => {
  const {
    floatPrecision = 3,
    leadingZero = true,
    defaultPx = true,
    convertToPx = true,
  } = params;

  /**
   * @type {(lists: string) => string}
   */
  const roundValues = (lists) => {
    const roundedList = [];

    for (const elem of lists.split(regSeparator)) {
      const match = elem.match(regNumericValues);
      const matchNew = elem.match(/new/);

      // if attribute value matches regNumericValues
      if (match) {
        // round it to the fixed precision
        let num = Number(Number(match[1]).toFixed(floatPrecision));
        /**
         * @type {any}
         */
        let matchedUnit = match[3] || '';
        /**
         * @type{'' | keyof typeof absoluteLengths}
         */
        let units = matchedUnit;

        // convert absolute values to pixels
        if (convertToPx && units && units in absoluteLengths) {
          const pxNum = Number(
            (absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision)
          );

          if (pxNum.toString().length < match[0].length) {
            num = pxNum;
            units = 'px';
          }
        }

        // and remove leading zero
        let str;
        if (leadingZero) {
          str = removeLeadingZero(num);
        } else {
          str = num.toString();
        }

        // remove default 'px' units
        if (defaultPx && units === 'px') {
          units = '';
        }

        roundedList.push(str + units);
      }
      // if attribute value is "new"(only enable-background).
      else if (matchNew) {
        roundedList.push('new');
      } else if (elem) {
        roundedList.push(elem);
      }
    }

    return roundedList.join(' ');
  };

  return {
    element: {
      enter: (node) => {
        if (node.attributes.points != null) {
          node.attributes.points = roundValues(node.attributes.points);
        }

        if (node.attributes['enable-background'] != null) {
          node.attributes['enable-background'] = roundValues(
            node.attributes['enable-background']
          );
        }

        if (node.attributes.viewBox != null) {
          node.attributes.viewBox = roundValues(node.attributes.viewBox);
        }

        if (node.attributes['stroke-dasharray'] != null) {
          node.attributes['stroke-dasharray'] = roundValues(
            node.attributes['stroke-dasharray']
          );
        }

        if (node.attributes.dx != null) {
          node.attributes.dx = roundValues(node.attributes.dx);
        }

        if (node.attributes.dy != null) {
          node.attributes.dy = roundValues(node.attributes.dy);
        }

        if (node.attributes.x != null) {
          node.attributes.x = roundValues(node.attributes.x);
        }

        if (node.attributes.y != null) {
          node.attributes.y = roundValues(node.attributes.y);
        }
      },
    },
  };
};

var convertStyleToAttrs = {};

convertStyleToAttrs.name = 'convertStyleToAttrs';

convertStyleToAttrs.type = 'perItem';

convertStyleToAttrs.active = false;

convertStyleToAttrs.description = 'converts style to attributes';

convertStyleToAttrs.params = {
  keepImportant: false,
};

var stylingProps = _collections.attrsGroups.presentation,
  rEscape = '\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)', // Like \" or \2051. Code points consume one space.
  rAttr = '\\s*(' + g('[^:;\\\\]', rEscape) + '*?)\\s*', // attribute name like â€˜fillâ€™
  rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)", // string in single quotes: 'smth'
  rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)', // string in double quotes: "smth"
  rQuotedString = new RegExp('^' + g(rSingleQuotes, rQuotes) + '$'),
  // Parentheses, E.g.: url(data:image/png;base64,iVBO...).
  // ':' and ';' inside of it should be threated as is. (Just like in strings.)
  rParenthesis =
    '\\(' + g('[^\'"()\\\\]+', rEscape, rSingleQuotes, rQuotes) + '*?' + '\\)',
  // The value. It can have strings and parentheses (see above). Fallbacks to anything in case of unexpected input.
  rValue =
    '\\s*(' +
    g(
      '[^!\'"();\\\\]+?',
      rEscape,
      rSingleQuotes,
      rQuotes,
      rParenthesis,
      '[^;]*?'
    ) +
    '*?' +
    ')',
  // End of declaration. Spaces outside of capturing groups help to do natural trimming.
  rDeclEnd = '\\s*(?:;\\s*|$)',
  // Important rule
  rImportant = '(\\s*!important(?![-(\\w]))?',
  // Final RegExp to parse CSS declarations.
  regDeclarationBlock = new RegExp(
    rAttr + ':' + rValue + rImportant + rDeclEnd,
    'ig'
  ),
  // Comments expression. Honors escape sequences and strings.
  regStripComments = new RegExp(
    g(rEscape, rSingleQuotes, rQuotes, '/\\*[^]*?\\*/'),
    'ig'
  );

/**
 * Convert style in attributes. Cleanups comments and illegal declarations (without colon) as a side effect.
 *
 * @example
 * <g style="fill:#000; color: #fff;">
 *             â¬‡
 * <g fill="#000" color="#fff">
 *
 * @example
 * <g style="fill:#000; color: #fff; -webkit-blah: blah">
 *             â¬‡
 * <g fill="#000" color="#fff" style="-webkit-blah: blah">
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
convertStyleToAttrs.fn = function (item, params) {
  if (item.type === 'element' && item.attributes.style != null) {
    // ['opacity: 1', 'color: #000']
    let styles = [];
    const newAttributes = {};

    // Strip CSS comments preserving escape sequences and strings.
    const styleValue = item.attributes.style.replace(
      regStripComments,
      (match) => {
        return match[0] == '/'
          ? ''
          : match[0] == '\\' && /[-g-z]/i.test(match[1])
          ? match[1]
          : match;
      }
    );

    regDeclarationBlock.lastIndex = 0;
    // eslint-disable-next-line no-cond-assign
    for (var rule; (rule = regDeclarationBlock.exec(styleValue)); ) {
      if (!params.keepImportant || !rule[3]) {
        styles.push([rule[1], rule[2]]);
      }
    }

    if (styles.length) {
      styles = styles.filter(function (style) {
        if (style[0]) {
          var prop = style[0].toLowerCase(),
            val = style[1];

          if (rQuotedString.test(val)) {
            val = val.slice(1, -1);
          }

          if (stylingProps.includes(prop)) {
            newAttributes[prop] = val;

            return false;
          }
        }

        return true;
      });

      Object.assign(item.attributes, newAttributes);

      if (styles.length) {
        item.attributes.style = styles
          .map((declaration) => declaration.join(':'))
          .join(';');
      } else {
        delete item.attributes.style;
      }
    }
  }
};

function g() {
  return '(?:' + Array.prototype.join.call(arguments, '|') + ')';
}

var prefixIds = {};

const csstree = libExports;
const { referencesProps } = _collections;

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').PluginInfo} PluginInfo
 */

prefixIds.type = 'visitor';
prefixIds.name = 'prefixIds';
prefixIds.active = false;
prefixIds.description = 'prefix IDs';

/**
 * extract basename from path
 * @type {(path: string) => string}
 */
const getBasename = (path) => {
  // extract everything after latest slash or backslash
  const matched = path.match(/[/\\]?([^/\\]+)$/);
  if (matched) {
    return matched[1];
  }
  return '';
};

/**
 * escapes a string for being used as ID
 * @type {(string: string) => string}
 */
const escapeIdentifierName = (str) => {
  return str.replace(/[. ]/g, '_');
};

/**
 * @type {(string: string) => string}
 */
const unquote = (string) => {
  if (
    (string.startsWith('"') && string.endsWith('"')) ||
    (string.startsWith("'") && string.endsWith("'"))
  ) {
    return string.slice(1, -1);
  }
  return string;
};

/**
 * prefix an ID
 * @type {(prefix: string, name: string) => string}
 */
const prefixId = (prefix, value) => {
  if (value.startsWith(prefix)) {
    return value;
  }
  return prefix + value;
};

/**
 * prefix an #ID
 * @type {(prefix: string, name: string) => string | null}
 */
const prefixReference = (prefix, value) => {
  if (value.startsWith('#')) {
    return '#' + prefixId(prefix, value.slice(1));
  }
  return null;
};

/**
 * Prefixes identifiers
 *
 * @author strarsis <strarsis@gmail.com>
 *
 * @type {import('../lib/types').Plugin<{
 *   prefix?: boolean | string | ((node: XastElement, info: PluginInfo) => string),
 *   delim?: string,
 *   prefixIds?: boolean,
 *   prefixClassNames?: boolean,
 * }>}
 */
prefixIds.fn = (_root, params, info) => {
  const { delim = '__', prefixIds = true, prefixClassNames = true } = params;

  return {
    element: {
      enter: (node) => {
        /**
         * prefix, from file name or option
         * @type {string}
         */
        let prefix = 'prefix' + delim;
        if (typeof params.prefix === 'function') {
          prefix = params.prefix(node, info) + delim;
        } else if (typeof params.prefix === 'string') {
          prefix = params.prefix + delim;
        } else if (params.prefix === false) {
          prefix = '';
        } else if (info.path != null && info.path.length > 0) {
          prefix = escapeIdentifierName(getBasename(info.path)) + delim;
        }

        // prefix id/class selectors and url() references in styles
        if (node.name === 'style') {
          // skip empty <style/> elements
          if (node.children.length === 0) {
            return;
          }

          // parse styles
          let cssText = '';
          if (
            node.children[0].type === 'text' ||
            node.children[0].type === 'cdata'
          ) {
            cssText = node.children[0].value;
          }
          /**
           * @type {null | csstree.CssNode}
           */
          let cssAst = null;
          try {
            cssAst = csstree.parse(cssText, {
              parseValue: true,
              parseCustomProperty: false,
            });
          } catch {
            return;
          }

          csstree.walk(cssAst, (node) => {
            // #ID, .class selectors
            if (
              (prefixIds && node.type === 'IdSelector') ||
              (prefixClassNames && node.type === 'ClassSelector')
            ) {
              node.name = prefixId(prefix, node.name);
              return;
            }
            // url(...) references
            if (
              node.type === 'Url' &&
              node.value.value &&
              node.value.value.length > 0
            ) {
              const prefixed = prefixReference(
                prefix,
                unquote(node.value.value)
              );
              if (prefixed != null) {
                node.value.value = prefixed;
              }
            }
          });

          // update styles
          if (
            node.children[0].type === 'text' ||
            node.children[0].type === 'cdata'
          ) {
            node.children[0].value = csstree.generate(cssAst);
          }
          return;
        }

        // prefix an ID attribute value
        if (
          prefixIds &&
          node.attributes.id != null &&
          node.attributes.id.length !== 0
        ) {
          node.attributes.id = prefixId(prefix, node.attributes.id);
        }

        // prefix a class attribute value
        if (
          prefixClassNames &&
          node.attributes.class != null &&
          node.attributes.class.length !== 0
        ) {
          node.attributes.class = node.attributes.class
            .split(/\s+/)
            .map((name) => prefixId(prefix, name))
            .join(' ');
        }

        // prefix a href attribute value
        // xlink:href is deprecated, must be still supported
        for (const name of ['href', 'xlink:href']) {
          if (
            node.attributes[name] != null &&
            node.attributes[name].length !== 0
          ) {
            const prefixed = prefixReference(prefix, node.attributes[name]);
            if (prefixed != null) {
              node.attributes[name] = prefixed;
            }
          }
        }

        // prefix an URL attribute value
        for (const name of referencesProps) {
          if (
            node.attributes[name] != null &&
            node.attributes[name].length !== 0
          ) {
            node.attributes[name] = node.attributes[name].replace(
              /url\((.*?)\)/gi,
              (match, url) => {
                const prefixed = prefixReference(prefix, url);
                if (prefixed == null) {
                  return match;
                }
                return `url(${prefixed})`;
              }
            );
          }
        }

        // prefix begin/end attribute value
        for (const name of ['begin', 'end']) {
          if (
            node.attributes[name] != null &&
            node.attributes[name].length !== 0
          ) {
            const parts = node.attributes[name].split(/\s*;\s+/).map((val) => {
              if (val.endsWith('.end') || val.endsWith('.start')) {
                const [id, postfix] = val.split('.');
                return `${prefixId(prefix, id)}.${postfix}`;
              }
              return val;
            });
            node.attributes[name] = parts.join('; ');
          }
        }
      },
    },
  };
};

var removeAttributesBySelector = {};

const { querySelectorAll } = xast;

removeAttributesBySelector.name = 'removeAttributesBySelector';
removeAttributesBySelector.type = 'visitor';
removeAttributesBySelector.active = false;
removeAttributesBySelector.description =
  'removes attributes of elements that match a css selector';

/**
 * Removes attributes of elements that match a css selector.
 *
 * @example
 * <caption>A selector removing a single attribute</caption>
 * plugins: [
 *   {
 *     name: "removeAttributesBySelector",
 *     params: {
 *       selector: "[fill='#00ff00']"
 *       attributes: "fill"
 *     }
 *   }
 * ]
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   â†“
 * <rect x="0" y="0" width="100" height="100" stroke="#00ff00"/>
 *
 * <caption>A selector removing multiple attributes</caption>
 * plugins: [
 *   {
 *     name: "removeAttributesBySelector",
 *     params: {
 *       selector: "[fill='#00ff00']",
 *       attributes: [
 *         "fill",
 *         "stroke"
 *       ]
 *     }
 *   }
 * ]
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   â†“
 * <rect x="0" y="0" width="100" height="100"/>
 *
 * <caption>Multiple selectors removing attributes</caption>
 * plugins: [
 *   {
 *     name: "removeAttributesBySelector",
 *     params: {
 *       selectors: [
 *         {
 *           selector: "[fill='#00ff00']",
 *           attributes: "fill"
 *         },
 *         {
 *           selector: "#remove",
 *           attributes: [
 *             "stroke",
 *             "id"
 *           ]
 *         }
 *       ]
 *     }
 *   }
 * ]
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   â†“
 * <rect x="0" y="0" width="100" height="100"/>
 *
 * @link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|MDN CSS Selectors
 *
 * @author Bradley Mease
 *
 * @type {import('../lib/types').Plugin<any>}
 */
removeAttributesBySelector.fn = (root, params) => {
  const selectors = Array.isArray(params.selectors)
    ? params.selectors
    : [params];
  for (const { selector, attributes } of selectors) {
    const nodes = querySelectorAll(root, selector);
    for (const node of nodes) {
      if (node.type === 'element') {
        if (Array.isArray(attributes)) {
          for (const name of attributes) {
            delete node.attributes[name];
          }
        } else {
          delete node.attributes[attributes];
        }
      }
    }
  }
  return {};
};

var removeAttrs = {};

removeAttrs.name = 'removeAttrs';
removeAttrs.type = 'visitor';
removeAttrs.active = false;
removeAttrs.description = 'removes specified attributes';

const DEFAULT_SEPARATOR = ':';
const ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;

/**
 * Remove attributes
 *
 * @example elemSeparator
 *   format: string
 *
 * @example preserveCurrentColor
 *   format: boolean
 *
 * @example attrs:
 *
 *   format: [ element* : attribute* : value* ]
 *
 *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)
 *   attribute : regexp (wrapped into ^...$)
 *   value     : regexp (wrapped into ^...$), single * or omitted > all values
 *
 *   examples:
 *
 *     > basic: remove fill attribute
 *     ---
 *     removeAttrs:
 *       attrs: 'fill'
 *
 *     > remove fill attribute on path element
 *     ---
 *       attrs: 'path:fill'
 *
 *     > remove fill attribute on path element where value is none
 *     ---
 *       attrs: 'path:fill:none'
 *
 *
 *     > remove all fill and stroke attribute
 *     ---
 *       attrs:
 *         - 'fill'
 *         - 'stroke'
 *
 *     [is same as]
 *
 *       attrs: '(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '*:(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '.*:(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '.*:(fill|stroke):.*'
 *
 *
 *     > remove all stroke related attributes
 *     ----
 *     attrs: 'stroke.*'
 *
 *
 * @author Benny Schudel
 *
 * @type {import('../lib/types').Plugin<{
 *   elemSeparator?: string,
 *   preserveCurrentColor?: boolean,
 *   attrs: string | Array<string>
 * }>}
 */
removeAttrs.fn = (root, params) => {
  if (typeof params.attrs == 'undefined') {
    console.warn(ENOATTRS);
    return null;
  }

  const elemSeparator =
    typeof params.elemSeparator == 'string'
      ? params.elemSeparator
      : DEFAULT_SEPARATOR;
  const preserveCurrentColor =
    typeof params.preserveCurrentColor == 'boolean'
      ? params.preserveCurrentColor
      : false;
  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];

  return {
    element: {
      enter: (node) => {
        for (let pattern of attrs) {
          // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*
          if (pattern.includes(elemSeparator) === false) {
            pattern = ['.*', elemSeparator, pattern, elemSeparator, '.*'].join(
              ''
            );
            // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value
          } else if (pattern.split(elemSeparator).length < 3) {
            pattern = [pattern, elemSeparator, '.*'].join('');
          }

          // create regexps for element, attribute name, and attribute value
          const list = pattern.split(elemSeparator).map((value) => {
            // adjust single * to match anything
            if (value === '*') {
              value = '.*';
            }
            return new RegExp(['^', value, '$'].join(''), 'i');
          });

          // matches element
          if (list[0].test(node.name)) {
            // loop attributes
            for (const [name, value] of Object.entries(node.attributes)) {
              const isFillCurrentColor =
                preserveCurrentColor &&
                name == 'fill' &&
                value == 'currentColor';
              const isStrokeCurrentColor =
                preserveCurrentColor &&
                name == 'stroke' &&
                value == 'currentColor';
              if (
                !isFillCurrentColor &&
                !isStrokeCurrentColor &&
                // matches attribute name
                list[1].test(name) &&
                // matches attribute value
                list[2].test(value)
              ) {
                delete node.attributes[name];
              }
            }
          }
        }
      },
    },
  };
};

var removeDimensions = {};

removeDimensions.name = 'removeDimensions';

removeDimensions.type = 'perItem';

removeDimensions.active = false;

removeDimensions.description =
  'removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)';

/**
 * Remove width/height attributes and add the viewBox attribute if it's missing
 *
 * @example
 * <svg width="100" height="50" />
 *   â†“
 * <svg viewBox="0 0 100 50" />
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if true, with and height will be filtered out
 *
 * @author Benny Schudel
 */
removeDimensions.fn = function (item) {
  if (item.type === 'element' && item.name === 'svg') {
    if (item.attributes.viewBox != null) {
      delete item.attributes.width;
      delete item.attributes.height;
    } else if (
      item.attributes.width != null &&
      item.attributes.height != null &&
      Number.isNaN(Number(item.attributes.width)) === false &&
      Number.isNaN(Number(item.attributes.height)) === false
    ) {
      const width = Number(item.attributes.width);
      const height = Number(item.attributes.height);
      item.attributes.viewBox = `0 0 ${width} ${height}`;
      delete item.attributes.width;
      delete item.attributes.height;
    }
  }
};

var removeElementsByAttr = {};

const { detachNodeFromParent: detachNodeFromParent$4 } = xast;

removeElementsByAttr.name = 'removeElementsByAttr';
removeElementsByAttr.type = 'visitor';
removeElementsByAttr.active = false;
removeElementsByAttr.description =
  'removes arbitrary elements by ID or className (disabled by default)';

/**
 * Remove arbitrary SVG elements by ID or className.
 *
 * @example id
 *     > single: remove element with ID of `elementID`
 *     ---
 *     removeElementsByAttr:
 *       id: 'elementID'
 *
 *     > list: remove multiple elements by ID
 *     ---
 *     removeElementsByAttr:
 *       id:
 *         - 'elementID'
 *         - 'anotherID'
 *
 * @example class
 *     > single: remove all elements with class of `elementClass`
 *     ---
 *     removeElementsByAttr:
 *       class: 'elementClass'
 *
 *     > list: remove all elements with class of `elementClass` or `anotherClass`
 *     ---
 *     removeElementsByAttr:
 *       class:
 *         - 'elementClass'
 *         - 'anotherClass'
 *
 * @author Eli Dupuis (@elidupuis)
 *
 * @type {import('../lib/types').Plugin<{
 *   id?: string | Array<string>,
 *   class?: string | Array<string>
 * }>}
 */
removeElementsByAttr.fn = (root, params) => {
  const ids =
    params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
  const classes =
    params.class == null
      ? []
      : Array.isArray(params.class)
      ? params.class
      : [params.class];
  return {
    element: {
      enter: (node, parentNode) => {
        // remove element if it's `id` matches configured `id` params
        if (node.attributes.id != null && ids.length !== 0) {
          if (ids.includes(node.attributes.id)) {
            detachNodeFromParent$4(node, parentNode);
          }
        }
        // remove element if it's `class` contains any of the configured `class` params
        if (node.attributes.class && classes.length !== 0) {
          const classList = node.attributes.class.split(' ');
          for (const item of classes) {
            if (classList.includes(item)) {
              detachNodeFromParent$4(node, parentNode);
              break;
            }
          }
        }
      },
    },
  };
};

var removeOffCanvasPaths = {};

/**
 * @typedef {import('../lib/types').PathDataItem} PathDataItem
 */

const { visitSkip, detachNodeFromParent: detachNodeFromParent$3 } = xast;
const { parsePathData } = path;
const { intersects } = _path;

removeOffCanvasPaths.type = 'visitor';
removeOffCanvasPaths.name = 'removeOffCanvasPaths';
removeOffCanvasPaths.active = false;
removeOffCanvasPaths.description =
  'removes elements that are drawn outside of the viewbox (disabled by default)';

/**
 * Remove elements that are drawn outside of the viewbox.
 *
 * @author JoshyPHP
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeOffCanvasPaths.fn = () => {
  /**
   * @type {null | {
   *   top: number,
   *   right: number,
   *   bottom: number,
   *   left: number,
   *   width: number,
   *   height: number
   * }}
   */
  let viewBoxData = null;

  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'svg' && parentNode.type === 'root') {
          let viewBox = '';
          // find viewbox
          if (node.attributes.viewBox != null) {
            // remove commas and plus signs, normalize and trim whitespace
            viewBox = node.attributes.viewBox;
          } else if (
            node.attributes.height != null &&
            node.attributes.width != null
          ) {
            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
          }

          // parse viewbox
          // remove commas and plus signs, normalize and trim whitespace
          viewBox = viewBox
            .replace(/[,+]|px/g, ' ')
            .replace(/\s+/g, ' ')
            .replace(/^\s*|\s*$/g, '');
          // ensure that the dimensions are 4 values separated by space
          const m =
            /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
              viewBox
            );
          if (m == null) {
            return;
          }
          const left = Number.parseFloat(m[1]);
          const top = Number.parseFloat(m[2]);
          const width = Number.parseFloat(m[3]);
          const height = Number.parseFloat(m[4]);

          // store the viewBox boundaries
          viewBoxData = {
            left,
            top,
            right: left + width,
            bottom: top + height,
            width,
            height,
          };
        }

        // consider that any item with a transform attribute is visible
        if (node.attributes.transform != null) {
          return visitSkip;
        }

        if (
          node.name === 'path' &&
          node.attributes.d != null &&
          viewBoxData != null
        ) {
          const pathData = parsePathData(node.attributes.d);

          // consider that a M command within the viewBox is visible
          let visible = false;
          for (const pathDataItem of pathData) {
            if (pathDataItem.command === 'M') {
              const [x, y] = pathDataItem.args;
              if (
                x >= viewBoxData.left &&
                x <= viewBoxData.right &&
                y >= viewBoxData.top &&
                y <= viewBoxData.bottom
              ) {
                visible = true;
              }
            }
          }
          if (visible) {
            return;
          }

          if (pathData.length === 2) {
            // close the path too short for intersects()
            pathData.push({ command: 'z', args: [] });
          }

          const { left, top, width, height } = viewBoxData;
          /**
           * @type {Array<PathDataItem>}
           */
          const viewBoxPathData = [
            { command: 'M', args: [left, top] },
            { command: 'h', args: [width] },
            { command: 'v', args: [height] },
            { command: 'H', args: [left] },
            { command: 'z', args: [] },
          ];

          if (intersects(viewBoxPathData, pathData) === false) {
            detachNodeFromParent$3(node, parentNode);
          }
        }
      },
    },
  };
};

var removeRasterImages = {};

const { detachNodeFromParent: detachNodeFromParent$2 } = xast;

removeRasterImages.name = 'removeRasterImages';
removeRasterImages.type = 'visitor';
removeRasterImages.active = false;
removeRasterImages.description = 'removes raster images (disabled by default)';

/**
 * Remove raster images references in <image>.
 *
 * @see https://bugs.webkit.org/show_bug.cgi?id=63548
 *
 * @author Kir Belevich
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeRasterImages.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (
          node.name === 'image' &&
          node.attributes['xlink:href'] != null &&
          /(\.|image\/)(jpg|png|gif)/.test(node.attributes['xlink:href'])
        ) {
          detachNodeFromParent$2(node, parentNode);
        }
      },
    },
  };
};

var removeScriptElement = {};

const { detachNodeFromParent: detachNodeFromParent$1 } = xast;

removeScriptElement.name = 'removeScriptElement';
removeScriptElement.type = 'visitor';
removeScriptElement.active = false;
removeScriptElement.description = 'removes <script> elements (disabled by default)';

/**
 * Remove <script>.
 *
 * https://www.w3.org/TR/SVG11/script.html
 *
 * @author Patrick Klingemann
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeScriptElement.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'script') {
          detachNodeFromParent$1(node, parentNode);
        }
      },
    },
  };
};

var removeStyleElement = {};

const { detachNodeFromParent } = xast;

removeStyleElement.name = 'removeStyleElement';
removeStyleElement.type = 'visitor';
removeStyleElement.active = false;
removeStyleElement.description = 'removes <style> element (disabled by default)';

/**
 * Remove <style>.
 *
 * https://www.w3.org/TR/SVG11/styling.html#StyleElement
 *
 * @author Betsy Dupuis
 *
 * @type {import('../lib/types').Plugin<void>}
 */
removeStyleElement.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === 'style') {
          detachNodeFromParent(node, parentNode);
        }
      },
    },
  };
};

var removeXMLNS = {};

removeXMLNS.name = 'removeXMLNS';

removeXMLNS.type = 'perItem';

removeXMLNS.active = false;

removeXMLNS.description =
  'removes xmlns attribute (for inline svg, disabled by default)';

/**
 * Remove the xmlns attribute when present.
 *
 * @example
 * <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
 *   â†“
 * <svg viewBox="0 0 100 50">
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if true, xmlns will be filtered out
 *
 * @author Ricardo Tomasi
 */
removeXMLNS.fn = function (item) {
  if (item.type === 'element' && item.name === 'svg') {
    delete item.attributes.xmlns;
    delete item.attributes['xmlns:xlink'];
  }
};

var reusePaths = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 * @typedef {import('../lib/types').XastNode} XastNode
 */

const JSAPI$2 = jsAPI;

reusePaths.type = 'visitor';
reusePaths.name = 'reusePaths';
reusePaths.active = false;
reusePaths.description =
  'Finds <path> elements with the same d, fill, and ' +
  'stroke, and converts them to <use> elements ' +
  'referencing a single <path> def.';

/**
 * Finds <path> elements with the same d, fill, and stroke, and converts them to
 * <use> elements referencing a single <path> def.
 *
 * @author Jacob Howcroft
 *
 * @type {import('../lib/types').Plugin<void>}
 */
reusePaths.fn = () => {
  /**
   * @type {Map<string, Array<XastElement>>}
   */
  const paths = new Map();

  return {
    element: {
      enter: (node) => {
        if (node.name === 'path' && node.attributes.d != null) {
          const d = node.attributes.d;
          const fill = node.attributes.fill || '';
          const stroke = node.attributes.stroke || '';
          const key = d + ';s:' + stroke + ';f:' + fill;
          let list = paths.get(key);
          if (list == null) {
            list = [];
            paths.set(key, list);
          }
          list.push(node);
        }
      },

      exit: (node, parentNode) => {
        if (node.name === 'svg' && parentNode.type === 'root') {
          /**
           * @type {XastElement}
           */
          const rawDefs = {
            type: 'element',
            name: 'defs',
            attributes: {},
            children: [],
          };
          /**
           * @type {XastElement}
           */
          const defsTag = new JSAPI$2(rawDefs, node);
          let index = 0;
          for (const list of paths.values()) {
            if (list.length > 1) {
              // add reusable path to defs
              /**
               * @type {XastElement}
               */
              const rawPath = {
                type: 'element',
                name: 'path',
                attributes: { ...list[0].attributes },
                children: [],
              };
              delete rawPath.attributes.transform;
              let id;
              if (rawPath.attributes.id == null) {
                id = 'reuse-' + index;
                index += 1;
                rawPath.attributes.id = id;
              } else {
                id = rawPath.attributes.id;
                delete list[0].attributes.id;
              }
              /**
               * @type {XastElement}
               */
              const reusablePath = new JSAPI$2(rawPath, defsTag);
              defsTag.children.push(reusablePath);
              // convert paths to <use>
              for (const pathNode of list) {
                pathNode.name = 'use';
                pathNode.attributes['xlink:href'] = '#' + id;
                delete pathNode.attributes.d;
                delete pathNode.attributes.stroke;
                delete pathNode.attributes.fill;
              }
            }
          }
          if (defsTag.children.length !== 0) {
            if (node.attributes['xmlns:xlink'] == null) {
              node.attributes['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';
            }
            node.children.unshift(defsTag);
          }
        }
      },
    },
  };
};

var sortAttrs = {};

sortAttrs.type = 'visitor';
sortAttrs.name = 'sortAttrs';
sortAttrs.active = false;
sortAttrs.description = 'Sort element attributes for better compression';

/**
 * Sort element attributes for better compression
 *
 * @author Nikolay Frantsev
 *
 * @type {import('../lib/types').Plugin<{
 *   order?: Array<string>
 *   xmlnsOrder?: 'front' | 'alphabetical'
 * }>}
 */
sortAttrs.fn = (_root, params) => {
  const {
    order = [
      'id',
      'width',
      'height',
      'x',
      'x1',
      'x2',
      'y',
      'y1',
      'y2',
      'cx',
      'cy',
      'r',
      'fill',
      'stroke',
      'marker',
      'd',
      'points',
    ],
    xmlnsOrder = 'front',
  } = params;

  /**
   * @type {(name: string) => number}
   */
  const getNsPriority = (name) => {
    if (xmlnsOrder === 'front') {
      // put xmlns first
      if (name === 'xmlns') {
        return 3;
      }
      // xmlns:* attributes second
      if (name.startsWith('xmlns:')) {
        return 2;
      }
    }
    // other namespaces after and sort them alphabetically
    if (name.includes(':')) {
      return 1;
    }
    // other attributes
    return 0;
  };

  /**
   * @type {(a: [string, string], b: [string, string]) => number}
   */
  const compareAttrs = ([aName], [bName]) => {
    // sort namespaces
    const aPriority = getNsPriority(aName);
    const bPriority = getNsPriority(bName);
    const priorityNs = bPriority - aPriority;
    if (priorityNs !== 0) {
      return priorityNs;
    }
    // extract the first part from attributes
    // for example "fill" from "fill" and "fill-opacity"
    const [aPart] = aName.split('-');
    const [bPart] = bName.split('-');
    // rely on alphabetical sort when the first part is the same
    if (aPart !== bPart) {
      const aInOrderFlag = order.includes(aPart) ? 1 : 0;
      const bInOrderFlag = order.includes(bPart) ? 1 : 0;
      // sort by position in order param
      if (aInOrderFlag === 1 && bInOrderFlag === 1) {
        return order.indexOf(aPart) - order.indexOf(bPart);
      }
      // put attributes from order param before others
      const priorityOrder = bInOrderFlag - aInOrderFlag;
      if (priorityOrder !== 0) {
        return priorityOrder;
      }
    }
    // sort alphabetically
    return aName < bName ? -1 : 1;
  };

  return {
    element: {
      enter: (node) => {
        const attrs = Object.entries(node.attributes);
        attrs.sort(compareAttrs);
        /**
         * @type {Record<string, string>}
         */
        const sortedAttributes = {};
        for (const [name, value] of attrs) {
          sortedAttributes[name] = value;
        }
        node.attributes = sortedAttributes;
      },
    },
  };
};

(function (exports) {

	// builtin presets
	exports['preset-default'] = presetDefault_1;

	// builtin plugins
	exports.addAttributesToSVGElement = addAttributesToSVGElement;
	exports.addClassesToSVGElement = addClassesToSVGElement;
	exports.cleanupAttrs = cleanupAttrs$1;
	exports.cleanupEnableBackground = cleanupEnableBackground$1;
	exports.cleanupIDs = cleanupIDs$1;
	exports.cleanupListOfValues = cleanupListOfValues;
	exports.cleanupNumericValues = cleanupNumericValues$1;
	exports.collapseGroups = collapseGroups$1;
	exports.convertColors = convertColors$1;
	exports.convertEllipseToCircle = convertEllipseToCircle$1;
	exports.convertPathData = convertPathData$1;
	exports.convertShapeToPath = convertShapeToPath$1;
	exports.convertStyleToAttrs = convertStyleToAttrs;
	exports.convertTransform = convertTransform$2;
	exports.mergeStyles = mergeStyles$1;
	exports.inlineStyles = inlineStyles$1;
	exports.mergePaths = mergePaths$1;
	exports.minifyStyles = minifyStyles$1;
	exports.moveElemsAttrsToGroup = moveElemsAttrsToGroup$1;
	exports.moveGroupAttrsToElems = moveGroupAttrsToElems$1;
	exports.prefixIds = prefixIds;
	exports.removeAttributesBySelector = removeAttributesBySelector;
	exports.removeAttrs = removeAttrs;
	exports.removeComments = removeComments$1;
	exports.removeDesc = removeDesc$1;
	exports.removeDimensions = removeDimensions;
	exports.removeDoctype = removeDoctype$1;
	exports.removeEditorsNSData = removeEditorsNSData$1;
	exports.removeElementsByAttr = removeElementsByAttr;
	exports.removeEmptyAttrs = removeEmptyAttrs$1;
	exports.removeEmptyContainers = removeEmptyContainers$1;
	exports.removeEmptyText = removeEmptyText$1;
	exports.removeHiddenElems = removeHiddenElems$1;
	exports.removeMetadata = removeMetadata$1;
	exports.removeNonInheritableGroupAttrs = removeNonInheritableGroupAttrs$1;
	exports.removeOffCanvasPaths = removeOffCanvasPaths;
	exports.removeRasterImages = removeRasterImages;
	exports.removeScriptElement = removeScriptElement;
	exports.removeStyleElement = removeStyleElement;
	exports.removeTitle = removeTitle$1;
	exports.removeUnknownsAndDefaults = removeUnknownsAndDefaults$1;
	exports.removeUnusedNS = removeUnusedNS$1;
	exports.removeUselessDefs = removeUselessDefs$1;
	exports.removeUselessStrokeAndFill = removeUselessStrokeAndFill$1;
	exports.removeViewBox = removeViewBox$1;
	exports.removeXMLNS = removeXMLNS;
	exports.removeXMLProcInst = removeXMLProcInst$1;
	exports.reusePaths = reusePaths;
	exports.sortAttrs = sortAttrs;
	exports.sortDefsChildren = sortDefsChildren$1;
} (plugins$1));

const pluginsMap = plugins$1;

const pluginsOrder = [
  'removeDoctype',
  'removeXMLProcInst',
  'removeComments',
  'removeMetadata',
  'removeXMLNS',
  'removeEditorsNSData',
  'cleanupAttrs',
  'mergeStyles',
  'inlineStyles',
  'minifyStyles',
  'convertStyleToAttrs',
  'cleanupIDs',
  'prefixIds',
  'removeRasterImages',
  'removeUselessDefs',
  'cleanupNumericValues',
  'cleanupListOfValues',
  'convertColors',
  'removeUnknownsAndDefaults',
  'removeNonInheritableGroupAttrs',
  'removeUselessStrokeAndFill',
  'removeViewBox',
  'cleanupEnableBackground',
  'removeHiddenElems',
  'removeEmptyText',
  'convertShapeToPath',
  'convertEllipseToCircle',
  'moveElemsAttrsToGroup',
  'moveGroupAttrsToElems',
  'collapseGroups',
  'convertPathData',
  'convertTransform',
  'removeEmptyAttrs',
  'removeEmptyContainers',
  'mergePaths',
  'removeUnusedNS',
  'sortAttrs',
  'sortDefsChildren',
  'removeTitle',
  'removeDesc',
  'removeDimensions',
  'removeAttrs',
  'removeAttributesBySelector',
  'removeElementsByAttr',
  'addClassesToSVGElement',
  'removeStyleElement',
  'removeScriptElement',
  'addAttributesToSVGElement',
  'removeOffCanvasPaths',
  'reusePaths',
];
const defaultPlugins$1 = pluginsOrder.filter((name) => pluginsMap[name].active);
config$1.defaultPlugins = defaultPlugins$1;

const extendDefaultPlugins$2 = (plugins) => {
  console.warn(
    '\n"extendDefaultPlugins" utility is deprecated.\n' +
      'Use "preset-default" plugin with overrides instead.\n' +
      'For example:\n' +
      `{\n` +
      `  name: 'preset-default',\n` +
      `  params: {\n` +
      `    overrides: {\n` +
      `      // customize plugin options\n` +
      `      convertShapeToPath: {\n` +
      `        convertArcs: true\n` +
      `      },\n` +
      `      // disable plugins\n` +
      `      convertPathData: false\n` +
      `    }\n` +
      `  }\n` +
      `}\n`
  );
  const extendedPlugins = pluginsOrder.map((name) => ({
    name,
    active: pluginsMap[name].active,
  }));
  for (const plugin of plugins) {
    const resolvedPlugin = resolvePluginConfig$1(plugin);
    const index = pluginsOrder.indexOf(resolvedPlugin.name);
    if (index === -1) {
      extendedPlugins.push(plugin);
    } else {
      extendedPlugins[index] = plugin;
    }
  }
  return extendedPlugins;
};
config$1.extendDefaultPlugins = extendDefaultPlugins$2;

const resolvePluginConfig$1 = (plugin) => {
  let configParams = {};
  if (typeof plugin === 'string') {
    // resolve builtin plugin specified as string
    const pluginConfig = pluginsMap[plugin];
    if (pluginConfig == null) {
      throw Error(`Unknown builtin plugin "${plugin}" specified.`);
    }
    return {
      ...pluginConfig,
      name: plugin,
      active: true,
      params: { ...pluginConfig.params, ...configParams },
    };
  }
  if (typeof plugin === 'object' && plugin != null) {
    if (plugin.name == null) {
      throw Error(`Plugin name should be specified`);
    }
    if (plugin.fn) {
      // resolve custom plugin with implementation
      return {
        active: true,
        ...plugin,
        params: { ...configParams, ...plugin.params },
      };
    } else {
      // resolve builtin plugin specified as object without implementation
      const pluginConfig = pluginsMap[plugin.name];
      if (pluginConfig == null) {
        throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
      }
      return {
        ...pluginConfig,
        active: true,
        ...plugin,
        params: { ...pluginConfig.params, ...configParams, ...plugin.params },
      };
    }
  }
  return null;
};
config$1.resolvePluginConfig = resolvePluginConfig$1;

var parser = {};

var sax = {};

(function (exports) {
(function (sax) { // wrapper for non-node envs
	  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) };
	  sax.SAXParser = SAXParser;

	  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
	  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
	  // since that's the earliest that a buffer overrun could occur.  This way, checks are
	  // as rare as required, but as often as necessary to ensure never crossing this bound.
	  // Furthermore, buffers are only tested at most once per write(), so passing a very
	  // large string into write() might have undesirable effects, but this is manageable by
	  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
	  // edge case, result in creating at most one complete copy of the string passed in.
	  // Set to Infinity to have unlimited buffers.
	  sax.MAX_BUFFER_LENGTH = 64 * 1024;

	  var buffers = [
	    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
	    'procInstName', 'procInstBody', 'entity', 'attribName',
	    'attribValue', 'cdata', 'script'
	  ];

	  sax.EVENTS = [
	    'text',
	    'processinginstruction',
	    'sgmldeclaration',
	    'doctype',
	    'comment',
	    'opentagstart',
	    'attribute',
	    'opentag',
	    'closetag',
	    'opencdata',
	    'cdata',
	    'closecdata',
	    'error',
	    'end',
	    'ready',
	    'script',
	    'opennamespace',
	    'closenamespace'
	  ];

	  function SAXParser (strict, opt) {
	    if (!(this instanceof SAXParser)) {
	      return new SAXParser(strict, opt)
	    }

	    var parser = this;
	    clearBuffers(parser);
	    parser.q = parser.c = '';
	    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
	    parser.opt = opt || {};
	    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
	    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
	    parser.tags = [];
	    parser.closed = parser.closedRoot = parser.sawRoot = false;
	    parser.tag = parser.error = null;
	    parser.strict = !!strict;
	    parser.noscript = !!(strict || parser.opt.noscript);
	    parser.state = S.BEGIN;
	    parser.strictEntities = parser.opt.strictEntities;
	    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
	    parser.attribList = [];

	    // namespaces form a prototype chain.
	    // it always points at the current tag,
	    // which protos to its parent tag.
	    if (parser.opt.xmlns) {
	      parser.ns = Object.create(rootNS);
	    }

	    // mostly just for error reporting
	    parser.trackPosition = parser.opt.position !== false;
	    if (parser.trackPosition) {
	      parser.position = parser.line = parser.column = 0;
	    }
	    emit(parser, 'onready');
	  }

	  if (!Object.create) {
	    Object.create = function (o) {
	      function F () {}
	      F.prototype = o;
	      var newf = new F();
	      return newf
	    };
	  }

	  if (!Object.keys) {
	    Object.keys = function (o) {
	      var a = [];
	      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
	      return a
	    };
	  }

	  function checkBufferLength (parser) {
	    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
	    var maxActual = 0;
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      var len = parser[buffers[i]].length;
	      if (len > maxAllowed) {
	        // Text/cdata nodes can get big, and since they're buffered,
	        // we can get here under normal conditions.
	        // Avoid issues by emitting the text node now,
	        // so at least it won't get any bigger.
	        switch (buffers[i]) {
	          case 'textNode':
	            closeText(parser);
	            break

	          case 'cdata':
	            emitNode(parser, 'oncdata', parser.cdata);
	            parser.cdata = '';
	            break

	          case 'script':
	            emitNode(parser, 'onscript', parser.script);
	            parser.script = '';
	            break

	          default:
	            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
	        }
	      }
	      maxActual = Math.max(maxActual, len);
	    }
	    // schedule the next check for the earliest possible buffer overrun.
	    var m = sax.MAX_BUFFER_LENGTH - maxActual;
	    parser.bufferCheckPosition = m + parser.position;
	  }

	  function clearBuffers (parser) {
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      parser[buffers[i]] = '';
	    }
	  }

	  function flushBuffers (parser) {
	    closeText(parser);
	    if (parser.cdata !== '') {
	      emitNode(parser, 'oncdata', parser.cdata);
	      parser.cdata = '';
	    }
	    if (parser.script !== '') {
	      emitNode(parser, 'onscript', parser.script);
	      parser.script = '';
	    }
	  }

	  SAXParser.prototype = {
	    end: function () { end(this); },
	    write: write,
	    resume: function () { this.error = null; return this },
	    close: function () { return this.write(null) },
	    flush: function () { flushBuffers(this); }
	  };

	  // this really needs to be replaced with character classes.
	  // XML allows all manner of ridiculous numbers and digits.
	  var CDATA = '[CDATA[';
	  var DOCTYPE = 'DOCTYPE';
	  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
	  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
	  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

	  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
	  // This implementation works on strings, a single character at a time
	  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
	  // without a significant breaking change to either this  parser, or the
	  // JavaScript language.  Implementation of an emoji-capable xml parser
	  // is left as an exercise for the reader.
	  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

	  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

	  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
	  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

	  function isWhitespace (c) {
	    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
	  }

	  function isQuote (c) {
	    return c === '"' || c === '\''
	  }

	  function isAttribEnd (c) {
	    return c === '>' || isWhitespace(c)
	  }

	  function isMatch (regex, c) {
	    return regex.test(c)
	  }

	  function notMatch (regex, c) {
	    return !isMatch(regex, c)
	  }

	  var S = 0;
	  sax.STATE = {
	    BEGIN: S++, // leading byte order mark or whitespace
	    BEGIN_WHITESPACE: S++, // leading whitespace
	    TEXT: S++, // general stuff
	    TEXT_ENTITY: S++, // &amp and such.
	    OPEN_WAKA: S++, // <
	    SGML_DECL: S++, // <!BLARG
	    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
	    DOCTYPE: S++, // <!DOCTYPE
	    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
	    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
	    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
	    COMMENT_STARTING: S++, // <!-
	    COMMENT: S++, // <!--
	    COMMENT_ENDING: S++, // <!-- blah -
	    COMMENT_ENDED: S++, // <!-- blah --
	    CDATA: S++, // <![CDATA[ something
	    CDATA_ENDING: S++, // ]
	    CDATA_ENDING_2: S++, // ]]
	    PROC_INST: S++, // <?hi
	    PROC_INST_BODY: S++, // <?hi there
	    PROC_INST_ENDING: S++, // <?hi "there" ?
	    OPEN_TAG: S++, // <strong
	    OPEN_TAG_SLASH: S++, // <strong /
	    ATTRIB: S++, // <a
	    ATTRIB_NAME: S++, // <a foo
	    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
	    ATTRIB_VALUE: S++, // <a foo=
	    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
	    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
	    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
	    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
	    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
	    CLOSE_TAG: S++, // </a
	    CLOSE_TAG_SAW_WHITE: S++, // </a   >
	    SCRIPT: S++, // <script> ...
	    SCRIPT_ENDING: S++ // <script> ... <
	  };

	  sax.XML_ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'"
	  };

	  sax.ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'",
	    'AElig': 198,
	    'Aacute': 193,
	    'Acirc': 194,
	    'Agrave': 192,
	    'Aring': 197,
	    'Atilde': 195,
	    'Auml': 196,
	    'Ccedil': 199,
	    'ETH': 208,
	    'Eacute': 201,
	    'Ecirc': 202,
	    'Egrave': 200,
	    'Euml': 203,
	    'Iacute': 205,
	    'Icirc': 206,
	    'Igrave': 204,
	    'Iuml': 207,
	    'Ntilde': 209,
	    'Oacute': 211,
	    'Ocirc': 212,
	    'Ograve': 210,
	    'Oslash': 216,
	    'Otilde': 213,
	    'Ouml': 214,
	    'THORN': 222,
	    'Uacute': 218,
	    'Ucirc': 219,
	    'Ugrave': 217,
	    'Uuml': 220,
	    'Yacute': 221,
	    'aacute': 225,
	    'acirc': 226,
	    'aelig': 230,
	    'agrave': 224,
	    'aring': 229,
	    'atilde': 227,
	    'auml': 228,
	    'ccedil': 231,
	    'eacute': 233,
	    'ecirc': 234,
	    'egrave': 232,
	    'eth': 240,
	    'euml': 235,
	    'iacute': 237,
	    'icirc': 238,
	    'igrave': 236,
	    'iuml': 239,
	    'ntilde': 241,
	    'oacute': 243,
	    'ocirc': 244,
	    'ograve': 242,
	    'oslash': 248,
	    'otilde': 245,
	    'ouml': 246,
	    'szlig': 223,
	    'thorn': 254,
	    'uacute': 250,
	    'ucirc': 251,
	    'ugrave': 249,
	    'uuml': 252,
	    'yacute': 253,
	    'yuml': 255,
	    'copy': 169,
	    'reg': 174,
	    'nbsp': 160,
	    'iexcl': 161,
	    'cent': 162,
	    'pound': 163,
	    'curren': 164,
	    'yen': 165,
	    'brvbar': 166,
	    'sect': 167,
	    'uml': 168,
	    'ordf': 170,
	    'laquo': 171,
	    'not': 172,
	    'shy': 173,
	    'macr': 175,
	    'deg': 176,
	    'plusmn': 177,
	    'sup1': 185,
	    'sup2': 178,
	    'sup3': 179,
	    'acute': 180,
	    'micro': 181,
	    'para': 182,
	    'middot': 183,
	    'cedil': 184,
	    'ordm': 186,
	    'raquo': 187,
	    'frac14': 188,
	    'frac12': 189,
	    'frac34': 190,
	    'iquest': 191,
	    'times': 215,
	    'divide': 247,
	    'OElig': 338,
	    'oelig': 339,
	    'Scaron': 352,
	    'scaron': 353,
	    'Yuml': 376,
	    'fnof': 402,
	    'circ': 710,
	    'tilde': 732,
	    'Alpha': 913,
	    'Beta': 914,
	    'Gamma': 915,
	    'Delta': 916,
	    'Epsilon': 917,
	    'Zeta': 918,
	    'Eta': 919,
	    'Theta': 920,
	    'Iota': 921,
	    'Kappa': 922,
	    'Lambda': 923,
	    'Mu': 924,
	    'Nu': 925,
	    'Xi': 926,
	    'Omicron': 927,
	    'Pi': 928,
	    'Rho': 929,
	    'Sigma': 931,
	    'Tau': 932,
	    'Upsilon': 933,
	    'Phi': 934,
	    'Chi': 935,
	    'Psi': 936,
	    'Omega': 937,
	    'alpha': 945,
	    'beta': 946,
	    'gamma': 947,
	    'delta': 948,
	    'epsilon': 949,
	    'zeta': 950,
	    'eta': 951,
	    'theta': 952,
	    'iota': 953,
	    'kappa': 954,
	    'lambda': 955,
	    'mu': 956,
	    'nu': 957,
	    'xi': 958,
	    'omicron': 959,
	    'pi': 960,
	    'rho': 961,
	    'sigmaf': 962,
	    'sigma': 963,
	    'tau': 964,
	    'upsilon': 965,
	    'phi': 966,
	    'chi': 967,
	    'psi': 968,
	    'omega': 969,
	    'thetasym': 977,
	    'upsih': 978,
	    'piv': 982,
	    'ensp': 8194,
	    'emsp': 8195,
	    'thinsp': 8201,
	    'zwnj': 8204,
	    'zwj': 8205,
	    'lrm': 8206,
	    'rlm': 8207,
	    'ndash': 8211,
	    'mdash': 8212,
	    'lsquo': 8216,
	    'rsquo': 8217,
	    'sbquo': 8218,
	    'ldquo': 8220,
	    'rdquo': 8221,
	    'bdquo': 8222,
	    'dagger': 8224,
	    'Dagger': 8225,
	    'bull': 8226,
	    'hellip': 8230,
	    'permil': 8240,
	    'prime': 8242,
	    'Prime': 8243,
	    'lsaquo': 8249,
	    'rsaquo': 8250,
	    'oline': 8254,
	    'frasl': 8260,
	    'euro': 8364,
	    'image': 8465,
	    'weierp': 8472,
	    'real': 8476,
	    'trade': 8482,
	    'alefsym': 8501,
	    'larr': 8592,
	    'uarr': 8593,
	    'rarr': 8594,
	    'darr': 8595,
	    'harr': 8596,
	    'crarr': 8629,
	    'lArr': 8656,
	    'uArr': 8657,
	    'rArr': 8658,
	    'dArr': 8659,
	    'hArr': 8660,
	    'forall': 8704,
	    'part': 8706,
	    'exist': 8707,
	    'empty': 8709,
	    'nabla': 8711,
	    'isin': 8712,
	    'notin': 8713,
	    'ni': 8715,
	    'prod': 8719,
	    'sum': 8721,
	    'minus': 8722,
	    'lowast': 8727,
	    'radic': 8730,
	    'prop': 8733,
	    'infin': 8734,
	    'ang': 8736,
	    'and': 8743,
	    'or': 8744,
	    'cap': 8745,
	    'cup': 8746,
	    'int': 8747,
	    'there4': 8756,
	    'sim': 8764,
	    'cong': 8773,
	    'asymp': 8776,
	    'ne': 8800,
	    'equiv': 8801,
	    'le': 8804,
	    'ge': 8805,
	    'sub': 8834,
	    'sup': 8835,
	    'nsub': 8836,
	    'sube': 8838,
	    'supe': 8839,
	    'oplus': 8853,
	    'otimes': 8855,
	    'perp': 8869,
	    'sdot': 8901,
	    'lceil': 8968,
	    'rceil': 8969,
	    'lfloor': 8970,
	    'rfloor': 8971,
	    'lang': 9001,
	    'rang': 9002,
	    'loz': 9674,
	    'spades': 9824,
	    'clubs': 9827,
	    'hearts': 9829,
	    'diams': 9830
	  };

	  Object.keys(sax.ENTITIES).forEach(function (key) {
	    var e = sax.ENTITIES[key];
	    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
	    sax.ENTITIES[key] = s;
	  });

	  for (var s in sax.STATE) {
	    sax.STATE[sax.STATE[s]] = s;
	  }

	  // shorthand
	  S = sax.STATE;

	  function emit (parser, event, data) {
	    parser[event] && parser[event](data);
	  }

	  function emitNode (parser, nodeType, data) {
	    if (parser.textNode) closeText(parser);
	    emit(parser, nodeType, data);
	  }

	  function closeText (parser) {
	    parser.textNode = textopts(parser.opt, parser.textNode);
	    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
	    parser.textNode = '';
	  }

	  function textopts (opt, text) {
	    if (opt.trim) text = text.trim();
	    if (opt.normalize) text = text.replace(/\s+/g, ' ');
	    return text
	  }

	  function error (parser, reason) {
	    closeText(parser);
	    const message = reason +
	      '\nLine: ' + parser.line +
	      '\nColumn: ' + parser.column +
	      '\nChar: ' + parser.c;
	    const error = new Error(message);
	    error.reason = reason;
	    error.line = parser.line;
	    error.column = parser.column;
	    parser.error = error;
	    emit(parser, 'onerror', error);
	    return parser
	  }

	  function end (parser) {
	    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
	    if ((parser.state !== S.BEGIN) &&
	      (parser.state !== S.BEGIN_WHITESPACE) &&
	      (parser.state !== S.TEXT)) {
	      error(parser, 'Unexpected end');
	    }
	    closeText(parser);
	    parser.c = '';
	    parser.closed = true;
	    emit(parser, 'onend');
	    SAXParser.call(parser, parser.strict, parser.opt);
	    return parser
	  }

	  function strictFail (parser, message) {
	    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
	      throw new Error('bad call to strictFail')
	    }
	    if (parser.strict) {
	      error(parser, message);
	    }
	  }

	  function newTag (parser) {
	    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
	    var parent = parser.tags[parser.tags.length - 1] || parser;
	    var tag = parser.tag = { name: parser.tagName, attributes: {} };

	    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
	    if (parser.opt.xmlns) {
	      tag.ns = parent.ns;
	    }
	    parser.attribList.length = 0;
	    emitNode(parser, 'onopentagstart', tag);
	  }

	  function qname (name, attribute) {
	    var i = name.indexOf(':');
	    var qualName = i < 0 ? [ '', name ] : name.split(':');
	    var prefix = qualName[0];
	    var local = qualName[1];

	    // <x "xmlns"="http://foo">
	    if (attribute && name === 'xmlns') {
	      prefix = 'xmlns';
	      local = '';
	    }

	    return { prefix: prefix, local: local }
	  }

	  function attrib (parser) {
	    if (!parser.strict) {
	      parser.attribName = parser.attribName[parser.looseCase]();
	    }

	    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
	      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
	      parser.attribName = parser.attribValue = '';
	      return
	    }

	    if (parser.opt.xmlns) {
	      var qn = qname(parser.attribName, true);
	      var prefix = qn.prefix;
	      var local = qn.local;

	      if (prefix === 'xmlns') {
	        // namespace binding attribute. push the binding into scope
	        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
	          strictFail(parser,
	            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue);
	        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
	          strictFail(parser,
	            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue);
	        } else {
	          var tag = parser.tag;
	          var parent = parser.tags[parser.tags.length - 1] || parser;
	          if (tag.ns === parent.ns) {
	            tag.ns = Object.create(parent.ns);
	          }
	          tag.ns[local] = parser.attribValue;
	        }
	      }

	      // defer onattribute events until all attributes have been seen
	      // so any new bindings can take effect. preserve attribute order
	      // so deferred events can be emitted in document order
	      parser.attribList.push([parser.attribName, parser.attribValue]);
	    } else {
	      // in non-xmlns mode, we can emit the event right away
	      parser.tag.attributes[parser.attribName] = parser.attribValue;
	      emitNode(parser, 'onattribute', {
	        name: parser.attribName,
	        value: parser.attribValue
	      });
	    }

	    parser.attribName = parser.attribValue = '';
	  }

	  function openTag (parser, selfClosing) {
	    if (parser.opt.xmlns) {
	      // emit namespace binding events
	      var tag = parser.tag;

	      // add namespace info to tag
	      var qn = qname(parser.tagName);
	      tag.prefix = qn.prefix;
	      tag.local = qn.local;
	      tag.uri = tag.ns[qn.prefix] || '';

	      if (tag.prefix && !tag.uri) {
	        strictFail(parser, 'Unbound namespace prefix: ' +
	          JSON.stringify(parser.tagName));
	        tag.uri = qn.prefix;
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser;
	      if (tag.ns && parent.ns !== tag.ns) {
	        Object.keys(tag.ns).forEach(function (p) {
	          emitNode(parser, 'onopennamespace', {
	            prefix: p,
	            uri: tag.ns[p]
	          });
	        });
	      }

	      // handle deferred onattribute events
	      // Note: do not apply default ns to attributes:
	      //   http://www.w3.org/TR/REC-xml-names/#defaulting
	      for (var i = 0, l = parser.attribList.length; i < l; i++) {
	        var nv = parser.attribList[i];
	        var name = nv[0];
	        var value = nv[1];
	        var qualName = qname(name, true);
	        var prefix = qualName.prefix;
	        var local = qualName.local;
	        var uri = prefix === '' ? '' : (tag.ns[prefix] || '');
	        var a = {
	          name: name,
	          value: value,
	          prefix: prefix,
	          local: local,
	          uri: uri
	        };

	        // if there's any attributes with an undefined namespace,
	        // then fail on them now.
	        if (prefix && prefix !== 'xmlns' && !uri) {
	          strictFail(parser, 'Unbound namespace prefix: ' +
	            JSON.stringify(prefix));
	          a.uri = prefix;
	        }
	        parser.tag.attributes[name] = a;
	        emitNode(parser, 'onattribute', a);
	      }
	      parser.attribList.length = 0;
	    }

	    parser.tag.isSelfClosing = !!selfClosing;

	    // process the tag
	    parser.sawRoot = true;
	    parser.tags.push(parser.tag);
	    emitNode(parser, 'onopentag', parser.tag);
	    if (!selfClosing) {
	      // special case for <script> in non-strict mode.
	      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
	        parser.state = S.SCRIPT;
	      } else {
	        parser.state = S.TEXT;
	      }
	      parser.tag = null;
	      parser.tagName = '';
	    }
	    parser.attribName = parser.attribValue = '';
	    parser.attribList.length = 0;
	  }

	  function closeTag (parser) {
	    if (!parser.tagName) {
	      strictFail(parser, 'Weird empty close tag.');
	      parser.textNode += '</>';
	      parser.state = S.TEXT;
	      return
	    }

	    if (parser.script) {
	      if (parser.tagName !== 'script') {
	        parser.script += '</' + parser.tagName + '>';
	        parser.tagName = '';
	        parser.state = S.SCRIPT;
	        return
	      }
	      emitNode(parser, 'onscript', parser.script);
	      parser.script = '';
	    }

	    // first make sure that the closing tag actually exists.
	    // <a><b></c></b></a> will close everything, otherwise.
	    var t = parser.tags.length;
	    var tagName = parser.tagName;
	    if (!parser.strict) {
	      tagName = tagName[parser.looseCase]();
	    }
	    var closeTo = tagName;
	    while (t--) {
	      var close = parser.tags[t];
	      if (close.name !== closeTo) {
	        // fail the first time in strict mode
	        strictFail(parser, 'Unexpected close tag');
	      } else {
	        break
	      }
	    }

	    // didn't find it.  we already failed for strict, so just abort.
	    if (t < 0) {
	      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
	      parser.textNode += '</' + parser.tagName + '>';
	      parser.state = S.TEXT;
	      return
	    }
	    parser.tagName = tagName;
	    var s = parser.tags.length;
	    while (s-- > t) {
	      var tag = parser.tag = parser.tags.pop();
	      parser.tagName = parser.tag.name;
	      emitNode(parser, 'onclosetag', parser.tagName);

	      var x = {};
	      for (var i in tag.ns) {
	        x[i] = tag.ns[i];
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser;
	      if (parser.opt.xmlns && tag.ns !== parent.ns) {
	        // remove namespace bindings introduced by tag
	        Object.keys(tag.ns).forEach(function (p) {
	          var n = tag.ns[p];
	          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
	        });
	      }
	    }
	    if (t === 0) parser.closedRoot = true;
	    parser.tagName = parser.attribValue = parser.attribName = '';
	    parser.attribList.length = 0;
	    parser.state = S.TEXT;
	  }

	  function parseEntity (parser) {
	    var entity = parser.entity;
	    var entityLC = entity.toLowerCase();
	    var num;
	    var numStr = '';

	    if (parser.ENTITIES[entity]) {
	      return parser.ENTITIES[entity]
	    }
	    if (parser.ENTITIES[entityLC]) {
	      return parser.ENTITIES[entityLC]
	    }
	    entity = entityLC;
	    if (entity.charAt(0) === '#') {
	      if (entity.charAt(1) === 'x') {
	        entity = entity.slice(2);
	        num = parseInt(entity, 16);
	        numStr = num.toString(16);
	      } else {
	        entity = entity.slice(1);
	        num = parseInt(entity, 10);
	        numStr = num.toString(10);
	      }
	    }
	    entity = entity.replace(/^0+/, '');
	    if (isNaN(num) || numStr.toLowerCase() !== entity) {
	      strictFail(parser, 'Invalid character entity');
	      return '&' + parser.entity + ';'
	    }

	    return String.fromCodePoint(num)
	  }

	  function beginWhiteSpace (parser, c) {
	    if (c === '<') {
	      parser.state = S.OPEN_WAKA;
	      parser.startTagPosition = parser.position;
	    } else if (!isWhitespace(c)) {
	      // have to process this as a text node.
	      // weird, but happens.
	      strictFail(parser, 'Non-whitespace before first tag.');
	      parser.textNode = c;
	      parser.state = S.TEXT;
	    }
	  }

	  function charAt (chunk, i) {
	    var result = '';
	    if (i < chunk.length) {
	      result = chunk.charAt(i);
	    }
	    return result
	  }

	  function write (chunk) {
	    var parser = this;
	    if (this.error) {
	      throw this.error
	    }
	    if (parser.closed) {
	      return error(parser,
	        'Cannot write after close. Assign an onready handler.')
	    }
	    if (chunk === null) {
	      return end(parser)
	    }
	    if (typeof chunk === 'object') {
	      chunk = chunk.toString();
	    }
	    var i = 0;
	    var c = '';
	    while (true) {
	      c = charAt(chunk, i++);
	      parser.c = c;

	      if (!c) {
	        break
	      }

	      if (parser.trackPosition) {
	        parser.position++;
	        if (c === '\n') {
	          parser.line++;
	          parser.column = 0;
	        } else {
	          parser.column++;
	        }
	      }

	      switch (parser.state) {
	        case S.BEGIN:
	          parser.state = S.BEGIN_WHITESPACE;
	          if (c === '\uFEFF') {
	            continue
	          }
	          beginWhiteSpace(parser, c);
	          continue

	        case S.BEGIN_WHITESPACE:
	          beginWhiteSpace(parser, c);
	          continue

	        case S.TEXT:
	          if (parser.sawRoot && !parser.closedRoot) {
	            var starti = i - 1;
	            while (c && c !== '<' && c !== '&') {
	              c = charAt(chunk, i++);
	              if (c && parser.trackPosition) {
	                parser.position++;
	                if (c === '\n') {
	                  parser.line++;
	                  parser.column = 0;
	                } else {
	                  parser.column++;
	                }
	              }
	            }
	            parser.textNode += chunk.substring(starti, i - 1);
	          }
	          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
	            parser.state = S.OPEN_WAKA;
	            parser.startTagPosition = parser.position;
	          } else {
	            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
	              strictFail(parser, 'Text data outside of root node.');
	            }
	            if (c === '&') {
	              parser.state = S.TEXT_ENTITY;
	            } else {
	              parser.textNode += c;
	            }
	          }
	          continue

	        case S.SCRIPT:
	          // only non-strict
	          if (c === '<') {
	            parser.state = S.SCRIPT_ENDING;
	          } else {
	            parser.script += c;
	          }
	          continue

	        case S.SCRIPT_ENDING:
	          if (c === '/') {
	            parser.state = S.CLOSE_TAG;
	          } else {
	            parser.script += '<' + c;
	            parser.state = S.SCRIPT;
	          }
	          continue

	        case S.OPEN_WAKA:
	          // either a /, ?, !, or text is coming next.
	          if (c === '!') {
	            parser.state = S.SGML_DECL;
	            parser.sgmlDecl = '';
	          } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {
	            parser.state = S.OPEN_TAG;
	            parser.tagName = c;
	          } else if (c === '/') {
	            parser.state = S.CLOSE_TAG;
	            parser.tagName = '';
	          } else if (c === '?') {
	            parser.state = S.PROC_INST;
	            parser.procInstName = parser.procInstBody = '';
	          } else {
	            strictFail(parser, 'Unencoded <');
	            // if there was some whitespace, then add that in.
	            if (parser.startTagPosition + 1 < parser.position) {
	              var pad = parser.position - parser.startTagPosition;
	              c = new Array(pad).join(' ') + c;
	            }
	            parser.textNode += '<' + c;
	            parser.state = S.TEXT;
	          }
	          continue

	        case S.SGML_DECL:
	          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
	            emitNode(parser, 'onopencdata');
	            parser.state = S.CDATA;
	            parser.sgmlDecl = '';
	            parser.cdata = '';
	          } else if (parser.sgmlDecl + c === '--') {
	            parser.state = S.COMMENT;
	            parser.comment = '';
	            parser.sgmlDecl = '';
	          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
	            parser.state = S.DOCTYPE;
	            if (parser.doctype || parser.sawRoot) {
	              strictFail(parser,
	                'Inappropriately located doctype declaration');
	            }
	            parser.doctype = '';
	            parser.sgmlDecl = '';
	          } else if (c === '>') {
	            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
	            parser.sgmlDecl = '';
	            parser.state = S.TEXT;
	          } else if (isQuote(c)) {
	            parser.state = S.SGML_DECL_QUOTED;
	            parser.sgmlDecl += c;
	          } else {
	            parser.sgmlDecl += c;
	          }
	          continue

	        case S.SGML_DECL_QUOTED:
	          if (c === parser.q) {
	            parser.state = S.SGML_DECL;
	            parser.q = '';
	          }
	          parser.sgmlDecl += c;
	          continue

	        case S.DOCTYPE:
	          if (c === '>') {
	            parser.state = S.TEXT;
	            emitNode(parser, 'ondoctype', parser.doctype);
	            parser.doctype = true; // just remember that we saw it.
	          } else {
	            parser.doctype += c;
	            if (c === '[') {
	              parser.state = S.DOCTYPE_DTD;
	            } else if (isQuote(c)) {
	              parser.state = S.DOCTYPE_QUOTED;
	              parser.q = c;
	            }
	          }
	          continue

	        case S.DOCTYPE_QUOTED:
	          parser.doctype += c;
	          if (c === parser.q) {
	            parser.q = '';
	            parser.state = S.DOCTYPE;
	          }
	          continue

	        case S.DOCTYPE_DTD:
	          parser.doctype += c;
	          if (c === ']') {
	            parser.state = S.DOCTYPE;
	          } else if (isQuote(c)) {
	            parser.state = S.DOCTYPE_DTD_QUOTED;
	            parser.q = c;
	          }
	          continue

	        case S.DOCTYPE_DTD_QUOTED:
	          parser.doctype += c;
	          if (c === parser.q) {
	            parser.state = S.DOCTYPE_DTD;
	            parser.q = '';
	          }
	          continue

	        case S.COMMENT:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDING;
	          } else {
	            parser.comment += c;
	          }
	          continue

	        case S.COMMENT_ENDING:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDED;
	            parser.comment = textopts(parser.opt, parser.comment);
	            if (parser.comment) {
	              emitNode(parser, 'oncomment', parser.comment);
	            }
	            parser.comment = '';
	          } else {
	            parser.comment += '-' + c;
	            parser.state = S.COMMENT;
	          }
	          continue

	        case S.COMMENT_ENDED:
	          if (c !== '>') {
	            strictFail(parser, 'Malformed comment');
	            // allow <!-- blah -- bloo --> in non-strict mode,
	            // which is a comment of " blah -- bloo "
	            parser.comment += '--' + c;
	            parser.state = S.COMMENT;
	          } else {
	            parser.state = S.TEXT;
	          }
	          continue

	        case S.CDATA:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING;
	          } else {
	            parser.cdata += c;
	          }
	          continue

	        case S.CDATA_ENDING:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING_2;
	          } else {
	            parser.cdata += ']' + c;
	            parser.state = S.CDATA;
	          }
	          continue

	        case S.CDATA_ENDING_2:
	          if (c === '>') {
	            if (parser.cdata) {
	              emitNode(parser, 'oncdata', parser.cdata);
	            }
	            emitNode(parser, 'onclosecdata');
	            parser.cdata = '';
	            parser.state = S.TEXT;
	          } else if (c === ']') {
	            parser.cdata += ']';
	          } else {
	            parser.cdata += ']]' + c;
	            parser.state = S.CDATA;
	          }
	          continue

	        case S.PROC_INST:
	          if (c === '?') {
	            parser.state = S.PROC_INST_ENDING;
	          } else if (isWhitespace(c)) {
	            parser.state = S.PROC_INST_BODY;
	          } else {
	            parser.procInstName += c;
	          }
	          continue

	        case S.PROC_INST_BODY:
	          if (!parser.procInstBody && isWhitespace(c)) {
	            continue
	          } else if (c === '?') {
	            parser.state = S.PROC_INST_ENDING;
	          } else {
	            parser.procInstBody += c;
	          }
	          continue

	        case S.PROC_INST_ENDING:
	          if (c === '>') {
	            emitNode(parser, 'onprocessinginstruction', {
	              name: parser.procInstName,
	              body: parser.procInstBody
	            });
	            parser.procInstName = parser.procInstBody = '';
	            parser.state = S.TEXT;
	          } else {
	            parser.procInstBody += '?' + c;
	            parser.state = S.PROC_INST_BODY;
	          }
	          continue

	        case S.OPEN_TAG:
	          if (isMatch(nameBody, c)) {
	            parser.tagName += c;
	          } else {
	            newTag(parser);
	            if (c === '>') {
	              openTag(parser);
	            } else if (c === '/') {
	              parser.state = S.OPEN_TAG_SLASH;
	            } else {
	              if (!isWhitespace(c)) {
	                strictFail(parser, 'Invalid character in tag name');
	              }
	              parser.state = S.ATTRIB;
	            }
	          }
	          continue

	        case S.OPEN_TAG_SLASH:
	          if (c === '>') {
	            openTag(parser, true);
	            closeTag(parser);
	          } else {
	            strictFail(parser, 'Forward-slash in opening tag not followed by >');
	            parser.state = S.ATTRIB;
	          }
	          continue

	        case S.ATTRIB:
	          // haven't read the attribute name yet.
	          if (isWhitespace(c)) {
	            continue
	          } else if (c === '>') {
	            openTag(parser);
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH;
	          } else if (isMatch(nameStart, c)) {
	            parser.attribName = c;
	            parser.attribValue = '';
	            parser.state = S.ATTRIB_NAME;
	          } else {
	            strictFail(parser, 'Invalid attribute name');
	          }
	          continue

	        case S.ATTRIB_NAME:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE;
	          } else if (c === '>') {
	            strictFail(parser, 'Attribute without value');
	            parser.attribValue = parser.attribName;
	            attrib(parser);
	            openTag(parser);
	          } else if (isWhitespace(c)) {
	            parser.state = S.ATTRIB_NAME_SAW_WHITE;
	          } else if (isMatch(nameBody, c)) {
	            parser.attribName += c;
	          } else {
	            strictFail(parser, 'Invalid attribute name');
	          }
	          continue

	        case S.ATTRIB_NAME_SAW_WHITE:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE;
	          } else if (isWhitespace(c)) {
	            continue
	          } else {
	            strictFail(parser, 'Attribute without value');
	            parser.tag.attributes[parser.attribName] = '';
	            parser.attribValue = '';
	            emitNode(parser, 'onattribute', {
	              name: parser.attribName,
	              value: ''
	            });
	            parser.attribName = '';
	            if (c === '>') {
	              openTag(parser);
	            } else if (isMatch(nameStart, c)) {
	              parser.attribName = c;
	              parser.state = S.ATTRIB_NAME;
	            } else {
	              strictFail(parser, 'Invalid attribute name');
	              parser.state = S.ATTRIB;
	            }
	          }
	          continue

	        case S.ATTRIB_VALUE:
	          if (isWhitespace(c)) {
	            continue
	          } else if (isQuote(c)) {
	            parser.q = c;
	            parser.state = S.ATTRIB_VALUE_QUOTED;
	          } else {
	            strictFail(parser, 'Unquoted attribute value');
	            parser.state = S.ATTRIB_VALUE_UNQUOTED;
	            parser.attribValue = c;
	          }
	          continue

	        case S.ATTRIB_VALUE_QUOTED:
	          if (c !== parser.q) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
	            } else {
	              parser.attribValue += c;
	            }
	            continue
	          }
	          attrib(parser);
	          parser.q = '';
	          parser.state = S.ATTRIB_VALUE_CLOSED;
	          continue

	        case S.ATTRIB_VALUE_CLOSED:
	          if (isWhitespace(c)) {
	            parser.state = S.ATTRIB;
	          } else if (c === '>') {
	            openTag(parser);
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH;
	          } else if (isMatch(nameStart, c)) {
	            strictFail(parser, 'No whitespace between attributes');
	            parser.attribName = c;
	            parser.attribValue = '';
	            parser.state = S.ATTRIB_NAME;
	          } else {
	            strictFail(parser, 'Invalid attribute name');
	          }
	          continue

	        case S.ATTRIB_VALUE_UNQUOTED:
	          if (!isAttribEnd(c)) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_U;
	            } else {
	              parser.attribValue += c;
	            }
	            continue
	          }
	          attrib(parser);
	          if (c === '>') {
	            openTag(parser);
	          } else {
	            parser.state = S.ATTRIB;
	          }
	          continue

	        case S.CLOSE_TAG:
	          if (!parser.tagName) {
	            if (isWhitespace(c)) {
	              continue
	            } else if (notMatch(nameStart, c)) {
	              if (parser.script) {
	                parser.script += '</' + c;
	                parser.state = S.SCRIPT;
	              } else {
	                strictFail(parser, 'Invalid tagname in closing tag.');
	              }
	            } else {
	              parser.tagName = c;
	            }
	          } else if (c === '>') {
	            closeTag(parser);
	          } else if (isMatch(nameBody, c)) {
	            parser.tagName += c;
	          } else if (parser.script) {
	            parser.script += '</' + parser.tagName;
	            parser.tagName = '';
	            parser.state = S.SCRIPT;
	          } else {
	            if (!isWhitespace(c)) {
	              strictFail(parser, 'Invalid tagname in closing tag');
	            }
	            parser.state = S.CLOSE_TAG_SAW_WHITE;
	          }
	          continue

	        case S.CLOSE_TAG_SAW_WHITE:
	          if (isWhitespace(c)) {
	            continue
	          }
	          if (c === '>') {
	            closeTag(parser);
	          } else {
	            strictFail(parser, 'Invalid characters in closing tag');
	          }
	          continue

	        case S.TEXT_ENTITY:
	        case S.ATTRIB_VALUE_ENTITY_Q:
	        case S.ATTRIB_VALUE_ENTITY_U:
	          var returnState;
	          var buffer;
	          switch (parser.state) {
	            case S.TEXT_ENTITY:
	              returnState = S.TEXT;
	              buffer = 'textNode';
	              break

	            case S.ATTRIB_VALUE_ENTITY_Q:
	              returnState = S.ATTRIB_VALUE_QUOTED;
	              buffer = 'attribValue';
	              break

	            case S.ATTRIB_VALUE_ENTITY_U:
	              returnState = S.ATTRIB_VALUE_UNQUOTED;
	              buffer = 'attribValue';
	              break
	          }

	          if (c === ';') {
	            var parsedEntity = parseEntity(parser);

	            // Custom entities can contain tags, so we potentially need to parse the result
	            if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== '&' + parser.entity + ';') {
	              chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
	            } else {
	              parser[buffer] += parsedEntity;
	            }

	            parser.entity = '';
	            parser.state = returnState;
	          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
	            parser.entity += c;
	          } else {
	            strictFail(parser, 'Invalid character in entity name');
	            parser[buffer] += '&' + parser.entity + c;
	            parser.entity = '';
	            parser.state = returnState;
	          }

	          continue

	        default:
	          throw new Error(parser, 'Unknown state: ' + parser.state)
	      }
	    } // while

	    if (parser.position >= parser.bufferCheckPosition) {
	      checkBufferLength(parser);
	    }
	    return parser
	  }
	})(exports);
} (sax));

/**
 * @typedef {import('./types').XastNode} XastNode
 * @typedef {import('./types').XastInstruction} XastInstruction
 * @typedef {import('./types').XastDoctype} XastDoctype
 * @typedef {import('./types').XastComment} XastComment
 * @typedef {import('./types').XastRoot} XastRoot
 * @typedef {import('./types').XastElement} XastElement
 * @typedef {import('./types').XastCdata} XastCdata
 * @typedef {import('./types').XastText} XastText
 * @typedef {import('./types').XastParent} XastParent
 */

// @ts-ignore sax will be replaced with something else later
const SAX = sax;
const JSAPI$1 = jsAPI;
const { textElems: textElems$1 } = _collections;

class SvgoParserError extends Error {
  /**
   * @param message {string}
   * @param line {number}
   * @param column {number}
   * @param source {string}
   * @param file {void | string}
   */
  constructor(message, line, column, source, file) {
    super(message);
    this.name = 'SvgoParserError';
    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;
    this.reason = message;
    this.line = line;
    this.column = column;
    this.source = source;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, SvgoParserError);
    }
  }
  toString() {
    const lines = this.source.split(/\r?\n/);
    const startLine = Math.max(this.line - 3, 0);
    const endLine = Math.min(this.line + 2, lines.length);
    const lineNumberWidth = String(endLine).length;
    const startColumn = Math.max(this.column - 54, 0);
    const endColumn = Math.max(this.column + 20, 80);
    const code = lines
      .slice(startLine, endLine)
      .map((line, index) => {
        const lineSlice = line.slice(startColumn, endColumn);
        let ellipsisPrefix = '';
        let ellipsisSuffix = '';
        if (startColumn !== 0) {
          ellipsisPrefix = startColumn > line.length - 1 ? ' ' : 'â€¦';
        }
        if (endColumn < line.length - 1) {
          ellipsisSuffix = 'â€¦';
        }
        const number = startLine + 1 + index;
        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
        if (number === this.line) {
          const gutterSpacing = gutter.replace(/[^|]/g, ' ');
          const lineSpacing = (
            ellipsisPrefix + line.slice(startColumn, this.column - 1)
          ).replace(/[^\t]/g, ' ');
          const spacing = gutterSpacing + lineSpacing;
          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\n ${spacing}^`;
        }
        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
      })
      .join('\n');
    return `${this.name}: ${this.message}\n\n${code}\n`;
  }
}

const entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;

const config = {
  strict: true,
  trim: false,
  normalize: false,
  lowercase: true,
  xmlns: true,
  position: true,
};

/**
 * Convert SVG (XML) string to SVG-as-JS object.
 *
 * @type {(data: string, from?: string) => XastRoot}
 */
const parseSvg$1 = (data, from) => {
  const sax = SAX.parser(config.strict, config);
  /**
   * @type {XastRoot}
   */
  const root = new JSAPI$1({ type: 'root', children: [] });
  /**
   * @type {XastParent}
   */
  let current = root;
  /**
   * @type {Array<XastParent>}
   */
  const stack = [root];

  /**
   * @type {<T extends XastNode>(node: T) => T}
   */
  const pushToContent = (node) => {
    const wrapped = new JSAPI$1(node, current);
    current.children.push(wrapped);
    return wrapped;
  };

  /**
   * @type {(doctype: string) => void}
   */
  sax.ondoctype = (doctype) => {
    /**
     * @type {XastDoctype}
     */
    const node = {
      type: 'doctype',
      // TODO parse doctype for name, public and system to match xast
      name: 'svg',
      data: {
        doctype,
      },
    };
    pushToContent(node);
    const subsetStart = doctype.indexOf('[');
    if (subsetStart >= 0) {
      entityDeclaration.lastIndex = subsetStart;
      let entityMatch = entityDeclaration.exec(data);
      while (entityMatch != null) {
        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
        entityMatch = entityDeclaration.exec(data);
      }
    }
  };

  /**
   * @type {(data: { name: string, body: string }) => void}
   */
  sax.onprocessinginstruction = (data) => {
    /**
     * @type {XastInstruction}
     */
    const node = {
      type: 'instruction',
      name: data.name,
      value: data.body,
    };
    pushToContent(node);
  };

  /**
   * @type {(comment: string) => void}
   */
  sax.oncomment = (comment) => {
    /**
     * @type {XastComment}
     */
    const node = {
      type: 'comment',
      value: comment.trim(),
    };
    pushToContent(node);
  };

  /**
   * @type {(cdata: string) => void}
   */
  sax.oncdata = (cdata) => {
    /**
     * @type {XastCdata}
     */
    const node = {
      type: 'cdata',
      value: cdata,
    };
    pushToContent(node);
  };

  /**
   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}
   */
  sax.onopentag = (data) => {
    /**
     * @type {XastElement}
     */
    let element = {
      type: 'element',
      name: data.name,
      attributes: {},
      children: [],
    };
    for (const [name, attr] of Object.entries(data.attributes)) {
      element.attributes[name] = attr.value;
    }
    element = pushToContent(element);
    current = element;
    stack.push(element);
  };

  /**
   * @type {(text: string) => void}
   */
  sax.ontext = (text) => {
    if (current.type === 'element') {
      // prevent trimming of meaningful whitespace inside textual tags
      if (textElems$1.includes(current.name)) {
        /**
         * @type {XastText}
         */
        const node = {
          type: 'text',
          value: text,
        };
        pushToContent(node);
      } else if (/\S/.test(text)) {
        /**
         * @type {XastText}
         */
        const node = {
          type: 'text',
          value: text.trim(),
        };
        pushToContent(node);
      }
    }
  };

  sax.onclosetag = () => {
    stack.pop();
    current = stack[stack.length - 1];
  };

  /**
   * @type {(e: any) => void}
   */
  sax.onerror = (e) => {
    const error = new SvgoParserError(
      e.reason,
      e.line + 1,
      e.column,
      data,
      from
    );
    if (e.message.indexOf('Unexpected end') === -1) {
      throw error;
    }
  };

  sax.write(data).close();
  return root;
};
parser.parseSvg = parseSvg$1;

var stringifier = {};

/**
 * @typedef {import('./types').XastParent} XastParent
 * @typedef {import('./types').XastRoot} XastRoot
 * @typedef {import('./types').XastElement} XastElement
 * @typedef {import('./types').XastInstruction} XastInstruction
 * @typedef {import('./types').XastDoctype} XastDoctype
 * @typedef {import('./types').XastText} XastText
 * @typedef {import('./types').XastCdata} XastCdata
 * @typedef {import('./types').XastComment} XastComment
 * @typedef {import('./types').StringifyOptions} StringifyOptions
 */

const { textElems } = _collections;

/**
 * @typedef {{
 *   width: void | string,
 *   height: void | string,
 *   indent: string,
 *   textContext: null | XastElement,
 *   indentLevel: number,
 * }} State
 */

/**
 * @typedef {Required<StringifyOptions>} Options
 */

/**
 * @type {(char: string) => string}
 */
const encodeEntity = (char) => {
  return entities[char];
};

/**
 * @type {Options}
 */
const defaults = {
  doctypeStart: '<!DOCTYPE',
  doctypeEnd: '>',
  procInstStart: '<?',
  procInstEnd: '?>',
  tagOpenStart: '<',
  tagOpenEnd: '>',
  tagCloseStart: '</',
  tagCloseEnd: '>',
  tagShortStart: '<',
  tagShortEnd: '/>',
  attrStart: '="',
  attrEnd: '"',
  commentStart: '<!--',
  commentEnd: '-->',
  cdataStart: '<![CDATA[',
  cdataEnd: ']]>',
  textStart: '',
  textEnd: '',
  indent: 4,
  regEntities: /[&'"<>]/g,
  regValEntities: /[&"<>]/g,
  encodeEntity: encodeEntity,
  pretty: false,
  useShortTags: true,
  eol: 'lf',
  finalNewline: false,
};

/**
 * @type {Record<string, string>}
 */
const entities = {
  '&': '&amp;',
  "'": '&apos;',
  '"': '&quot;',
  '>': '&gt;',
  '<': '&lt;',
};

/**
 * convert XAST to SVG string
 *
 * @type {(data: XastRoot, config: StringifyOptions) => {
 *   data: string,
 *   info: {
 *     width: void | string,
 *     height: void | string
 *   }
 * }}
 */
const stringifySvg$1 = (data, userOptions = {}) => {
  /**
   * @type {Options}
   */
  const config = { ...defaults, ...userOptions };
  const indent = config.indent;
  let newIndent = '    ';
  if (typeof indent === 'number' && Number.isNaN(indent) === false) {
    newIndent = indent < 0 ? '\t' : ' '.repeat(indent);
  } else if (typeof indent === 'string') {
    newIndent = indent;
  }
  /**
   * @type {State}
   */
  const state = {
    // TODO remove width and height in v3
    width: undefined,
    height: undefined,
    indent: newIndent,
    textContext: null,
    indentLevel: 0,
  };
  const eol = config.eol === 'crlf' ? '\r\n' : '\n';
  if (config.pretty) {
    config.doctypeEnd += eol;
    config.procInstEnd += eol;
    config.commentEnd += eol;
    config.cdataEnd += eol;
    config.tagShortEnd += eol;
    config.tagOpenEnd += eol;
    config.tagCloseEnd += eol;
    config.textEnd += eol;
  }
  let svg = stringifyNode(data, config, state);
  if (config.finalNewline && svg.length > 0 && svg[svg.length - 1] !== '\n') {
    svg += eol;
  }
  return {
    data: svg,
    info: {
      width: state.width,
      height: state.height,
    },
  };
};
stringifier.stringifySvg = stringifySvg$1;

/**
 * @type {(node: XastParent, config: Options, state: State) => string}
 */
const stringifyNode = (data, config, state) => {
  let svg = '';
  state.indentLevel += 1;
  for (const item of data.children) {
    if (item.type === 'element') {
      svg += stringifyElement(item, config, state);
    }
    if (item.type === 'text') {
      svg += stringifyText(item, config, state);
    }
    if (item.type === 'doctype') {
      svg += stringifyDoctype(item, config);
    }
    if (item.type === 'instruction') {
      svg += stringifyInstruction(item, config);
    }
    if (item.type === 'comment') {
      svg += stringifyComment(item, config);
    }
    if (item.type === 'cdata') {
      svg += stringifyCdata(item, config, state);
    }
  }
  state.indentLevel -= 1;
  return svg;
};

/**
 * create indent string in accordance with the current node level.
 *
 * @type {(config: Options, state: State) => string}
 */
const createIndent = (config, state) => {
  let indent = '';
  if (config.pretty && state.textContext == null) {
    indent = state.indent.repeat(state.indentLevel - 1);
  }
  return indent;
};

/**
 * @type {(node: XastDoctype, config: Options) => string}
 */
const stringifyDoctype = (node, config) => {
  return config.doctypeStart + node.data.doctype + config.doctypeEnd;
};

/**
 * @type {(node: XastInstruction, config: Options) => string}
 */
const stringifyInstruction = (node, config) => {
  return (
    config.procInstStart + node.name + ' ' + node.value + config.procInstEnd
  );
};

/**
 * @type {(node: XastComment, config: Options) => string}
 */
const stringifyComment = (node, config) => {
  return config.commentStart + node.value + config.commentEnd;
};

/**
 * @type {(node: XastCdata, config: Options, state: State) => string}
 */
const stringifyCdata = (node, config, state) => {
  return (
    createIndent(config, state) +
    config.cdataStart +
    node.value +
    config.cdataEnd
  );
};

/**
 * @type {(node: XastElement, config: Options, state: State) => string}
 */
const stringifyElement = (node, config, state) => {
  // beautiful injection for obtaining SVG information :)
  if (
    node.name === 'svg' &&
    node.attributes.width != null &&
    node.attributes.height != null
  ) {
    state.width = node.attributes.width;
    state.height = node.attributes.height;
  }

  // empty element and short tag
  if (node.children.length === 0) {
    if (config.useShortTags) {
      return (
        createIndent(config, state) +
        config.tagShortStart +
        node.name +
        stringifyAttributes(node, config) +
        config.tagShortEnd
      );
    } else {
      return (
        createIndent(config, state) +
        config.tagShortStart +
        node.name +
        stringifyAttributes(node, config) +
        config.tagOpenEnd +
        config.tagCloseStart +
        node.name +
        config.tagCloseEnd
      );
    }
    // non-empty element
  } else {
    let tagOpenStart = config.tagOpenStart;
    let tagOpenEnd = config.tagOpenEnd;
    let tagCloseStart = config.tagCloseStart;
    let tagCloseEnd = config.tagCloseEnd;
    let openIndent = createIndent(config, state);
    let closeIndent = createIndent(config, state);

    if (state.textContext) {
      tagOpenStart = defaults.tagOpenStart;
      tagOpenEnd = defaults.tagOpenEnd;
      tagCloseStart = defaults.tagCloseStart;
      tagCloseEnd = defaults.tagCloseEnd;
      openIndent = '';
    } else if (textElems.includes(node.name)) {
      tagOpenEnd = defaults.tagOpenEnd;
      tagCloseStart = defaults.tagCloseStart;
      closeIndent = '';
      state.textContext = node;
    }

    const children = stringifyNode(node, config, state);

    if (state.textContext === node) {
      state.textContext = null;
    }

    return (
      openIndent +
      tagOpenStart +
      node.name +
      stringifyAttributes(node, config) +
      tagOpenEnd +
      children +
      closeIndent +
      tagCloseStart +
      node.name +
      tagCloseEnd
    );
  }
};

/**
 * @type {(node: XastElement, config: Options) => string}
 */
const stringifyAttributes = (node, config) => {
  let attrs = '';
  for (const [name, value] of Object.entries(node.attributes)) {
    // TODO remove attributes without values support in v3
    if (value !== undefined) {
      const encodedValue = value
        .toString()
        .replace(config.regValEntities, config.encodeEntity);
      attrs += ' ' + name + config.attrStart + encodedValue + config.attrEnd;
    } else {
      attrs += ' ' + name;
    }
  }
  return attrs;
};

/**
 * @type {(node: XastText, config: Options, state: State) => string}
 */
const stringifyText = (node, config, state) => {
  return (
    createIndent(config, state) +
    config.textStart +
    node.value.replace(config.regEntities, config.encodeEntity) +
    (state.textContext ? '' : config.textEnd)
  );
};

const {
  defaultPlugins,
  resolvePluginConfig,
  extendDefaultPlugins: extendDefaultPlugins$1,
} = config$1;
const { parseSvg } = parser;
const { stringifySvg } = stringifier;
const { invokePlugins } = plugins;
const JSAPI = jsAPI;
const { encodeSVGDatauri } = tools;

svgo.extendDefaultPlugins = extendDefaultPlugins$1;

const optimize$1 = (input, config) => {
  if (config == null) {
    config = {};
  }
  if (typeof config !== 'object') {
    throw Error('Config should be an object');
  }
  const maxPassCount = config.multipass ? 10 : 1;
  let prevResultSize = Number.POSITIVE_INFINITY;
  let svgjs = null;
  const info = {};
  if (config.path != null) {
    info.path = config.path;
  }
  for (let i = 0; i < maxPassCount; i += 1) {
    info.multipassCount = i;
    // TODO throw this error in v3
    try {
      svgjs = parseSvg(input, config.path);
    } catch (error) {
      return { error: error.toString(), modernError: error };
    }
    if (svgjs.error != null) {
      if (config.path != null) {
        svgjs.path = config.path;
      }
      return svgjs;
    }
    const plugins = config.plugins || defaultPlugins;
    if (Array.isArray(plugins) === false) {
      throw Error(
        "Invalid plugins list. Provided 'plugins' in config should be an array."
      );
    }
    const resolvedPlugins = plugins.map(resolvePluginConfig);
    const globalOverrides = {};
    if (config.floatPrecision != null) {
      globalOverrides.floatPrecision = config.floatPrecision;
    }
    svgjs = invokePlugins(svgjs, info, resolvedPlugins, null, globalOverrides);
    svgjs = stringifySvg(svgjs, config.js2svg);
    if (svgjs.data.length < prevResultSize) {
      input = svgjs.data;
      prevResultSize = svgjs.data.length;
    } else {
      if (config.datauri) {
        svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
      }
      if (config.path != null) {
        svgjs.path = config.path;
      }
      return svgjs;
    }
  }
  return svgjs;
};
svgo.optimize = optimize$1;

/**
 * The factory that creates a content item with the helper methods.
 *
 * @param {Object} data which is passed to jsAPI constructor
 * @returns {JSAPI} content item
 */
const createContentItem$1 = (data) => {
  return new JSAPI(data);
};
svgo.createContentItem = createContentItem$1;

const os = require$$0$4;
const {
  extendDefaultPlugins,
  optimize: optimizeAgnostic,
  createContentItem,
} = svgo;

const optimize = (input, config) => {
  if (config == null) {
    config = {};
  }
  if (typeof config !== 'object') {
    throw Error('Config should be an object');
  }
  return optimizeAgnostic(input, {
    ...config,
    js2svg: {
      // platform specific default for end of line
      eol: os.EOL === '\r\n' ? 'crlf' : 'lf',
      ...config.js2svg,
    },
  });
};
var optimize_1 = optimize;

const splitAttrsTokenizer = /([a-z0-9_\:\-]*)\s*?=\s*?(['"]?)(.*?)\2\s+/gim;
const domParserTokenizer = /(?:<(\/?)([a-zA-Z][a-zA-Z0-9\:]*)(?:\s([^>]*?))?((?:\s*\/)?)>|(<\!\-\-)([\s\S]*?)(\-\->)|(<\!\[CDATA\[)([\s\S]*?)(\]\]>))/gm;
const splitAttrs = (str) => {
  let res = {};
  let token;
  if (str) {
    splitAttrsTokenizer.lastIndex = 0;
    str = " " + (str || "") + " ";
    while (token = splitAttrsTokenizer.exec(str)) {
      res[token[1]] = token[3];
    }
  }
  return res;
};
function optimizeSvg(contents, name, options) {
  return optimize_1(contents, {
    plugins: [
      "removeDoctype",
      "removeXMLProcInst",
      "removeComments",
      "removeMetadata",
      "removeXMLNS",
      "removeEditorsNSData",
      "cleanupAttrs",
      "minifyStyles",
      "convertStyleToAttrs",
      {
        name: "cleanupIDs",
        params: { prefix: `${SPRITESHEET_NAMESPACE}:${name}` }
      },
      "removeRasterImages",
      "removeUselessDefs",
      "cleanupNumericValues",
      "cleanupListOfValues",
      "convertColors",
      "removeUnknownsAndDefaults",
      "removeNonInheritableGroupAttrs",
      "removeUselessStrokeAndFill",
      "removeViewBox",
      "cleanupEnableBackground",
      "removeHiddenElems",
      "removeEmptyText",
      "convertShapeToPath",
      "moveElemsAttrsToGroup",
      "moveGroupAttrsToElems",
      "collapseGroups",
      "convertPathData",
      "convertTransform",
      "removeEmptyAttrs",
      "removeEmptyContainers",
      "mergePaths",
      "removeUnusedNS",
      "sortAttrs",
      "removeTitle",
      "removeDesc",
      "removeDimensions",
      "removeStyleElement",
      "removeScriptElement"
    ]
  }).data;
}
const preprocessCache = /* @__PURE__ */ new Map();
function preprocess(contents, name, { optimize }) {
  if (preprocessCache.has(contents)) {
    return preprocessCache.get(contents);
  }
  if (optimize) {
    contents = optimizeSvg(contents, name);
  }
  domParserTokenizer.lastIndex = 0;
  let result = contents;
  let token;
  if (contents) {
    while (token = domParserTokenizer.exec(contents)) {
      const tag = token[2];
      if (tag === "svg") {
        const attrs = splitAttrs(token[3]);
        result = contents.slice(domParserTokenizer.lastIndex).replace(/<\/svg>/gim, "").trim();
        const value = { innerHTML: result, defaultProps: attrs };
        preprocessCache.set(contents, value);
        return value;
      }
    }
  }
}
function normalizeProps(inputProps) {
  const size = inputProps.size;
  delete inputProps.size;
  const w = inputProps.width ?? size;
  const h = inputProps.height ?? size;
  const width = w ? toAttributeSize(w) : void 0;
  const height = h ? toAttributeSize(h) : void 0;
  return { ...inputProps, width, height };
}
const toAttributeSize = (size) => String(size).replace(/(?<=[0-9])x$/, "em");
const fallback = {
  innerHTML: '<rect width="24" height="24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" />',
  props: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }
};
async function load(name, inputProps, optimize) {
  const key = name;
  if (!name) {
    throw new Error("<Icon> requires a name!");
  }
  let svg = "";
  let filepath = "";
  if (name.includes(":")) {
    const [pack, ..._name] = name.split(":");
    name = _name.join(":");
    filepath = `/src/icons/${pack}`;
    let get$1;
    try {
      const files = /* #__PURE__ */ Object.assign({

});
      const keys = Object.fromEntries(
        Object.keys(files).map((key2) => [key2.replace(/\.[cm]?[jt]s$/, ""), key2])
      );
      if (!(filepath in keys)) {
        throw new Error(`Could not find the file "${filepath}"`);
      }
      const mod = files[keys[filepath]];
      if (typeof mod.default !== "function") {
        throw new Error(
          `[astro-icon] "${filepath}" did not export a default function!`
        );
      }
      get$1 = mod.default;
    } catch (e) {
    }
    if (typeof get$1 === "undefined") {
      get$1 = get.bind(null, pack);
    }
    const contents = await get$1(name, inputProps);
    if (!contents) {
      throw new Error(
        `<Icon pack="${pack}" name="${name}" /> did not return an icon!`
      );
    }
    if (!/<svg/gim.test(contents)) {
      throw new Error(
        `Unable to process "<Icon pack="${pack}" name="${name}" />" because an SVG string was not returned!

Recieved the following content:
${contents}`
      );
    }
    svg = contents;
  } else {
    filepath = `/src/icons/${name}.svg`;
    try {
      const files = /* #__PURE__ */ Object.assign({});
      if (!(filepath in files)) {
        throw new Error(`Could not find the file "${filepath}"`);
      }
      const contents = files[filepath];
      if (!/<svg/gim.test(contents)) {
        throw new Error(
          `Unable to process "${filepath}" because it is not an SVG!

Recieved the following content:
${contents}`
        );
      }
      svg = contents;
    } catch (e) {
      throw new Error(
        `[astro-icon] Unable to load "${filepath}". Does the file exist?`
      );
    }
  }
  const { innerHTML, defaultProps } = preprocess(svg, key, { optimize });
  if (!innerHTML.trim()) {
    throw new Error(`Unable to parse "${filepath}"!`);
  }
  return {
    innerHTML,
    props: { ...defaultProps, ...normalizeProps(inputProps) }
  };
}

const $$Astro$m = createAstro("https://nadderud.no");
const $$Icon = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$m, $$props, $$slots);
  Astro2.self = $$Icon;
  let { name, pack, title, optimize = true, class: className, ...inputProps } = Astro2.props;
  let props = {};
  if (pack) {
    name = `${pack}:${name}`;
  }
  let innerHTML = "";
  try {
    const svg = await load(name, { ...inputProps, class: className }, optimize);
    innerHTML = svg.innerHTML;
    props = svg.props;
  } catch (e) {
    innerHTML = fallback.innerHTML;
    props = { ...fallback.props, ...normalizeProps(inputProps) };
    title = `Failed to load "${name}"!`;
    console.error(e);
  }
  return renderTemplate`${maybeRenderHead($$result)}<svg${spreadAttributes(props)}${addAttribute(name, "astro-icon")}>${unescapeHTML((title ? `<title>${title}</title>` : "") + innerHTML)}</svg>`;
}, "/home/martin/Documents/GitHub/mason/node_modules/.pnpm/astro-icon@0.8.0/node_modules/astro-icon/lib/Icon.astro");

const sprites = /* @__PURE__ */ new WeakMap();
function trackSprite(request, name) {
  let currentSet = sprites.get(request);
  if (!currentSet) {
    currentSet = /* @__PURE__ */ new Set([name]);
  } else {
    currentSet.add(name);
  }
  sprites.set(request, currentSet);
}
const warned = /* @__PURE__ */ new Set();
async function getUsedSprites(request) {
  const currentSet = sprites.get(request);
  if (currentSet) {
    return Array.from(currentSet);
  }
  if (!warned.has(request)) {
    const { pathname } = new URL(request.url);
    console.log(`[astro-icon] No sprites found while rendering "${pathname}"`);
    warned.add(request);
  }
  return [];
}

const $$Astro$l = createAstro("https://nadderud.no");
const $$Spritesheet = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$l, $$props, $$slots);
  Astro2.self = $$Spritesheet;
  const { optimize = true, style, ...props } = Astro2.props;
  const names = await getUsedSprites(Astro2.request);
  const icons = await Promise.all(names.map((name) => {
    return load(name, {}, optimize).then((res) => ({ ...res, name })).catch((e) => {
      return { ...fallback, name };
    });
  }));
  return renderTemplate`${maybeRenderHead($$result)}<svg${addAttribute(`position: absolute; width: 0; height: 0; overflow: hidden; ${style ?? ""}`.trim(), "style")}${spreadAttributes({ "aria-hidden": true, ...props })} astro-icon-spritesheet>
    ${icons.map((icon) => renderTemplate`<symbol${spreadAttributes(icon.props)}${addAttribute(`${SPRITESHEET_NAMESPACE}:${icon.name}`, "id")}>${unescapeHTML(icon.innerHTML)}</symbol>`)}
</svg>`;
}, "/home/martin/Documents/GitHub/mason/node_modules/.pnpm/astro-icon@0.8.0/node_modules/astro-icon/lib/Spritesheet.astro");

const $$Astro$k = createAstro("https://nadderud.no");
const $$SpriteProvider = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$k, $$props, $$slots);
  Astro2.self = $$SpriteProvider;
  const content = await Astro2.slots.render("default");
  return renderTemplate`${renderComponent($$result, "Fragment", Fragment, {}, { "default": ($$result2) => renderTemplate`${unescapeHTML(content)}` })}
${renderComponent($$result, "Spritesheet", $$Spritesheet, {})}`;
}, "/home/martin/Documents/GitHub/mason/node_modules/.pnpm/astro-icon@0.8.0/node_modules/astro-icon/lib/SpriteProvider.astro");

const $$Astro$j = createAstro("https://nadderud.no");
const $$Sprite = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$j, $$props, $$slots);
  Astro2.self = $$Sprite;
  let { name, pack, title, class: className, x, y, ...inputProps } = Astro2.props;
  const props = normalizeProps(inputProps);
  if (pack) {
    name = `${pack}:${name}`;
  }
  const href = `#${SPRITESHEET_NAMESPACE}:${name}`;
  trackSprite(Astro2.request, name);
  return renderTemplate`${maybeRenderHead($$result)}<svg${spreadAttributes(props)}${addAttribute(className, "class")}${addAttribute(name, "astro-icon")}>
    ${title ? renderTemplate`<title>${title}</title>` : ""}
    <use${spreadAttributes({ "xlink:href": href, width: props.width, height: props.height, x, y })}></use>
</svg>`;
}, "/home/martin/Documents/GitHub/mason/node_modules/.pnpm/astro-icon@0.8.0/node_modules/astro-icon/lib/Sprite.astro");

Object.assign($$Sprite, { Provider: $$SpriteProvider });

const $$Astro$i = createAstro("https://nadderud.no");
const $$ToggleMenu = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$i, $$props, $$slots);
  Astro2.self = $$ToggleMenu;
  const {
    label = "Toggle Menu",
    class: className = "ml-1.5 text-gray-500 dark:text-gray-400 hover:bg-gray-100 focus:outline-none focus:ring-4 focus:ring-gray-200  rounded-lg text-sm p-2.5 inline-flex items-center transition",
    iconClass = "w-6 h-6",
    iconName = "tabler:menu"
  } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<button type="button"${addAttribute(className, "class")}${addAttribute(label, "aria-label")} data-aw-toggle-menu>
  ${renderComponent($$result, "Icon", $$Icon, { "name": iconName, "class": iconClass, "optimize": false })}
</button>`;
}, "/home/martin/Documents/GitHub/mason/src/components/common/ToggleMenu.astro");

const $$Astro$h = createAstro("https://nadderud.no");
const $$Header = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$h, $$props, $$slots);
  Astro2.self = $$Header;
  const { links = [] } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<header id="header">
  <div class="navbar bg-base-100 max-w-6xl mx-auto sticky z-20">
    <div class="navbar-start">
      <a class="btn btn-ghost normal-case text-xl" href="/"> ${renderComponent($$result, "Logo", $$Logo, {})}</a>
    </div>
    <nav class="navbar-center hidden lg:flex">
      <ul class="menu menu-horizontal px-1">
        ${links.map(({ text, href, links: links2 }) => renderTemplate`<li${addAttribute(links2?.length ? "dropdown" : "", "class")}${addAttribute(0, "tab-index")}>
              ${links2?.length ? renderTemplate`${renderComponent($$result, "Fragment", Fragment, {}, { "default": ($$result2) => renderTemplate`<a>
                    ${text}
                    <svg class="fill-current" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                      <path d="M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z"></path>
                    </svg>
                  </a><ul class="bg-base-100 shadow-lg">
                    ${links2.map(({ text: text2, href: href2 }) => renderTemplate`<li>
                        <a${addAttribute(href2, "href")}>${text2}</a>
                      </li>`)}
                  </ul>` })}` : renderTemplate`<a class="font-medium hover:text-gray-900 px-4 py-3 flex items-center transition duration-150 ease-in-out"${addAttribute(href, "href")}>
                  ${text}
                </a>`}
            </li>`)}
      </ul>
    </nav>
    <div class="navbar-end">
      <a class="btn btn-primary btn-sm" href="/bli-speider">Bli speider</a>
      <div class="flex items-center lg:hidden">
        ${renderComponent($$result, "ToggleMenu", $$ToggleMenu, {})}
      </div>
    </div>
  </div>
  <ul class="menu px-1 hidden" id="mobile-menue">
    ${links.map(({ text, href, links: links2 }) => renderTemplate`<li${addAttribute(links2?.length ? "dropdown" : "", "class")}${addAttribute(0, "tab-index")}>
          ${links2?.length ? renderTemplate`${renderComponent($$result, "Fragment", Fragment, {}, { "default": ($$result2) => renderTemplate`<a>
                ${text}
                <svg class="fill-current" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                  <path d="M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z"></path>
                </svg>
              </a><ul class="bg-base-100 shadow-lg">
                ${links2.map(({ text: text2, href: href2 }) => renderTemplate`<li>
                    <a${addAttribute(href2, "href")}>${text2}</a>
                  </li>`)}
              </ul>` })}` : renderTemplate`<a class="font-medium hover:text-gray-900 px-4 py-3 flex items-center transition duration-150 ease-in-out"${addAttribute(href, "href")}>
              ${text}
            </a>`}
        </li>`)}
  </ul>
</header>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/Header.astro");

const $$Astro$g = createAstro("https://nadderud.no");
const $$Footer = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$g, $$props, $$slots);
  Astro2.self = $$Footer;
  return renderTemplate`${maybeRenderHead($$result)}<footer id="footer" class="bg-base-200 text-center p-2 flex gap-2 justify-center">
    <p>Â© ${( new Date()).getFullYear()} Nadderud Speidergruppe</p>
    <a class="link" href="/personvern">Personvern</a>
</footer>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/Footer.astro");

const $$Astro$f = createAstro("https://nadderud.no");
const $$Announcement = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$f, $$props, $$slots);
  Astro2.self = $$Announcement;
  return renderTemplate`${maybeRenderHead($$result)}<section id="announcement" class="hidden md:block bg-blue-900 dark:bg-slate-800 dark:border-slate-800 dark:text-slate-400 border-b border-blue-900 text-sm px-3 py-2 text-gray-200 overflow-hidden whitespace-nowrap text-ellipsis">
</section>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/Announcement.astro");

const headerData = {
  links: [
    {
      text: "Artikler",
      href: "/artikler"
    },
    {
      text: "Wiki",
      href: "/wiki"
    },
    {
      text: "Program",
      href: "/program"
    },
    {
      text: "Kontakt oss",
      href: "/info"
    }
  ]
};

const $$Astro$e = createAstro("https://nadderud.no");
const $$PageLayout = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$e, $$props, $$slots);
  Astro2.self = $$PageLayout;
  const { meta } = Astro2.props;
  return renderTemplate`${renderComponent($$result, "Layout", $$BaseLayout, { "meta": meta }, { "default": ($$result2) => renderTemplate`${renderSlot($$result2, $$slots["announcement"], renderTemplate`
    ${renderComponent($$result2, "Announcement", $$Announcement, {})}
  `)}${renderSlot($$result2, $$slots["header"], renderTemplate`
    ${renderComponent($$result2, "Header", $$Header, { ...headerData })}
  `)}${maybeRenderHead($$result2)}<main class="bg-base-100 grow flex flex-col">
    ${renderSlot($$result2, $$slots["default"])}
  </main>${renderSlot($$result2, $$slots["footer"], renderTemplate`
    ${renderComponent($$result2, "Footer", $$Footer, {})}
  `)}` })}`;
}, "/home/martin/Documents/GitHub/mason/src/layouts/PageLayout.astro");

const $$Astro$d = createAstro("https://nadderud.no");
const $$FrontpageHero = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$d, $$props, $$slots);
  Astro2.self = $$FrontpageHero;
  const { slagord, description, featuredImage } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<section id="hero" class="hero-section astro-GRDUWYPQ">
  <h1 class="text-4xl tracking-tight md:text-5xl md:w-150 z-10 pt-12 astro-GRDUWYPQ" style="grid-area: title;">
    ${slagord}
  </h1>
  <p class="hero-text astro-GRDUWYPQ" style="grid-area: text;">
    ${description}
  </p>
  <img${addAttribute(featuredImage, "src")} class="aspect-square object-cover image astro-GRDUWYPQ" alt="Astro" style="grid-area: image;">
</section>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/FrontpageHero.astro");

const spondBaseApiUrl = "https://api.spond.com/core/v1/";
const getEvents = async (groupId) => {
  const { data } = await axios.get(`${spondBaseApiUrl}sponds`, {
    params: {
      groupId: "FFD5200F30364D0B860F39FA04C0C603",
      subGroupId: groupId,
      order: "asc",
      scheduled: true,
      addProfileInfo: false,
      includeHidden: true,
      includeComments: false,
      max: 10,
      minEndTimestamp: /* @__PURE__ */ new Date()
    },
    headers: {
      Authorization: `Bearer ${"ZXlKaGJHY2lPaUpJVXpVeE1pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnpkV0lpT2lJdmRDOXpNMkZDY1ZGTk1EWXJVV2Q2Y1hKSVZHNU9OVWR5S3pObGQxbE1SakIwVTA5MGFUQnBOMnBqVERGM1UydEJTaXR0YkdZdlpWQjZSazEyYjBwWFpUQlVORkJHTURWYWNscDNMMkZWZDFkYVNrZDRWelkxVDJjd0t6TTNWRmxwUVVncmFqSndUQ3RaWldKeFQxRkJSbUp4TjBkUmRUVlpObE56SWl3aWRpSTZNaXdpYVhOeklqb2ljM0J2Ym1RdVkyOXRJaXdpZEhsd1pTSTZNVEY5Lkx2TVBSM2M1d3VISkQ1OXhCZWkycTFTeEJVNUkxSXhLWTlXTGtramVWUmI1d1MtRl84RkF4a0ZhRlFGbmJFX213MzEzNjMwdEtlX0x3bWkxRG1yWUtR"}`,
      accept: "application/json",
      "Api-level": "2.5.53"
    }
  });
  return data;
};
const getEventsFromSelectedGroups = async (groupIds) => {
  try {
    const allEvents = await Promise.all(
      groupIds.map((groupId) => getEvents(groupId))
    );
    return allEvents.flat();
  } catch (error) {
    console.error("Error fetching events from Spond", error);
    return [];
  }
};

const $$Astro$c = createAstro("https://nadderud.no");
const $$FrontpageEvents = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$c, $$props, $$slots);
  Astro2.self = $$FrontpageEvents;
  const subGroupIds = [
    "DEB269433BAD4F0F9F96AAC757678537",
    "6549C386074E409EAAF5EDA6336129E5"
  ];
  const rawEvents = await getEventsFromSelectedGroups(subGroupIds);
  const events = rawEvents.slice(0, 4);
  const { description } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<section id="events-summary" class="events px-5 pt-8 astro-26RH7TWD">
  <div style="grid-area: text;" class="relative astro-26RH7TWD">
    <h2 class="text-2xl tracking-tight py-4 astro-26RH7TWD">Kommende arrangementer</h2>
    <p class="astro-26RH7TWD">
      ${description}
    </p>
    <p class="py-2 astro-26RH7TWD">
      Trenger du bruker pÃ¥ Spond? <a href="/info" class="link astro-26RH7TWD">Kontakt oss</a>
    </p>
  </div>
  ${events.map((event, i) => renderTemplate`<div${addAttribute(`grid-area:${i === 0 ? "event-large" : ""}`, "style")} class="h-full flex flex-col astro-26RH7TWD">
        <img class="bg-base-200 object-cover astro-26RH7TWD"${addAttribute(event.picture || "/img/upload/vann.jpg", "src")}${addAttribute(`Bilde til ${event.heading}`, "alt")} loading="lazy">
        <p class="astro-26RH7TWD">${new Date(event.startTimestamp).toLocaleDateString("no-NO", { day: "2-digit", weekday: "short", month: "long" })}</p>
        <h3 class="font-bold astro-26RH7TWD">${event.heading}</h3>
      </div>`)}
</section>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/FrontpageEvents.astro");

const $$Astro$b = createAstro("https://nadderud.no");
const $$ImageLarge = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$b, $$props, $$slots);
  Astro2.self = $$ImageLarge;
  const { title, src, alt } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<section id="large-image" class="astro-33DS2Y4J">
    <h3 class="text-3xl tracking-tight font-bold md:text-4xl md:w-150 z-10 astro-33DS2Y4J">${title}</h3>
    <img${addAttribute(src, "src")}${addAttribute(alt || title, "alt")} class="bg-base-200 astro-33DS2Y4J">
</section>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/ImageLarge.astro");

const $$Astro$a = createAstro("https://nadderud.no");
const $$WhoCanJoinInfo = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$a, $$props, $$slots);
  Astro2.self = $$WhoCanJoinInfo;
  const data = [
    {
      title: "3.-4. klasse",
      tag: "Flokken",
      tagColor: "yellow"
    },
    {
      title: "5.-10. klasse",
      tag: "Troppen",
      tagColor: "blue"
    },
    {
      title: "1.VGS - 25 \xE5r",
      tag: "Rover",
      tagColor: "green"
    }
  ];
  const { texts = ["", "", ""] } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<section id="who-can-join" class="astro-U7J6M7T7">
  ${data.map((detail, i) => renderTemplate`<div class="card w-full bg-base-100 shadow-xl astro-U7J6M7T7">
        <div class="card-body astro-U7J6M7T7">
          <h2 class="card-title self-center astro-U7J6M7T7">
            ${detail.title}
            <div class="badge badge-secondary astro-U7J6M7T7">${detail.tag}</div>
          </h2>
          <p class="astro-U7J6M7T7">${texts[i]}</p>
        </div>
      </div>`)}
</section>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/WhoCanJoinInfo.astro");

const $$Astro$9 = createAstro("https://nadderud.no");
const $$JoinScoutGroup = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$9, $$props, $$slots);
  Astro2.self = $$JoinScoutGroup;
  return renderTemplate`${maybeRenderHead($$result)}<section id="join-scout-group" class="text-center py-16">
    <h2 class="text-3xl font-bold mb-4">Bli speider</h2>
    <p>Ler mer om hvordan du blir speider her.</p>
    <a href="/bli-speider" class="btn btn-primary my-4">Bli speider</a>
</section>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/JoinScoutGroup.astro");

const $$Astro$8 = createAstro("https://nadderud.no");
const $$FrontpageLayout = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$8, $$props, $$slots);
  Astro2.self = $$FrontpageLayout;
  const { frontmatter } = Astro2.props;
  const meta = {
    title: SITE.title,
    description: SITE.description,
    dontUseTitleTemplate: true
  };
  return renderTemplate`${renderComponent($$result, "PageLayout", $$PageLayout, { "meta": meta }, { "default": ($$result2) => renderTemplate`${renderComponent($$result2, "FrontpageHero", $$FrontpageHero, { "slagord": frontmatter.slagord, "description": frontmatter.description, "featuredImage": frontmatter.featuredImage })}${renderComponent($$result2, "FrontpageEvents", $$FrontpageEvents, { "description": frontmatter.eventText })}${renderComponent($$result2, "ImageLarge", $$ImageLarge, { "title": "Speiding er spennende og gir venner for livet!", "src": frontmatter.largeImage, "alt": "Speiding er spennende og gir venner for livet!" })}${renderComponent($$result2, "WhoCanJoinInfo", $$WhoCanJoinInfo, { "texts": [frontmatter.flokkenText, frontmatter.troppenText, frontmatter.roverText] })}${renderComponent($$result2, "JoinScoutGroup", $$JoinScoutGroup, {})}${renderSlot($$result2, $$slots["default"])}` })}`;
}, "/home/martin/Documents/GitHub/mason/src/layouts/FrontpageLayout.astro");

const images$A = {
					
				};

				function updateImageReferences$A(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$A[imagePath].src, ...images$A[imagePath].attributes})
					);
				}

				const html$A = updateImageReferences$A("");

				const frontmatter$A = {"layout":"../layouts/FrontpageLayout.astro","slagord":"Friluft, mestring og samhold!","featuredImage":"/img/upload/leirbaal.jpg","description":"Spennende friluftsliv for barn og ungdom fra 3. klasse og oppover. Vi er en aktiv speidergruppe med ca. 100 medlemmer som dekker omrÃ¥det Nadderud, Bekkestua, Hosle, Eikeli og Haslum.","eventText":"Naddeurd speidergruppe gjennomfÃ¸rer mange spennende turer, arrangementer og mÃ¸ter gjennom Ã¥ret. Sammen lager vi den beste friliftlivsopplevelsen! For Ã¥ holde deg som forelder/speider oppdatert gjennom Ã¥ret, bruker vi Spond. Her kan du se noen av de kommende arrangementene.","largeImage":"/img/upload/img_20210703_081612_706.jpg","flokkenText":"Speiderne i flokken er 3. klasse og 4. klasse. Vi mÃ¸tes hver tirsdag fra 18:00 til 19:30. Vi har mange spennende aktiviteter som speiderleker, bÃ¥l, lek og mye mer.","troppenText":"Speiderne i troppen gÃ¥r i 5.-til 10. klasse. Vi mÃ¸tes hver mandag fra 18:00 til 19:00. Vi har mange mÃ¸ter, turer og sommerleir hvert Ã¥r.","roverText":"Roverne er speidere som gÃ¥r pÃ¥ videregÃ¥ende skole og oppover. Vi gjÃ¸r veldig mye spennende. Vi hjelper til med Ã¥ planlegge og gjennomfÃ¸re arrangementer, leirer, vi har mÃ¸ter og vi har mye moro sammen."};
				const file$A = "/home/martin/Documents/GitHub/mason/src/pages/index.md";
				const url$A = "";
				function rawContent$A() {
					return "";
				}
				function compiledContent$A() {
					return html$A;
				}
				function getHeadings$A() {
					return [];
				}
				async function Content$A() {
					const { layout, ...content } = frontmatter$A;
					content.file = file$A;
					content.url = url$A;
					const contentFragment = createVNode(Fragment, { 'set:html': html$A });
					return createVNode($$FrontpageLayout, {
									file: file$A,
									url: url$A,
									content,
									frontmatter: content,
									headings: getHeadings$A(),
									rawContent: rawContent$A,
									compiledContent: compiledContent$A,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$A[Symbol.for('astro.needsHeadRendering')] = false;

const _page0 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$A,
  compiledContent: compiledContent$A,
  default: Content$A,
  file: file$A,
  frontmatter: frontmatter$A,
  getHeadings: getHeadings$A,
  images: images$A,
  rawContent: rawContent$A,
  url: url$A
}, Symbol.toStringTag, { value: 'Module' }));

const $$Astro$7 = createAstro("https://nadderud.no");
const $$Hero = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$7, $$props, $$slots);
  Astro2.self = $$Hero;
  const { image, title, description } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<section>
  <div class="h-80 relative flex justify-center items-center">
    <img${addAttribute(image, "src")}${addAttribute(`Forside bilde til siden "${title}"`, "alt")} class="object-cover w-full h-full" fetchpriority="high" loading="eager">
    <h1 class="absolute text-3xl tracking-tight font-bold md:text-4xl py-6 px-10 bg-base-100 italic">${title}</h1>
  </div>
  ${description && renderTemplate`<div class="p-4 bg-base-100"><p class="max-w-2xl mx-auto border-b-2 pb-5 pt-2">${description}</p></div>`}
</section>`;
}, "/home/martin/Documents/GitHub/mason/src/components/common/Hero.astro");

const $$Astro$6 = createAstro("https://nadderud.no");
const $$MarkdownPageLayout = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$6, $$props, $$slots);
  Astro2.self = $$MarkdownPageLayout;
  const { frontmatter } = Astro2.props;
  return renderTemplate`${renderComponent($$result, "PageLayout", $$PageLayout, { "meta": { title: frontmatter.title, description: frontmatter.description, image: frontmatter.image } }, { "default": ($$result2) => renderTemplate`${frontmatter && frontmatter.image ? renderTemplate`${renderComponent($$result2, "Hero", $$Hero, { ...frontmatter })}` : null}${maybeRenderHead($$result2)}<section class="prose max-w-2xl mx-auto p-4">
    ${frontmatter && !frontmatter.image && frontmatter.title ? renderTemplate`<h1 class="pt-10">${frontmatter.title}</h1>` : null}
    ${renderSlot($$result2, $$slots["default"])}
  </section>` })}`;
}, "/home/martin/Documents/GitHub/mason/src/layouts/MarkdownPageLayout.astro");

const images$z = {
					
				};

				function updateImageReferences$z(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$z[imagePath].src, ...images$z[imagePath].attributes})
					);
				}

				const html$z = updateImageReferences$z("<p><a href=\"https://min.speiding.no/register/in/group/1003\" target=\"_blank\">GÃ¥ til innmeldingsskjema (egen fane)</a></p>\n<h2 id=\"spÃ¸rsmÃ¥l-om-speiding\">SpÃ¸rsmÃ¥l om speiding</h2>\n<h3 id=\"hva-er-speiding\">Hva er speiding?</h3>\n<p>Speiding er aktivt friluftsliv. Det er en stor Ã¥ viktig del av speiderarbeidet Ã¥ vÃ¦re ute i naturen. Bli kjent med naturen og klare seg uansett forhold. Speiding er vennskap og opplevelser for livet. Gjennom felles eventyr og opplevelser, utvikler man et spesielt forhold til menneskene rundt seg, som kan vare livet ut. 28 millioner speidere pÃ¥ verdensbasis kan ikke ta feil. Hva venter du pÃ¥? Eventyrene er der ute!</p>\n<h3 id=\"hvem-kan-bli-speider\">Hvem kan bli speider?</h3>\n<p>Alle barn og ungdom fra 3. klasse til 25 Ã¥r kan bli speidere. Du trenger ingen forkunnskaper - og du kan begynne nÃ¥r du vil. Noen begynner med en gang de er gamle nok, andre litt senere.</p>\n<h3 id=\"nÃ¥r-kan-jeg-begynne-i-speideren\">NÃ¥r kan jeg begynne i speideren?</h3>\n<p>De fleste vil begynne pÃ¥ hÃ¸sten, ved skolestart. Men sÃ¥ lenge det er plass tar vi inn nye speidere gjennom hele Ã¥ret.</p>\n<h3 id=\"hvor-mye-tid-tar-speideren\">Hvor mye tid tar speideren?</h3>\n<p>Vi har mÃ¸ter Ã©n gang i uka. MÃ¸tene tar vanligvis en time. I tillegg er det noen overnattingsturer. Jo eldre du er, jo flere turer har vi. Se <a href=\"/program/\">program</a> for en oversikt over turer og mÃ¸ter.</p>\n<h3 id=\"er-det-dyrt-Ã¥-vÃ¦re-speider\">Er det dyrt Ã¥ vÃ¦re speider?</h3>\n<p>Nei. Vi har en medlemskontingent pÃ¥ litt over 1 200 kr i Ã¥ret, som dekker de aller fleste arrangementer et helt Ã¥r. (Speidere som begynner pÃ¥ hÃ¸sten betaler halv kontingent for hÃ¸sten.) Noen stÃ¸rre arrangementer (f.eks. sommerleir) har egen deltakeravgift. Ellers trenger du litt turutstyr og mat og drikke til turene.</p>\n<h3 id=\"kreves-det-mye-foreldreinnsats-i-speideren-til-dugnader-ol\">Kreves det mye foreldreinnsats i speideren (til dugnader o.l.)?</h3>\n<p>Nei, slett ikke. Vi er riktignok en frivillig organisasjon, som er avhengig av at noen gjÃ¸r en frivillig innsats for Ã¥ holde hjulene i gang, men det stilles ingen krav om engasjement fra foreldrene. I lÃ¸pet av et Ã¥r vil foreldre vanligvis bli bedt om Ã¥ stille pÃ¥ Ã©n vedlikeholdsdugnad (en lÃ¸rdag eller sÃ¸ndag formiddag) pÃ¥ speiderhytta vÃ¥r og 1-2 inntektsgivende dugnader (et par timer en kveld).</p>\n<h3 id=\"kan-jeg-begynne-i-speideren-selv-om-jeg-er-over-25-Ã¥r\">Kan jeg begynne i speideren selv om jeg er over 25 Ã¥r?</h3>\n<p>Ja! Vi trenger ledere. Alle friluftsinteresserte ungdom og voksne som har lyst til Ã¥ vÃ¦re med Ã¥ drive speidergruppa er velkomne. Du trenger ikke ha noen tidligere erfaring med speiding eller friluftsliv - det holder at du har lyst til Ã¥ lÃ¦re. Ledertrening i speideren er dessuten en god erfaring Ã¥ ha med seg videre i livet. Ta kontakt for en uforpliktende prat!</p>");

				const frontmatter$z = {"layout":"../layouts/MarkdownPageLayout.astro","title":"Bli speider","image":"/img/upload/leirbaal.jpg","description":"Speidere synes det er gÃ¸y Ã¥ vÃ¦re ute. Du kan bli speider hvis du gÃ¥r i 3. klasse eller mer."};
				const file$z = "/home/martin/Documents/GitHub/mason/src/pages/bli-speider.md";
				const url$z = "/bli-speider";
				function rawContent$z() {
					return "\n<a href=\"https://min.speiding.no/register/in/group/1003\" target=\"_blank\">GÃ¥ til innmeldingsskjema (egen fane)</a>\n\n## SpÃ¸rsmÃ¥l om speiding\n\n### Hva er speiding?\n\nSpeiding er aktivt friluftsliv. Det er en stor Ã¥ viktig del av speiderarbeidet Ã¥ vÃ¦re ute i naturen. Bli kjent med naturen og klare seg uansett forhold. Speiding er vennskap og opplevelser for livet. Gjennom felles eventyr og opplevelser, utvikler man et spesielt forhold til menneskene rundt seg, som kan vare livet ut. 28 millioner speidere pÃ¥ verdensbasis kan ikke ta feil. Hva venter du pÃ¥? Eventyrene er der ute!\n\n### Hvem kan bli speider?\n\nAlle barn og ungdom fra 3. klasse til 25 Ã¥r kan bli speidere. Du trenger ingen forkunnskaper - og du kan begynne nÃ¥r du vil. Noen begynner med en gang de er gamle nok, andre litt senere.\n\n### NÃ¥r kan jeg begynne i speideren?\n\nDe fleste vil begynne pÃ¥ hÃ¸sten, ved skolestart. Men sÃ¥ lenge det er plass tar vi inn nye speidere gjennom hele Ã¥ret.\n\n### Hvor mye tid tar speideren?\n\nVi har mÃ¸ter Ã©n gang i uka. MÃ¸tene tar vanligvis en time. I tillegg er det noen overnattingsturer. Jo eldre du er, jo flere turer har vi. Se [program](/program/) for en oversikt over turer og mÃ¸ter.\n\n### Er det dyrt Ã¥ vÃ¦re speider?\n\nNei. Vi har en medlemskontingent pÃ¥ litt over 1 200 kr i Ã¥ret, som dekker de aller fleste arrangementer et helt Ã¥r. (Speidere som begynner pÃ¥ hÃ¸sten betaler halv kontingent for hÃ¸sten.) Noen stÃ¸rre arrangementer (f.eks. sommerleir) har egen deltakeravgift. Ellers trenger du litt turutstyr og mat og drikke til turene.\n\n### Kreves det mye foreldreinnsats i speideren (til dugnader o.l.)?\n\nNei, slett ikke. Vi er riktignok en frivillig organisasjon, som er avhengig av at noen gjÃ¸r en frivillig innsats for Ã¥ holde hjulene i gang, men det stilles ingen krav om engasjement fra foreldrene. I lÃ¸pet av et Ã¥r vil foreldre vanligvis bli bedt om Ã¥ stille pÃ¥ Ã©n vedlikeholdsdugnad (en lÃ¸rdag eller sÃ¸ndag formiddag) pÃ¥ speiderhytta vÃ¥r og 1-2 inntektsgivende dugnader (et par timer en kveld).\n\n### Kan jeg begynne i speideren selv om jeg er over 25 Ã¥r?\n\nJa! Vi trenger ledere. Alle friluftsinteresserte ungdom og voksne som har lyst til Ã¥ vÃ¦re med Ã¥ drive speidergruppa er velkomne. Du trenger ikke ha noen tidligere erfaring med speiding eller friluftsliv - det holder at du har lyst til Ã¥ lÃ¦re. Ledertrening i speideren er dessuten en god erfaring Ã¥ ha med seg videre i livet. Ta kontakt for en uforpliktende prat!\n";
				}
				function compiledContent$z() {
					return html$z;
				}
				function getHeadings$z() {
					return [{"depth":2,"slug":"spÃ¸rsmÃ¥l-om-speiding","text":"SpÃ¸rsmÃ¥l om speiding"},{"depth":3,"slug":"hva-er-speiding","text":"Hva er speiding?"},{"depth":3,"slug":"hvem-kan-bli-speider","text":"Hvem kan bli speider?"},{"depth":3,"slug":"nÃ¥r-kan-jeg-begynne-i-speideren","text":"NÃ¥r kan jeg begynne i speideren?"},{"depth":3,"slug":"hvor-mye-tid-tar-speideren","text":"Hvor mye tid tar speideren?"},{"depth":3,"slug":"er-det-dyrt-Ã¥-vÃ¦re-speider","text":"Er det dyrt Ã¥ vÃ¦re speider?"},{"depth":3,"slug":"kreves-det-mye-foreldreinnsats-i-speideren-til-dugnader-ol","text":"Kreves det mye foreldreinnsats i speideren (til dugnader o.l.)?"},{"depth":3,"slug":"kan-jeg-begynne-i-speideren-selv-om-jeg-er-over-25-Ã¥r","text":"Kan jeg begynne i speideren selv om jeg er over 25 Ã¥r?"}];
				}
				async function Content$z() {
					const { layout, ...content } = frontmatter$z;
					content.file = file$z;
					content.url = url$z;
					const contentFragment = createVNode(Fragment, { 'set:html': html$z });
					return createVNode($$MarkdownPageLayout, {
									file: file$z,
									url: url$z,
									content,
									frontmatter: content,
									headings: getHeadings$z(),
									rawContent: rawContent$z,
									compiledContent: compiledContent$z,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$z[Symbol.for('astro.needsHeadRendering')] = false;

const _page1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$z,
  compiledContent: compiledContent$z,
  default: Content$z,
  file: file$z,
  frontmatter: frontmatter$z,
  getHeadings: getHeadings$z,
  images: images$z,
  rawContent: rawContent$z,
  url: url$z
}, Symbol.toStringTag, { value: 'Module' }));

const images$y = {
					
				};

				function updateImageReferences$y(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$y[imagePath].src, ...images$y[imagePath].attributes})
					);
				}

				const html$y = updateImageReferences$y("<h2 id=\"generelt\">Generelt</h2>\n<p>De fleste organisasjoner og virksomheter som samler inn og bruker opplysninger om enkeltpersoner\nmÃ¥ fÃ¸lge personopplysningsloven. Dette gjelder ogsÃ¥ Nadderud speidergruppe. I dette dokumentet\nbeskriver vi hvordan og hvorfor vi bruker personopplysninger, og hvilke rettigheter du har\ndersom vi behandler opplysninger om deg.</p>\n<p>Gruppelederen er ansvarlig for behandling av personopplysninger i Nadderud speidergruppe.</p>\n<p>Vi bruker kontaktopplysninger om speiderne og foresatte til Ã¥:</p>\n<ul>\n<li>sende ut informasjon om aktiviteter og annen relevant informasjon pÃ¥ e-post eller SMS</li>\n<li>registrere pÃ¥melding til turer og andre arrangementer</li>\n<li>kontakte enkeltmedlemmer om medlemskapet, betaling e.l.</li>\n<li>rekruttere frivillige ledere og hjelpere til aktiviteter</li>\n</ul>\n<p>I tillegg bruker vi opplysninger om diett og andre relevante opplysninger som er nÃ¸dvendig\nfor Ã¥ tilrettelegge matservering og beredskap for speidere med sÃ¦rlige behov. Slike opplysninger\nsamles inn ved pÃ¥melding (helseskjema) til konkrete arrangementer og slettes etter at\narrangementet er gjennomfÃ¸rt.</p>\n<p>Vi vil bare ta imot og bruke helseopplysninger som vi fÃ¥r direkte fra speideren eller foresatte.\nVi ber om at dere ikke sender oss sensitive opplysninger pÃ¥ e-post.</p>\n<p>Vi ber ogsÃ¥ om samtykke til Ã¥ ta og dele bilder og video av speidere som deltar pÃ¥ aktivitetene\nvÃ¥re pÃ¥ internett og sosiale medier. Samtykket innhentes i pÃ¥meldingsskjemaet, men alle speidere\nkan selv gi og trekke samtykket i medlemsprofilen pÃ¥ <a href=\"https://min.speiding.no\">min.speiding.no</a>.</p>\n<h2 id=\"medlemskap\">Medlemskap</h2>\n<p>Nadderud speidergruppe er en del av Norges speiderforbund. Personopplysninger om\nmedlemskapet ditt blir behandlet etter <a href=\"https://speiding.no/personvernserklaering\">Norges speiderforbunds personvernerklÃ¦ring</a>.\nGrunnlaget for denne behandlingen er avtalen om medlemskap i Norges speiderforbund og ansvarlig\nfor behandlingen er generalsekretÃ¦ren i speiderforbundet.</p>\n<p>Speidere kan selv logge inn og se og endre sin medlemsprofil pÃ¥ <a href=\"https://min.speiding.no\">min.speiding.no</a>.</p>\n<p>Speiderforbundet behandler ogsÃ¥ opplysniger om politiattest for ledere og andre frivillige.\nDenne behandlingen er hjemlet i politiregisterforskriften Â§34-1.</p>\n<h2 id=\"informasjonskapsler-pÃ¥-naddderudno\">Informasjonskapsler pÃ¥ naddderud.no</h2>\n<p>Informasjonskapsler er smÃ¥ tekstfiler som lagres pÃ¥ din datamaskin/enhet nÃ¥r du besÃ¸ker nettsider.\nVi bruker disse filene til Ã¥ lage besÃ¸ksstatistikk med Google Analytics for nettsidene vÃ¥re. Google\nbruker informasjonskapselen â€<code>_ga</code>â€ til Ã¥ spore hvilke sider du besÃ¸ker og hvor lenge du\ner inne pÃ¥ hver side. Denne informasjonen bruker vi til Ã¥ lage bedre nettsider for deg og andre.</p>\n<p>IP-adressen din blir alltid anonymisert fÃ¸r den deles med Google. Du kan selv <a href=\"https://nettvett.no/slik-administrer-du-informasjonskapsler/\">slette og endre\ninnstilliger for informasjonskapsler</a>\ni nettleseren din.</p>\n<h2 id=\"kontaktinformasjon\">Kontaktinformasjon</h2>\n<p>Henvendelser og spÃ¸rsmÃ¥l om personvern og personopplysninger kan sendes til\n<a href=\"mailto:post@nadderud.no\">post@nadderud.no</a>.</p>");

				const frontmatter$y = {"layout":"../layouts/MarkdownPageLayout.astro","date":"2020-03-22T11:04:00.000Z","title":"Personvern","description":"PersonvernerklÃ¦ring som beskriver hvordan vi behandler dine personopplysninger."};
				const file$y = "/home/martin/Documents/GitHub/mason/src/pages/personvern.md";
				const url$y = "/personvern";
				function rawContent$y() {
					return "\n## Generelt\n\nDe fleste organisasjoner og virksomheter som samler inn og bruker opplysninger om enkeltpersoner\nmÃ¥ fÃ¸lge personopplysningsloven. Dette gjelder ogsÃ¥ Nadderud speidergruppe. I dette dokumentet\nbeskriver vi hvordan og hvorfor vi bruker personopplysninger, og hvilke rettigheter du har\ndersom vi behandler opplysninger om deg.\n\nGruppelederen er ansvarlig for behandling av personopplysninger i Nadderud speidergruppe.\n\nVi bruker kontaktopplysninger om speiderne og foresatte til Ã¥:\n\n- sende ut informasjon om aktiviteter og annen relevant informasjon pÃ¥ e-post eller SMS\n- registrere pÃ¥melding til turer og andre arrangementer\n- kontakte enkeltmedlemmer om medlemskapet, betaling e.l.\n- rekruttere frivillige ledere og hjelpere til aktiviteter\n\nI tillegg bruker vi opplysninger om diett og andre relevante opplysninger som er nÃ¸dvendig\nfor Ã¥ tilrettelegge matservering og beredskap for speidere med sÃ¦rlige behov. Slike opplysninger\nsamles inn ved pÃ¥melding (helseskjema) til konkrete arrangementer og slettes etter at\narrangementet er gjennomfÃ¸rt.\n\nVi vil bare ta imot og bruke helseopplysninger som vi fÃ¥r direkte fra speideren eller foresatte.\nVi ber om at dere ikke sender oss sensitive opplysninger pÃ¥ e-post.\n\nVi ber ogsÃ¥ om samtykke til Ã¥ ta og dele bilder og video av speidere som deltar pÃ¥ aktivitetene\nvÃ¥re pÃ¥ internett og sosiale medier. Samtykket innhentes i pÃ¥meldingsskjemaet, men alle speidere\nkan selv gi og trekke samtykket i medlemsprofilen pÃ¥ [min.speiding.no](https://min.speiding.no).\n\n## Medlemskap\n\nNadderud speidergruppe er en del av Norges speiderforbund. Personopplysninger om\nmedlemskapet ditt blir behandlet etter [Norges speiderforbunds personvernerklÃ¦ring](https://speiding.no/personvernserklaering).\nGrunnlaget for denne behandlingen er avtalen om medlemskap i Norges speiderforbund og ansvarlig\nfor behandlingen er generalsekretÃ¦ren i speiderforbundet.\n\nSpeidere kan selv logge inn og se og endre sin medlemsprofil pÃ¥ [min.speiding.no](https://min.speiding.no).\n\nSpeiderforbundet behandler ogsÃ¥ opplysniger om politiattest for ledere og andre frivillige.\nDenne behandlingen er hjemlet i politiregisterforskriften Â§34-1.\n\n## Informasjonskapsler pÃ¥ naddderud.no\n\nInformasjonskapsler er smÃ¥ tekstfiler som lagres pÃ¥ din datamaskin/enhet nÃ¥r du besÃ¸ker nettsider.\nVi bruker disse filene til Ã¥ lage besÃ¸ksstatistikk med Google Analytics for nettsidene vÃ¥re. Google\nbruker informasjonskapselen \"<code>\\_ga</code>\" til Ã¥ spore hvilke sider du besÃ¸ker og hvor lenge du\ner inne pÃ¥ hver side. Denne informasjonen bruker vi til Ã¥ lage bedre nettsider for deg og andre.\n\nIP-adressen din blir alltid anonymisert fÃ¸r den deles med Google. Du kan selv [slette og endre\ninnstilliger for informasjonskapsler](https://nettvett.no/slik-administrer-du-informasjonskapsler/)\ni nettleseren din.\n\n## Kontaktinformasjon\n\nHenvendelser og spÃ¸rsmÃ¥l om personvern og personopplysninger kan sendes til\n[post@nadderud.no](mailto:post@nadderud.no).\n";
				}
				function compiledContent$y() {
					return html$y;
				}
				function getHeadings$y() {
					return [{"depth":2,"slug":"generelt","text":"Generelt"},{"depth":2,"slug":"medlemskap","text":"Medlemskap"},{"depth":2,"slug":"informasjonskapsler-pÃ¥-naddderudno","text":"Informasjonskapsler pÃ¥ naddderud.no"},{"depth":2,"slug":"kontaktinformasjon","text":"Kontaktinformasjon"}];
				}
				async function Content$y() {
					const { layout, ...content } = frontmatter$y;
					content.file = file$y;
					content.url = url$y;
					const contentFragment = createVNode(Fragment, { 'set:html': html$y });
					return createVNode($$MarkdownPageLayout, {
									file: file$y,
									url: url$y,
									content,
									frontmatter: content,
									headings: getHeadings$y(),
									rawContent: rawContent$y,
									compiledContent: compiledContent$y,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$y[Symbol.for('astro.needsHeadRendering')] = false;

const _page2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$y,
  compiledContent: compiledContent$y,
  default: Content$y,
  file: file$y,
  frontmatter: frontmatter$y,
  getHeadings: getHeadings$y,
  images: images$y,
  rawContent: rawContent$y,
  url: url$y
}, Symbol.toStringTag, { value: 'Module' }));

const $$Astro$5 = createAstro("https://nadderud.no");
const $$ArticleLayout = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$5, $$props, $$slots);
  Astro2.self = $$ArticleLayout;
  const { frontmatter } = Astro2.props;
  return renderTemplate`${renderComponent($$result, "PageLayout", $$PageLayout, { "meta": { title: frontmatter.title, description: frontmatter.description, image: frontmatter.featuredimage } }, { "default": ($$result2) => renderTemplate`${renderComponent($$result2, "Hero", $$Hero, { "image": frontmatter.featuredimage, "title": frontmatter.title })}${maybeRenderHead($$result2)}<article class="prose max-w-2xl mx-auto p-4">
    ${renderSlot($$result2, $$slots["default"])}
  </article>` })}`;
}, "/home/martin/Documents/GitHub/mason/src/layouts/ArticleLayout.astro");

const images$x = {
					
				};

				function updateImageReferences$x(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$x[imagePath].src, ...images$x[imagePath].attributes})
					);
				}

				const html$x = updateImageReferences$x("<p>Troppen og de fleste patruljene har laget sin terminliste som ligger under program og patrulje. Rev sin terminliste vil bli lagt ut sÃ¸ndag kveld. Vi har valgt Ã¥ fjerne en tur for Ã¥ gjÃ¸re plass til patruljetur, vi oppforder alle til Ã¥ bli med pÃ¥ troppsturer og patruljeturer. Dugnad pÃ¥ Mason Hill er satt til 18 April, og vi hÃ¥per sÃ¥ mange som mulig har mulighet til Ã¥ bli med opp Ã¥ hjelpe til pÃ¥ hytta da.</p>\n<p>I tillegg til det som skjer i troppen, har speidergruppa behov for ekstra innsats fra noen foreldre (foreldrerÃ¥d) for blant annet Ã¥ organisere dugnader. Dugnadsarbeidet har sÃ¸rget for ca halvparten av gruppens inntekter, hvis dette faller bort mÃ¥ kontingenten Ã¸kes tilsvarende, noe vi ikke Ã¸nsker. Ta kontakt med Mats: <a href=\"mailto:mats@nadderud.no\">mats@nadderud.no</a> dersom du Ã¸nsker Ã¥ bistÃ¥.</p>\n<p>Det er ogsÃ¥ sendt ut forhÃ¥ndspÃ¥melding til sommerleir, vi hÃ¥per sÃ¥ mange som mulig har mulighet til Ã¥ bli med!</p>");

				const frontmatter$x = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Velkommen til et nytt speidersemester og godt nytt Ã¥r!","date":"2020-01-16T21:31:20.623Z","description":"NÃ¥ gleder vi oss til Ã¥ ta fÃ¥tt pÃ¥ ett nytt speidersemester! ","featuredimage":"/img/upload/bÃ¥l.jpeg","expireInDays":60,"tags":["troppen"]};
				const file$x = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-01-16-velkommen-til-et-nytt-speidersemester-og-godt-nytt-Ã¥r.md";
				const url$x = "/artikler/2020-01-16-velkommen-til-et-nytt-speidersemester-og-godt-nytt-Ã¥r";
				function rawContent$x() {
					return "\nTroppen og de fleste patruljene har laget sin terminliste som ligger under program og patrulje. Rev sin terminliste vil bli lagt ut sÃ¸ndag kveld. Vi har valgt Ã¥ fjerne en tur for Ã¥ gjÃ¸re plass til patruljetur, vi oppforder alle til Ã¥ bli med pÃ¥ troppsturer og patruljeturer. Dugnad pÃ¥ Mason Hill er satt til 18 April, og vi hÃ¥per sÃ¥ mange som mulig har mulighet til Ã¥ bli med opp Ã¥ hjelpe til pÃ¥ hytta da.\n\nI tillegg til det som skjer i troppen, har speidergruppa behov for ekstra innsats fra noen foreldre (foreldrerÃ¥d) for blant annet Ã¥ organisere dugnader. Dugnadsarbeidet har sÃ¸rget for ca halvparten av gruppens inntekter, hvis dette faller bort mÃ¥ kontingenten Ã¸kes tilsvarende, noe vi ikke Ã¸nsker. Ta kontakt med Mats: mats@nadderud.no dersom du Ã¸nsker Ã¥ bistÃ¥.\n\nDet er ogsÃ¥ sendt ut forhÃ¥ndspÃ¥melding til sommerleir, vi hÃ¥per sÃ¥ mange som mulig har mulighet til Ã¥ bli med!\n";
				}
				function compiledContent$x() {
					return html$x;
				}
				function getHeadings$x() {
					return [];
				}
				async function Content$x() {
					const { layout, ...content } = frontmatter$x;
					content.file = file$x;
					content.url = url$x;
					const contentFragment = createVNode(Fragment, { 'set:html': html$x });
					return createVNode($$ArticleLayout, {
									file: file$x,
									url: url$x,
									content,
									frontmatter: content,
									headings: getHeadings$x(),
									rawContent: rawContent$x,
									compiledContent: compiledContent$x,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$x[Symbol.for('astro.needsHeadRendering')] = false;

const _page3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$x,
  compiledContent: compiledContent$x,
  default: Content$x,
  file: file$x,
  frontmatter: frontmatter$x,
  getHeadings: getHeadings$x,
  images: images$x,
  rawContent: rawContent$x,
  url: url$x
}, Symbol.toStringTag, { value: 'Module' }));

const images$w = {
					
				};

				function updateImageReferences$w(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$w[imagePath].src, ...images$w[imagePath].attributes})
					);
				}

				const html$w = updateImageReferences$w("<p>Alle troppsmÃ¸ter vil vare fra kl. 18.00 til kl. 19.30. De er satt til fÃ¸rste mandagen i hver mÃ¥ned, og bestÃ¥r av opplegg for alle patruljene i troppen. De resterende mandagene er holdt av til patruljemÃ¸ter. Disse varer i Ã©n time, og er fra kl. 18.00-19.00. I starten av hÃ¸sten vil vi prÃ¸ve Ã¥ avholde alle mÃ¸ter utendÃ¸rs. MÃ¸tene vil vÃ¦re pÃ¥ speiderhuset i Ã˜ygardveien 49 eller et annet sted i nÃ¦romrÃ¥det. Det betyr at det er viktig Ã¥ fÃ¸lge med i terminlisten hvor troppen/patruljen skal vÃ¦re og ta pÃ¥ riktig klÃ¦r.<br>\n<br>\nI tillegg til tropps- og patruljemÃ¸ter skal vi selvfÃ¸lgelig pÃ¥ tur denne hÃ¸sten! Det arrangeres to turer for hele troppen, Ã©n tur for patruljefÃ¸rere og assistenter, og patruljetur for hver patrulje. FÃ¸lg med pÃ¥ terminlisten og hold av datoer. De fleste speiderne syns turene er det morsomste med speideren, sÃ¥ vi oppfordrer alle til Ã¥ bli med pÃ¥ tur!<br>\n<br>\nAlle peffer og asser skal i tillegg mÃ¸te til planlegging av patruljenes terminlister mandag 24. august pÃ¥ speiderhuset kl. 18.00, vi er ferdige ca kl. 20.00. Det blir sendt egen mail til peffer og asser om dette.<br>\n<br>\nTa kontakt hvis noen lurer pÃ¥ noe (<a href=\"mailto:martincclementz@gmail.com\">martincclementz@gmail.com</a>).</p>\n<p>Dersom du har meldt deg ut av speideren, men fortsatt mottar mail fra oss beklager vi det. Da har vi dessverre ikke fÃ¥tt registrert at du har sluttet og vi vil da sette stor pris pÃ¥ om du sender oss en mail sÃ¥ fort som mulig om at vi skal fjerne deg fra medlemslistene.<br>\n<br>\nMail med utmelding kan sendes til <a href=\"mailto:mbhaukedal@gmail.com\">mbhaukedal@gmail.com</a><br>\n<br>\nVi gleder oss til Ã¥ komme i gang!<br>\n<br>\nHilsen lederne</p>");

				const frontmatter$w = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Oppstart for troppen, KanomÃ¸te pÃ¥ Bogstadvannet, 7 sept","featuredimage":"/img/upload/happy-day.jpg","description":"Da var sommeren over og et nytt speiderÃ¥r rett rundt hjÃ¸rnet!\n\nTroppens fÃ¸rste mÃ¸te (de som starter i 5-10 kl) er pÃ¥ Bogstadvannet den 7.september.","date":"2020-08-12T15:16:26.759Z","expireInDays":60,"tags":["-"]};
				const file$w = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-08-12-oppstart-for-troppen-kanomÃ¸te-pÃ¥-bogstadvannet-7-sept.md";
				const url$w = "/artikler/2020-08-12-oppstart-for-troppen-kanomÃ¸te-pÃ¥-bogstadvannet-7-sept";
				function rawContent$w() {
					return "\nAlle troppsmÃ¸ter vil vare fra kl. 18.00 til kl. 19.30. De er satt til fÃ¸rste mandagen i hver mÃ¥ned, og bestÃ¥r av opplegg for alle patruljene i troppen. De resterende mandagene er holdt av til patruljemÃ¸ter. Disse varer i Ã©n time, og er fra kl. 18.00-19.00. I starten av hÃ¸sten vil vi prÃ¸ve Ã¥ avholde alle mÃ¸ter utendÃ¸rs. MÃ¸tene vil vÃ¦re pÃ¥ speiderhuset i Ã˜ygardveien 49 eller et annet sted i nÃ¦romrÃ¥det. Det betyr at det er viktig Ã¥ fÃ¸lge med i terminlisten hvor troppen/patruljen skal vÃ¦re og ta pÃ¥ riktig klÃ¦r.\\\n\\\nI tillegg til tropps- og patruljemÃ¸ter skal vi selvfÃ¸lgelig pÃ¥ tur denne hÃ¸sten! Det arrangeres to turer for hele troppen, Ã©n tur for patruljefÃ¸rere og assistenter, og patruljetur for hver patrulje. FÃ¸lg med pÃ¥ terminlisten og hold av datoer. De fleste speiderne syns turene er det morsomste med speideren, sÃ¥ vi oppfordrer alle til Ã¥ bli med pÃ¥ tur!\\\n\\\nAlle peffer og asser skal i tillegg mÃ¸te til planlegging av patruljenes terminlister mandag 24. august pÃ¥ speiderhuset kl. 18.00, vi er ferdige ca kl. 20.00. Det blir sendt egen mail til peffer og asser om dette.\\\n\\\nTa kontakt hvis noen lurer pÃ¥ noe ([martincclementz@gmail.com](mailto:martincclementz@gmail.com)).\n\nDersom du har meldt deg ut av speideren, men fortsatt mottar mail fra oss beklager vi det. Da har vi dessverre ikke fÃ¥tt registrert at du har sluttet og vi vil da sette stor pris pÃ¥ om du sender oss en mail sÃ¥ fort som mulig om at vi skal fjerne deg fra medlemslistene.\\\n\\\nMail med utmelding kan sendes til [mbhaukedal@gmail.com](mailto:mbhaukedal@gmail.com)\\\n\\\nVi gleder oss til Ã¥ komme i gang!\\\n\\\nHilsen lederne\n";
				}
				function compiledContent$w() {
					return html$w;
				}
				function getHeadings$w() {
					return [];
				}
				async function Content$w() {
					const { layout, ...content } = frontmatter$w;
					content.file = file$w;
					content.url = url$w;
					const contentFragment = createVNode(Fragment, { 'set:html': html$w });
					return createVNode($$ArticleLayout, {
									file: file$w,
									url: url$w,
									content,
									frontmatter: content,
									headings: getHeadings$w(),
									rawContent: rawContent$w,
									compiledContent: compiledContent$w,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$w[Symbol.for('astro.needsHeadRendering')] = false;

const _page4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$w,
  compiledContent: compiledContent$w,
  default: Content$w,
  file: file$w,
  frontmatter: frontmatter$w,
  getHeadings: getHeadings$w,
  images: images$w,
  rawContent: rawContent$w,
  url: url$w
}, Symbol.toStringTag, { value: 'Module' }));

const images$v = {
					
				};

				function updateImageReferences$v(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$v[imagePath].src, ...images$v[imagePath].attributes})
					);
				}

				const html$v = updateImageReferences$v("<p>Det blir nissegrÃ¸t, leker, moro, og kanskje noen overraskelser. <em>Vi oppfordrer alle til Ã¥ kle seg ut som nisser.</em> Det blir premie for beste kostyme. Ta med din egen tallerken, skje og kopp.</p>\n<p><em><strong>OBS! Vi skal vÃ¦re ute - sÃ¥ husk varme klÃ¦r under nissedrakta!</strong></em></p>\n<p>Vi trenger hjelp av 3 foreldre som kan koke grÃ¸t til festen, og gjerne vÃ¦re med og servere speiderne. Gi beskjed til <a href=\"mailto:mats@nadderud.no\">mailto:mats@nadderud.no</a> sÃ¥ fort som mulig hvis du kan bidra. (Uten hjelp blir det ingen nissegrÃ¸t.)</p>\n<p>Vel mÃ¸tt!</p>\n<p>Speiderhilsen lederne og foreldrerÃ¥det</p>");

				const frontmatter$v = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Nissefest pÃ¥ speiderhuset mandag 16. desember","date":"2019-12-01T18:51:04.465Z","description":"Nettene er blitt lange, og kulda har satt inn. Siste speidermÃ¸te fÃ¸r jul er vÃ¥r tradisjonsrike nissefest. Denne blir pÃ¥ baksiden av speiderhuset mandag 16. desember klokka 18.00 til 19.00. Alle er velkommen - bÃ¥de store og smÃ¥!","featuredimage":"/img/upload/nisser.jpg","expireInDays":60,"tags":["troppen","flokken"]};
				const file$v = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2019-12-01-nissefest-pÃ¥-speiderhuset-mandag-16-desember.md";
				const url$v = "/artikler/2019-12-01-nissefest-pÃ¥-speiderhuset-mandag-16-desember";
				function rawContent$v() {
					return "\nDet blir nissegrÃ¸t, leker, moro, og kanskje noen overraskelser. _Vi oppfordrer alle til Ã¥ kle seg ut som nisser._ Det blir premie for beste kostyme. Ta med din egen tallerken, skje og kopp.\n\n_**OBS! Vi skal vÃ¦re ute - sÃ¥ husk varme klÃ¦r under nissedrakta!**_\n\nVi trenger hjelp av 3 foreldre som kan koke grÃ¸t til festen, og gjerne vÃ¦re med og servere speiderne. Gi beskjed til <mailto:mats@nadderud.no> sÃ¥ fort som mulig hvis du kan bidra. (Uten hjelp blir det ingen nissegrÃ¸t.)\n\nVel mÃ¸tt!\n\nSpeiderhilsen lederne og foreldrerÃ¥det\n";
				}
				function compiledContent$v() {
					return html$v;
				}
				function getHeadings$v() {
					return [];
				}
				async function Content$v() {
					const { layout, ...content } = frontmatter$v;
					content.file = file$v;
					content.url = url$v;
					const contentFragment = createVNode(Fragment, { 'set:html': html$v });
					return createVNode($$ArticleLayout, {
									file: file$v,
									url: url$v,
									content,
									frontmatter: content,
									headings: getHeadings$v(),
									rawContent: rawContent$v,
									compiledContent: compiledContent$v,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$v[Symbol.for('astro.needsHeadRendering')] = false;

const _page5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$v,
  compiledContent: compiledContent$v,
  default: Content$v,
  file: file$v,
  frontmatter: frontmatter$v,
  getHeadings: getHeadings$v,
  images: images$v,
  rawContent: rawContent$v,
  url: url$v
}, Symbol.toStringTag, { value: 'Module' }));

const images$u = {
					
				};

				function updateImageReferences$u(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$u[imagePath].src, ...images$u[imagePath].attributes})
					);
				}

				const html$u = updateImageReferences$u("<p>Speiderne mÃ¸ter der det stÃ¥r pÃ¥ terminlista, Ekorn mÃ¸ter pÃ¥ Hosle skole. De fleste mÃ¸tene vil bli gjennomfÃ¸rt med planlagt program, mens noen vil det bli laget alternativt program for.</p>\n<p><br>\nDet er viktig at alle speiderne fÃ¸lger rÃ¥d om smittevern, peff/ass vil ha med antibac til alle i patrulja.</p>\n<p><br>\nDe som skal ha strandrydding mÃ¥ ta med plashandsker og sÃ¸ppelpose. Fint om speiderne tar med sÃ¸ppelet hjem og kaster det sÃ¥ vi ikke overbelaster sÃ¸ppelbÃ¸tter pÃ¥ strendene.</p>");

				const frontmatter$u = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Troppen starter opp igjen med patruljemÃ¸ter!","featuredimage":"/img/upload/happy-day.jpg","description":"Neste uke starter troppen opp igjen med patruljemÃ¸ter, alle mÃ¸tene vil bli gjennomfÃ¸rt utendÃ¸rs.","date":"2020-05-05T19:43:41.955Z","expireInDays":60,"tags":["-"]};
				const file$u = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-05-05-troppen-starter-opp-igjen-med-patruljemÃ¸ter.md";
				const url$u = "/artikler/2020-05-05-troppen-starter-opp-igjen-med-patruljemÃ¸ter";
				function rawContent$u() {
					return "\nSpeiderne mÃ¸ter der det stÃ¥r pÃ¥ terminlista, Ekorn mÃ¸ter pÃ¥ Hosle skole. De fleste mÃ¸tene vil bli gjennomfÃ¸rt med planlagt program, mens noen vil det bli laget alternativt program for.\n\n\\\nDet er viktig at alle speiderne fÃ¸lger rÃ¥d om smittevern, peff/ass vil ha med antibac til alle i patrulja.\n\n\\\nDe som skal ha strandrydding mÃ¥ ta med plashandsker og sÃ¸ppelpose. Fint om speiderne tar med sÃ¸ppelet hjem og kaster det sÃ¥ vi ikke overbelaster sÃ¸ppelbÃ¸tter pÃ¥ strendene.\n";
				}
				function compiledContent$u() {
					return html$u;
				}
				function getHeadings$u() {
					return [];
				}
				async function Content$u() {
					const { layout, ...content } = frontmatter$u;
					content.file = file$u;
					content.url = url$u;
					const contentFragment = createVNode(Fragment, { 'set:html': html$u });
					return createVNode($$ArticleLayout, {
									file: file$u,
									url: url$u,
									content,
									frontmatter: content,
									headings: getHeadings$u(),
									rawContent: rawContent$u,
									compiledContent: compiledContent$u,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$u[Symbol.for('astro.needsHeadRendering')] = false;

const _page6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$u,
  compiledContent: compiledContent$u,
  default: Content$u,
  file: file$u,
  frontmatter: frontmatter$u,
  getHeadings: getHeadings$u,
  images: images$u,
  rawContent: rawContent$u,
  url: url$u
}, Symbol.toStringTag, { value: 'Module' }));

const images$t = {
					
				};

				function updateImageReferences$t(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$t[imagePath].src, ...images$t[imagePath].attributes})
					);
				}

				const html$t = updateImageReferences$t("<p>Det var en gang for lenge siden hvor BjÃ¸rn mÃ¥tte pÃ¥ en Quest for Ã¥ redde prinsessa, resten er hitorie</p>");

				const frontmatter$t = {"layout":"../../layouts/ArticleLayout.astro","title":"The conquest of the Lord & Saviour BjÃ¸rn ","featuredimage":"/img/upload/20190403_221359000_ios.jpg","description":"BjÃ¸rn pÃ¥ sin reise, du kan tenke deg hvordan dette skjeddeðŸ¤·","date":"2023-04-03T07:13:41+02:00","expireInDays":60,"tags":["What is this"]};
				const file$t = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2023-04-03-the-conquest-of-the-lord-saviour-bjÃ¸rn.md";
				const url$t = "/artikler/2023-04-03-the-conquest-of-the-lord-saviour-bjÃ¸rn";
				function rawContent$t() {
					return "Det var en gang for lenge siden hvor BjÃ¸rn mÃ¥tte pÃ¥ en Quest for Ã¥ redde prinsessa, resten er hitorie\n";
				}
				function compiledContent$t() {
					return html$t;
				}
				function getHeadings$t() {
					return [];
				}
				async function Content$t() {
					const { layout, ...content } = frontmatter$t;
					content.file = file$t;
					content.url = url$t;
					const contentFragment = createVNode(Fragment, { 'set:html': html$t });
					return createVNode($$ArticleLayout, {
									file: file$t,
									url: url$t,
									content,
									frontmatter: content,
									headings: getHeadings$t(),
									rawContent: rawContent$t,
									compiledContent: compiledContent$t,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$t[Symbol.for('astro.needsHeadRendering')] = false;

const _page7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$t,
  compiledContent: compiledContent$t,
  default: Content$t,
  file: file$t,
  frontmatter: frontmatter$t,
  getHeadings: getHeadings$t,
  images: images$t,
  rawContent: rawContent$t,
  url: url$t
}, Symbol.toStringTag, { value: 'Module' }));

const images$s = {
					
				};

				function updateImageReferences$s(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$s[imagePath].src, ...images$s[imagePath].attributes})
					);
				}

				const html$s = updateImageReferences$s("<p>Alle planlagte mÃ¸ter og turer er avlyst inntil helsemyndighetene opphever vedtaket om forbud mot kultur- og idrettsarrangementer. Dette er innfÃ¸rt som et tiltak for Ã¥ begrense spredning av koronavirus i Norge.</p>\n<p>BÃ¥de <a href=\"https://speiding.no/nyhetsarkiv/viktig-informasjon\">Norges speiderforbund</a> og <a href=\"https://vestmarka.speiding.no/anbefaling-rundt-speiding-og-korona/\">Vestmarka krets</a> har i dag gÃ¥tt ut med informasjon om at planlagte fysiske arrangementer avlyses og oppfordret gruppene til Ã¥ gjÃ¸re det samme. Oppfordringen fra speiderforbundet gjelder alle fysiske samlinger til og med 30. april.</p>\n<p>Patruljene kan pÃ¥ eget initiativ gjennomfÃ¸re patruljemÃ¸ter pÃ¥ internett, f.eks. pÃ¥ skype, hangouts e.l.</p>\n<p>NÃ¥r det gjelder Ã¥rsmÃ¸te, sommerleir og andre arrangementer fremover i tid, vil vi komme tilbake med mer informasjon etter pÃ¥ske.</p>\n<p>Vi ber alle speidere Ã¥ ta den krevende situasjonen pÃ¥ alvor og gjÃ¸re det vi kan for Ã¥ ta vare pÃ¥ hverandre og hjelpe andre.</p>");

				const frontmatter$s = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Avlysninger knyttet til koronaviruset","featuredimage":"/img/upload/hvitsteinvann.jpg","description":"PÃ¥ bakgrunn av helsemyndighetenes tiltak for Ã¥ begrense smitte avlyses alle aktiviteter i Nadderud speidergruppe med umiddelbar virkning.","date":"2020-03-12T16:47:00.899Z","expireInDays":60,"tags":["troppen flokken"]};
				const file$s = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-03-12-avlysninger-knyttet-til-koronaviruset.md";
				const url$s = "/artikler/2020-03-12-avlysninger-knyttet-til-koronaviruset";
				function rawContent$s() {
					return "\nAlle planlagte mÃ¸ter og turer er avlyst inntil helsemyndighetene opphever vedtaket om forbud mot kultur- og idrettsarrangementer. Dette er innfÃ¸rt som et tiltak for Ã¥ begrense spredning av koronavirus i Norge.\n\nBÃ¥de [Norges speiderforbund](https://speiding.no/nyhetsarkiv/viktig-informasjon) og [Vestmarka krets](https://vestmarka.speiding.no/anbefaling-rundt-speiding-og-korona/) har i dag gÃ¥tt ut med informasjon om at planlagte fysiske arrangementer avlyses og oppfordret gruppene til Ã¥ gjÃ¸re det samme. Oppfordringen fra speiderforbundet gjelder alle fysiske samlinger til og med 30. april.\n\nPatruljene kan pÃ¥ eget initiativ gjennomfÃ¸re patruljemÃ¸ter pÃ¥ internett, f.eks. pÃ¥ skype, hangouts e.l.\n\nNÃ¥r det gjelder Ã¥rsmÃ¸te, sommerleir og andre arrangementer fremover i tid, vil vi komme tilbake med mer informasjon etter pÃ¥ske.\n\nVi ber alle speidere Ã¥ ta den krevende situasjonen pÃ¥ alvor og gjÃ¸re det vi kan for Ã¥ ta vare pÃ¥ hverandre og hjelpe andre.\n";
				}
				function compiledContent$s() {
					return html$s;
				}
				function getHeadings$s() {
					return [];
				}
				async function Content$s() {
					const { layout, ...content } = frontmatter$s;
					content.file = file$s;
					content.url = url$s;
					const contentFragment = createVNode(Fragment, { 'set:html': html$s });
					return createVNode($$ArticleLayout, {
									file: file$s,
									url: url$s,
									content,
									frontmatter: content,
									headings: getHeadings$s(),
									rawContent: rawContent$s,
									compiledContent: compiledContent$s,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$s[Symbol.for('astro.needsHeadRendering')] = false;

const _page8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$s,
  compiledContent: compiledContent$s,
  default: Content$s,
  file: file$s,
  frontmatter: frontmatter$s,
  getHeadings: getHeadings$s,
  images: images$s,
  rawContent: rawContent$s,
  url: url$s
}, Symbol.toStringTag, { value: 'Module' }));

const images$r = {
					
				};

				function updateImageReferences$r(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$r[imagePath].src, ...images$r[imagePath].attributes})
					);
				}

				const html$r = updateImageReferences$r("<p>Vi skal vÃ¦re ute. Parallelt med at speiderne har mÃ¸te, holder vi et kort foreldremÃ¸te der gruppeleder Merete Haukedal og en av flokklederne informerer om arbeidet i flokken. Det er fint om iallfall de nye foreldrene har anledning til Ã¥ vÃ¦re med pÃ¥ dette. Av smittevernhensyn ber vi om at det bare kommer Ã©n forelder per speider, og at de som kommer, melder seg pÃ¥ ved Ã¥ sende e-post til <a href=\"mailto:yngve.hagvar@gmail.com\">yngve.hagvar@gmail.com</a>. Speiderhuset ligger i samme bygg som Nadderudskogen barnehage i <a href=\"https://goo.gl/maps/jHbkfZtu8mDxiyXy8\">Ã˜ygardveien 49</a>.</p>\n<p>Vi er for tiden tre fedre fra fjerde klasse som leder flokken, og per i dag er det registrert 17 speidere fra tredje og fjerde klasse. Vi hÃ¥per vi kan fÃ¥ med en forelder eller to til, gjerne fra tredje klasse, og gjerne mÃ¸dre. Speidererfaring er en fordel, men ikke noe krav. Dette kan vi prate om pÃ¥ mÃ¸tet. Vi Ã¸nsker oss ogsÃ¥ flere jenter i flokken, sÃ¥ hvis noen av barna har en venninne som er interessert, er det bare Ã¥ bli med.</p>\n<p>MÃ¸tene vil bli hver tirsdag fra 18.00 til ca. 19.15. Noen ganger mÃ¸tes vi andre steder enn speiderhuset, for eksempel for Ã¥ padle kano eller tenne bÃ¥l i skogen. FÃ¸lg med i kalenderen har pÃ¥ hjemmesida.</p>\n<p>Vi mÃ¥ ta noen spesielle hensyn utover hÃ¸sten pÃ¥ grunn av covid-19. <a href=\"https://speiding.no/nyhetsarkiv/rad-og-tips-til-fysiske-og-digitale-speideraktiviteter-fra-norges-speiderforbund-0\">Norges speiderforbund fÃ¸lger FHIs smittevernregler</a>. Det betyr i praksis at speiderne skal holde en meters avstand pÃ¥ mÃ¸tene og ikke dele utstyr. Vi kommer ogsÃ¥ til Ã¥ ha alle mÃ¸ter utendÃ¸rs. Hvis vi blir sÃ¥ mange at summen av speidere og ledere overstiger 20 pÃ¥ mÃ¸tene, deler vi flokken i to med hver sine mÃ¸ter. PÃ¥ det fÃ¸rste mÃ¸tet vil speidermÃ¸tet og foreldremÃ¸tet foregÃ¥ pÃ¥ hver sin side av huset, sÃ¥ vi regner det som to atskilte mÃ¸ter.</p>\n<p>Har dere noen spÃ¸rsmÃ¥l, kan dere gjerne kontakte en av flokklederne:</p>\n<p>Yngve Benestad HÃ¥gvar, 416 43 901</p>\n<p>Tom Langford, 478 95 755</p>\n<p>Richard LitsÃ©n, 980 73 426</p>");

				const frontmatter$r = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Flokken starter opp tirsdag 25. august","featuredimage":"/img/upload/spikking.jpg","description":"Tirsdag 25. august starter vi opp med speidermÃ¸ter for tredje- og fjerdeklassingene. Det fÃ¸rste mÃ¸tet blir fra 18.00 til 19.15 pÃ¥ speiderhuset.","date":"2020-08-17T08:04:40.307Z","expireInDays":60,"tags":["Flokk"]};
				const file$r = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-08-17-flokken-starter-opp-tirsdag-25-august.md";
				const url$r = "/artikler/2020-08-17-flokken-starter-opp-tirsdag-25-august";
				function rawContent$r() {
					return "\nVi skal vÃ¦re ute. Parallelt med at speiderne har mÃ¸te, holder vi et kort foreldremÃ¸te der gruppeleder Merete Haukedal og en av flokklederne informerer om arbeidet i flokken. Det er fint om iallfall de nye foreldrene har anledning til Ã¥ vÃ¦re med pÃ¥ dette. Av smittevernhensyn ber vi om at det bare kommer Ã©n forelder per speider, og at de som kommer, melder seg pÃ¥ ved Ã¥ sende e-post til yngve.hagvar@gmail.com. Speiderhuset ligger i samme bygg som Nadderudskogen barnehage i [Ã˜ygardveien 49](https://goo.gl/maps/jHbkfZtu8mDxiyXy8).\n\nVi er for tiden tre fedre fra fjerde klasse som leder flokken, og per i dag er det registrert 17 speidere fra tredje og fjerde klasse. Vi hÃ¥per vi kan fÃ¥ med en forelder eller to til, gjerne fra tredje klasse, og gjerne mÃ¸dre. Speidererfaring er en fordel, men ikke noe krav. Dette kan vi prate om pÃ¥ mÃ¸tet. Vi Ã¸nsker oss ogsÃ¥ flere jenter i flokken, sÃ¥ hvis noen av barna har en venninne som er interessert, er det bare Ã¥ bli med.\n\nMÃ¸tene vil bli hver tirsdag fra 18.00 til ca. 19.15. Noen ganger mÃ¸tes vi andre steder enn speiderhuset, for eksempel for Ã¥ padle kano eller tenne bÃ¥l i skogen. FÃ¸lg med i kalenderen har pÃ¥ hjemmesida.\n\nVi mÃ¥ ta noen spesielle hensyn utover hÃ¸sten pÃ¥ grunn av covid-19. [Norges speiderforbund fÃ¸lger FHIs smittevernregler](https://speiding.no/nyhetsarkiv/rad-og-tips-til-fysiske-og-digitale-speideraktiviteter-fra-norges-speiderforbund-0). Det betyr i praksis at speiderne skal holde en meters avstand pÃ¥ mÃ¸tene og ikke dele utstyr. Vi kommer ogsÃ¥ til Ã¥ ha alle mÃ¸ter utendÃ¸rs. Hvis vi blir sÃ¥ mange at summen av speidere og ledere overstiger 20 pÃ¥ mÃ¸tene, deler vi flokken i to med hver sine mÃ¸ter. PÃ¥ det fÃ¸rste mÃ¸tet vil speidermÃ¸tet og foreldremÃ¸tet foregÃ¥ pÃ¥ hver sin side av huset, sÃ¥ vi regner det som to atskilte mÃ¸ter.\n\nHar dere noen spÃ¸rsmÃ¥l, kan dere gjerne kontakte en av flokklederne:\n\nYngve Benestad HÃ¥gvar, 416 43 901\n\nTom Langford, 478 95 755\n\nRichard LitsÃ©n, 980 73 426\n";
				}
				function compiledContent$r() {
					return html$r;
				}
				function getHeadings$r() {
					return [];
				}
				async function Content$r() {
					const { layout, ...content } = frontmatter$r;
					content.file = file$r;
					content.url = url$r;
					const contentFragment = createVNode(Fragment, { 'set:html': html$r });
					return createVNode($$ArticleLayout, {
									file: file$r,
									url: url$r,
									content,
									frontmatter: content,
									headings: getHeadings$r(),
									rawContent: rawContent$r,
									compiledContent: compiledContent$r,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$r[Symbol.for('astro.needsHeadRendering')] = false;

const _page9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$r,
  compiledContent: compiledContent$r,
  default: Content$r,
  file: file$r,
  frontmatter: frontmatter$r,
  getHeadings: getHeadings$r,
  images: images$r,
  rawContent: rawContent$r,
  url: url$r
}, Symbol.toStringTag, { value: 'Module' }));

const images$q = {
					
				};

				function updateImageReferences$q(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$q[imagePath].src, ...images$q[imagePath].attributes})
					);
				}

				const html$q = updateImageReferences$q("<p>Men vi mÃ¥ ikke glemme hvorfor vi har denne leiren. Prinsessen mÃ¥ reddes! Hun har fÃ¥tt en stor spillegjeld over hode, etter Ã¥ ha gamblet med trollene. NÃ¥ frykter hun at trollene er ute etter henne, og derfor har hun har ansatt oss for Ã¥ vÃ¦re hennes livvakter. Uheldigvis er det fortsatt lenge til leiren, og mye kan skje pÃ¥ den tidâ€¦<br>\n<br>\nLeiren varer fra fredag 8-15 august og vil vÃ¦re pÃ¥ Steinholet leirplass ved Sjoa, midt mellom Randsverk og Gjende.<br>\n<br>\nPÃ¥ leiren vil det blandt annet bli:<br>\nLeirbÃ¥l, haik, kiosk, speideraktiviteter, bading, rafting og mye annet moro!<br>\n<br>\nPris<br>\nDeltagende speidere 3 000,-<br>\nSÃ¸skenmoderert deltagerpris 2 500,- (for hvert sÃ¸sken etter deltager til full pris)<br>\nRovere 2 000,-<br>\n<br>\nFrist for forhÃ¥ndspÃ¥melding 20 februar! Kr 1000,- indbetales ved forhÃ¥ndspÃ¥melding.<br>\n<br>\nNadderud speidergruppe Ã¸nsker at alle speidere skal ha mulighet til Ã¥ delta pÃ¥ denne leiren. Dersom din familie har vanskeligheter med Ã¥ betale hele leirkontingenten, Ã¸nsker speidergruppa Ã¥ bidra med Ã¸konomisk stÃ¸tte. Kontakt i sÃ¥ fall gruppeleder (Mats) sÃ¥ fort som mulig.<br>\n<br>\nDersom dere har spÃ¸rsmÃ¥l rundt betalingen kan dere ta kontakt med Mats Grimsgaard pÃ¥ tlf: 926 11 925<br>\n<br>\nBindende pÃ¥melding skjer i mai, men det er viktig at vi fÃ¥r en oversikt over hvor mange som Ã¸nsker Ã¥ bli med allerede nÃ¥.<br>\n<br>\nForhÃ¥ndspÃ¥melding skjer ved Ã¥ betale inn 1000,- til konto 9235 19 85773 (Nadderud speidergruppe). Det er viktig at innbetalingen merkes med navn.<br>\n<br>\nHar dere spÃ¸rsmÃ¥l angÃ¥ende leiren kan dere ta kontakt med Merete pÃ¥<a href=\"mailto:mbhaukedal@gmail.com\">mbhaukedal@gmail.com </a>eller Martin pÃ¥ <a href=\"mailto:martincclementz@gmail.com\">martincclementz@gmail.com</a>.<br>\n<br>\n<br>\nVi gleder oss til leir!<br>\n<br>\nHilsen lederne</p>");

				const frontmatter$q = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Troppsleir i Jotunheimen 8-15 august - Avlyst","featuredimage":"/img/upload/leir Jotunheimen.jpg","description":"Bli med pÃ¥ en eventyrlig uke, sammen med troll, prinsesser og konger. Sammen skal vi leke oss gjennom en uke, full av morsomme opplevelser. Vi skal bade, bygge, spise, lete, rafte og mye mer!","date":"2020-03-03T18:32:31.373Z","expireInDays":150,"tags":[null]};
				const file$q = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-03-03-troppsleir-i-jotunheimen-8-15-august.md";
				const url$q = "/artikler/2020-03-03-troppsleir-i-jotunheimen-8-15-august";
				function rawContent$q() {
					return "\nMen vi mÃ¥ ikke glemme hvorfor vi har denne leiren. Prinsessen mÃ¥ reddes! Hun har fÃ¥tt en stor spillegjeld over hode, etter Ã¥ ha gamblet med trollene. NÃ¥ frykter hun at trollene er ute etter henne, og derfor har hun har ansatt oss for Ã¥ vÃ¦re hennes livvakter. Uheldigvis er det fortsatt lenge til leiren, og mye kan skje pÃ¥ den tid...\\\n\\\nLeiren varer fra fredag 8-15 august og vil vÃ¦re pÃ¥ Steinholet leirplass ved Sjoa, midt mellom Randsverk og Gjende.\\\n\\\nPÃ¥ leiren vil det blandt annet bli:\\\nLeirbÃ¥l, haik, kiosk, speideraktiviteter, bading, rafting og mye annet moro!\\\n\\\nPris\\\nDeltagende speidere 3 000,-\\\nSÃ¸skenmoderert deltagerpris 2 500,- (for hvert sÃ¸sken etter deltager til full pris)\\\nRovere 2 000,-\\\n\\\nFrist for forhÃ¥ndspÃ¥melding 20 februar! Kr 1000,- indbetales ved forhÃ¥ndspÃ¥melding.\\\n\\\nNadderud speidergruppe Ã¸nsker at alle speidere skal ha mulighet til Ã¥ delta pÃ¥ denne leiren. Dersom din familie har vanskeligheter med Ã¥ betale hele leirkontingenten, Ã¸nsker speidergruppa Ã¥ bidra med Ã¸konomisk stÃ¸tte. Kontakt i sÃ¥ fall gruppeleder (Mats) sÃ¥ fort som mulig.\\\n\\\nDersom dere har spÃ¸rsmÃ¥l rundt betalingen kan dere ta kontakt med Mats Grimsgaard pÃ¥ tlf: 926 11 925\\\n\\\nBindende pÃ¥melding skjer i mai, men det er viktig at vi fÃ¥r en oversikt over hvor mange som Ã¸nsker Ã¥ bli med allerede nÃ¥.\\\n\\\nForhÃ¥ndspÃ¥melding skjer ved Ã¥ betale inn 1000,- til konto 9235 19 85773 (Nadderud speidergruppe). Det er viktig at innbetalingen merkes med navn.\\\n\\\nHar dere spÃ¸rsmÃ¥l angÃ¥ende leiren kan dere ta kontakt med Merete pÃ¥[mbhaukedal@gmail.com ](mailto:mbhaukedal@gmail.com)eller Martin pÃ¥ [martincclementz@gmail.com](mailto:martincclementz@gmail.com).\\\n\\\n\\\nVi gleder oss til leir!\\\n\\\nHilsen lederne\n";
				}
				function compiledContent$q() {
					return html$q;
				}
				function getHeadings$q() {
					return [];
				}
				async function Content$q() {
					const { layout, ...content } = frontmatter$q;
					content.file = file$q;
					content.url = url$q;
					const contentFragment = createVNode(Fragment, { 'set:html': html$q });
					return createVNode($$ArticleLayout, {
									file: file$q,
									url: url$q,
									content,
									frontmatter: content,
									headings: getHeadings$q(),
									rawContent: rawContent$q,
									compiledContent: compiledContent$q,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$q[Symbol.for('astro.needsHeadRendering')] = false;

const _page10 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$q,
  compiledContent: compiledContent$q,
  default: Content$q,
  file: file$q,
  frontmatter: frontmatter$q,
  getHeadings: getHeadings$q,
  images: images$q,
  rawContent: rawContent$q,
  url: url$q
}, Symbol.toStringTag, { value: 'Module' }));

const images$p = {
					
				};

				function updateImageReferences$p(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$p[imagePath].src, ...images$p[imagePath].attributes})
					);
				}

				const html$p = updateImageReferences$p("<p>-</p>");

				const frontmatter$p = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Gratulerer med dagen alle speidere!","featuredimage":"/img/upload/flaggborg.jpg","description":"I dag har Nadderud speidergruppe gÃ¥tt i flaggborg for fÃ¸rste gang! Det var veldig fint Ã¥ fÃ¥ mulighet til Ã¥ vÃ¦re med pÃ¥ og vi hÃ¥per vi fÃ¥r lov til det fremover ogsÃ¥. Det var en veldig fin mÃ¥te Ã¥ synliggjÃ¸re gruppa i lokalmiljÃ¸et.\n\nTusen takk til alle speiderne som deltok bÃ¥de pÃ¥ flaggheis og flaggborg.","date":"2020-05-17T19:22:14.989Z","expireInDays":60,"tags":["-"]};
				const file$p = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-05-17-gratulerer-med-dagen-alle-speidere.md";
				const url$p = "/artikler/2020-05-17-gratulerer-med-dagen-alle-speidere";
				function rawContent$p() {
					return "\n\\-\n";
				}
				function compiledContent$p() {
					return html$p;
				}
				function getHeadings$p() {
					return [];
				}
				async function Content$p() {
					const { layout, ...content } = frontmatter$p;
					content.file = file$p;
					content.url = url$p;
					const contentFragment = createVNode(Fragment, { 'set:html': html$p });
					return createVNode($$ArticleLayout, {
									file: file$p,
									url: url$p,
									content,
									frontmatter: content,
									headings: getHeadings$p(),
									rawContent: rawContent$p,
									compiledContent: compiledContent$p,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$p[Symbol.for('astro.needsHeadRendering')] = false;

const _page11 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$p,
  compiledContent: compiledContent$p,
  default: Content$p,
  file: file$p,
  frontmatter: frontmatter$p,
  getHeadings: getHeadings$p,
  images: images$p,
  rawContent: rawContent$p,
  url: url$p
}, Symbol.toStringTag, { value: 'Module' }));

const images$o = {
					
				};

				function updateImageReferences$o(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$o[imagePath].src, ...images$o[imagePath].attributes})
					);
				}

				const html$o = updateImageReferences$o("<p>OppmÃ¸te pÃ¥ parkeringen ved Stein GÃ¥rd kl. 11 lÃ¸rdag morgen.</p>\n<p>Vi gÃ¥r i samlet flokk innover til hytta som ligger bare et steinkast unna vÃ¥r egen Mason Hill ved Fiskelaustjern. Turen inn til Lomma er ca. 3 km lang, og gÃ¥r pÃ¥ vei/sti i lett terreng, men noen steder kan det vÃ¦re litt myrlendt/vÃ¥tt, sÃ¥ alle mÃ¥ mÃ¸te opp i fottÃ¸y tilpasset dette.</p>\n<p>Troppen har troppskonkurranse i skogene i nÃ¦rheten samme helg, og vi satser pÃ¥ Ã¥ fÃ¥ tatt en liten titt pÃ¥ hva de driver med der i lÃ¸pet av turen. Dette blir primÃ¦rt pÃ¥ sÃ¸ndagen, da vi istedenfor Ã¥ returnere til Stein gÃ¥rd heller fortsetter videre nordover til Burudvann der troppen har tilbragt natten. Etappen hit bestÃ¥r av ca. 3 km gange pÃ¥ lett sti.</p>\n<p>Turen avsluttes pÃ¥ parkeringen ved Burudvann kl 13 pÃ¥ sÃ¸ndag.</p>\n<p>Ytterligere informasjon, pakkeliste og pÃ¥meldingsdetaljer blir sendt i separat e-post.</p>\n<p>Vi gleder oss masse til tur og hÃ¥per all i flokken har mulighet til Ã¥ bli med.</p>\n<p>Speiderhilsen fra lederne i flokken</p>");

				const frontmatter$o = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Flokk-tur til Lomma 19.-20. oktober","date":"2019-10-11T14:58:17.793Z","description":"HÃ¸stens store hendelse for barna i flokken nÃ¦rmer seg, og turen gÃ¥r til 1. Eiksmarka's hytte \"Lomma\" i BÃ¦rumsmarka.","featuredimage":"/img/upload/lomma.jpg","expireInDays":60,"tags":["flokken"]};
				const file$o = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2019-10-12-flokk-tur-til-lomma-19-20-oktober.md";
				const url$o = "/artikler/2019-10-12-flokk-tur-til-lomma-19-20-oktober";
				function rawContent$o() {
					return "\nOppmÃ¸te pÃ¥ parkeringen ved Stein GÃ¥rd kl. 11 lÃ¸rdag morgen.\n\nVi gÃ¥r i samlet flokk innover til hytta som ligger bare et steinkast unna vÃ¥r egen Mason Hill ved Fiskelaustjern. Turen inn til Lomma er ca. 3 km lang, og gÃ¥r pÃ¥ vei/sti i lett terreng, men noen steder kan det vÃ¦re litt myrlendt/vÃ¥tt, sÃ¥ alle mÃ¥ mÃ¸te opp i fottÃ¸y tilpasset dette.\n\nTroppen har troppskonkurranse i skogene i nÃ¦rheten samme helg, og vi satser pÃ¥ Ã¥ fÃ¥ tatt en liten titt pÃ¥ hva de driver med der i lÃ¸pet av turen. Dette blir primÃ¦rt pÃ¥ sÃ¸ndagen, da vi istedenfor Ã¥ returnere til Stein gÃ¥rd heller fortsetter videre nordover til Burudvann der troppen har tilbragt natten. Etappen hit bestÃ¥r av ca. 3 km gange pÃ¥ lett sti.\n\nTuren avsluttes pÃ¥ parkeringen ved Burudvann kl 13 pÃ¥ sÃ¸ndag.\n\nYtterligere informasjon, pakkeliste og pÃ¥meldingsdetaljer blir sendt i separat e-post.\n\nVi gleder oss masse til tur og hÃ¥per all i flokken har mulighet til Ã¥ bli med.\n\nSpeiderhilsen fra lederne i flokken\n";
				}
				function compiledContent$o() {
					return html$o;
				}
				function getHeadings$o() {
					return [];
				}
				async function Content$o() {
					const { layout, ...content } = frontmatter$o;
					content.file = file$o;
					content.url = url$o;
					const contentFragment = createVNode(Fragment, { 'set:html': html$o });
					return createVNode($$ArticleLayout, {
									file: file$o,
									url: url$o,
									content,
									frontmatter: content,
									headings: getHeadings$o(),
									rawContent: rawContent$o,
									compiledContent: compiledContent$o,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$o[Symbol.for('astro.needsHeadRendering')] = false;

const _page12 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$o,
  compiledContent: compiledContent$o,
  default: Content$o,
  file: file$o,
  frontmatter: frontmatter$o,
  getHeadings: getHeadings$o,
  images: images$o,
  rawContent: rawContent$o,
  url: url$o
}, Symbol.toStringTag, { value: 'Module' }));

const images$n = {
					
				};

				function updateImageReferences$n(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$n[imagePath].src, ...images$n[imagePath].attributes})
					);
				}

				const html$n = updateImageReferences$n("<p>Det blir leir med overnatting, og den avholdes pÃ¥ Trettenes leirsted ved Farris, rett innenfor Larvik. Dette er et idyllisk sted med flotte turmuligheter, bÃ¥de pÃ¥ vannet og i skogen. Vi kommer til bruke kanoene en hel del! Leiren vil vÃ¦re fra lÃ¸rdag 8. august til tirsdag 11. august. Speiderne mÃ¥ leveres og hentes pÃ¥ leirstedet, og hÃ¥per dere fÃ¥r koordinert litt samkjÃ¸ring. Det vil ogsÃ¥ vÃ¦re mulig Ã¥ hente speidere pÃ¥ toget i Larvik.</p>\n<p>Fordi vi ikke fÃ¥r transportkostnader og har fÃ¥tt midler fra Ferd til â€œkoronaspeidingâ€ vil leiren vÃ¦re gratis.</p>\n<p>Litt info om smittevernsvurderingen:</p>\n<p>â€¢ Som hovedregel vil aktiviteter og opplegg vÃ¦re tilpasset 1-metersregelen, og fÃ¸lge gjeldende retningslinjer fra FHI og NSF.</p>\n<p>â€¢ Speiderne kommer til Ã¥ spise og sove med patruljene sine og vil vÃ¦re noe tettere pÃ¥ disse enn troppen for Ã¸vrig. De vil sove inntil seks personer i hver 10-mannslavvo, og fÃ¥r minst en meter mellom hodene nÃ¥r de sover.</p>\n<p>â€¢ Nadderud har tradisjon for to daglige inspeksjoner av personlig hygiene, generell hygiene og orden, og denne kommer til bli strengere i Ã¥r!</p>\n<p>â€¢ Det er vannklosetter og rennende vann Ã¥ vaske seg med pÃ¥ stedet. Toalettene vil bli rengjort flere ganger daglig.</p>\n<p>â€¢ Personer med forkjÃ¸lelsessymptomer eller andre luftveisinfeksjoner skal holde seg hjemme. Det gjelder ogsÃ¥ personer i karantene eller isolasjon. Dersom symptomer skulle oppstÃ¥ pÃ¥ leir mÃ¥ speideren blir hentet. Vi har muligheter for karantene frem til henting.</p>\n<p>PÃ¥melding til leir pÃ¥ mail til Merete pÃ¥ <a href=\"mailto:mbhaukedal@gmail.com\">mbhaukedal@gmail.com</a>, senest 19. juni. NÃ¥r du melder deg pÃ¥ vil du motta helsekort som mÃ¥ fylles ut og returneres.</p>\n<p>Speideren utvikler mennesker til selvstendighet og til Ã¥ ta aktivt ansvar i samfunnet i samsvar med idealene fra speiderlÃ¸ftet og speiderloven. Med dette som bakteppe Ã¸nsker vi skape en trygg og god leir som gir speiderne gode sommerminner, supre speideropplevelser og masse nyttig kunnskap!</p>\n<p>Vi hÃ¥per Ã¥ se flest mulig av dere og gleder oss til leir!</p>\n<p>Hilsen roverne og lederne</p>");

				const frontmatter$n = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Minileir sommer 2020 ved Farris!","featuredimage":"/img/upload/20190608_153548.jpg","description":"Ã…rets sommerleir i Jotunheimen er avlyst, men vi har nÃ¥ gleden av Ã¥ invitere til en mindre og lettere leir!\n\nMeld deg pÃ¥ til Trettenes 2020!","date":"2020-06-10T18:35:55.130Z","expireInDays":60,"tags":["-"]};
				const file$n = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-06-10-minileir-sommer-2020-ved-farris.md";
				const url$n = "/artikler/2020-06-10-minileir-sommer-2020-ved-farris";
				function rawContent$n() {
					return "\nDet blir leir med overnatting, og den avholdes pÃ¥ Trettenes leirsted ved Farris, rett innenfor Larvik. Dette er et idyllisk sted med flotte turmuligheter, bÃ¥de pÃ¥ vannet og i skogen. Vi kommer til bruke kanoene en hel del! Leiren vil vÃ¦re fra lÃ¸rdag 8. august til tirsdag 11. august. Speiderne mÃ¥ leveres og hentes pÃ¥ leirstedet, og hÃ¥per dere fÃ¥r koordinert litt samkjÃ¸ring. Det vil ogsÃ¥ vÃ¦re mulig Ã¥ hente speidere pÃ¥ toget i Larvik.\n\nFordi vi ikke fÃ¥r transportkostnader og har fÃ¥tt midler fra Ferd til â€œkoronaspeidingâ€ vil leiren vÃ¦re gratis.\n\nLitt info om smittevernsvurderingen:\n\nâ€¢ Som hovedregel vil aktiviteter og opplegg vÃ¦re tilpasset 1-metersregelen, og fÃ¸lge gjeldende retningslinjer fra FHI og NSF.\n\nâ€¢ Speiderne kommer til Ã¥ spise og sove med patruljene sine og vil vÃ¦re noe tettere pÃ¥ disse enn troppen for Ã¸vrig. De vil sove inntil seks personer i hver 10-mannslavvo, og fÃ¥r minst en meter mellom hodene nÃ¥r de sover.\n\nâ€¢ Nadderud har tradisjon for to daglige inspeksjoner av personlig hygiene, generell hygiene og orden, og denne kommer til bli strengere i Ã¥r!\n\nâ€¢ Det er vannklosetter og rennende vann Ã¥ vaske seg med pÃ¥ stedet. Toalettene vil bli rengjort flere ganger daglig.\n\nâ€¢ Personer med forkjÃ¸lelsessymptomer eller andre luftveisinfeksjoner skal holde seg hjemme. Det gjelder ogsÃ¥ personer i karantene eller isolasjon. Dersom symptomer skulle oppstÃ¥ pÃ¥ leir mÃ¥ speideren blir hentet. Vi har muligheter for karantene frem til henting.\n\nPÃ¥melding til leir pÃ¥ mail til Merete pÃ¥ mbhaukedal@gmail.com, senest 19. juni. NÃ¥r du melder deg pÃ¥ vil du motta helsekort som mÃ¥ fylles ut og returneres.\n\nSpeideren utvikler mennesker til selvstendighet og til Ã¥ ta aktivt ansvar i samfunnet i samsvar med idealene fra speiderlÃ¸ftet og speiderloven. Med dette som bakteppe Ã¸nsker vi skape en trygg og god leir som gir speiderne gode sommerminner, supre speideropplevelser og masse nyttig kunnskap!\n\nVi hÃ¥per Ã¥ se flest mulig av dere og gleder oss til leir!\n\nHilsen roverne og lederne\n";
				}
				function compiledContent$n() {
					return html$n;
				}
				function getHeadings$n() {
					return [];
				}
				async function Content$n() {
					const { layout, ...content } = frontmatter$n;
					content.file = file$n;
					content.url = url$n;
					const contentFragment = createVNode(Fragment, { 'set:html': html$n });
					return createVNode($$ArticleLayout, {
									file: file$n,
									url: url$n,
									content,
									frontmatter: content,
									headings: getHeadings$n(),
									rawContent: rawContent$n,
									compiledContent: compiledContent$n,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$n[Symbol.for('astro.needsHeadRendering')] = false;

const _page13 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$n,
  compiledContent: compiledContent$n,
  default: Content$n,
  file: file$n,
  frontmatter: frontmatter$n,
  getHeadings: getHeadings$n,
  images: images$n,
  rawContent: rawContent$n,
  url: url$n
}, Symbol.toStringTag, { value: 'Module' }));

const images$m = {
					
				};

				function updateImageReferences$m(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$m[imagePath].src, ...images$m[imagePath].attributes})
					);
				}

				const html$m = updateImageReferences$m("<p>Dette ble en litt annerledes vÃ¥r. Vi har vÃ¦rt gjennom en uventet og krevende tid, men nÃ¥ gleder vi oss over at patruljene og flokken forsiktig har begynt med mÃ¸ter igjen.</p>\n<p>FÃ¸r vi tar sommerferie er det viktig Ã¥ fÃ¥ gjennomfÃ¸rt et Ã¥rsmÃ¸te, hvor vi kan mÃ¸tes og legge planer for resten av Ã¥ret. Det er pÃ¥ Ã¥rsmÃ¸tet vi bestemmer hva vi skal gjÃ¸re framover og jeg hÃ¥per mange speidere har lyst til Ã¥ vÃ¦re med og bestemme!</p>\n<p>Vi trenger ogsÃ¥ flere foreldre som kan vÃ¦re med Ã¥ drive speidergruppa, og hjelpe til med store eller smÃ¥ oppgaver.</p>\n<p><strong>OBS! Av hensyn til smittevern ber vi om at alle <a href=\"https://forms.gle/iE3fKmLAgTMFDMmF8\">registrerer seg som deltakere</a> innen fredag 5. juni</strong>, sÃ¥ vi kan planlegge etter hvor mange som kommer. Ã…rsmÃ¸tet vil bli gjennomfÃ¸rt utendÃ¸rs, med god plass. Det vil bli servert pizza til registrerte deltakere.</p>\n<p>Sakspapirer legges ut pÃ¥ nadderud.no ca. en uke fÃ¸r Ã¥rsmÃ¸tet. Hvis noen har saker dere Ã¸nsker Ã¥ ta opp pÃ¥ Ã¥rsmÃ¸tet, kan de sendes til <a href=\"mailto:mats@nadderud.no\">mats@nadderud.no</a> innen 1. juni.</p>\n<h2 id=\"saksliste\">Saksliste</h2>\n<ol>\n<li>\n<p><strong>Konstituering</strong></p>\n<ol>\n<li>Valg av mÃ¸teleder</li>\n<li>Valg av referent og to representanter til Ã¥ underskrive protokollen</li>\n<li>Godkjenning av innkalling og saksliste</li>\n</ol>\n</li>\n<li>\n<p><strong><a href=\"https://docs.google.com/document/d/e/2PACX-1vQ7COFw5tgyFnr_ZJrzM8B7mMcC9r_8nU1Nmv1xeE348r3huOo9haochSbsRF5xlamFDyQ-_90jtya1/pub\">Ã…rsmelding 2019</a></strong><br>\nGruppestyrets Ã¥rsmelding legges fram for godkjenning. Rapport fra enhetene og Mason Hill.</p>\n</li>\n<li>\n<p><strong><a href=\"https://drive.google.com/file/d/1w109Ti6FyHXvepxszRNdDByDCQDwuwb8/view?usp=sharing\">Regnskap 2019</a></strong><br>\nRegnskap legges fram for godkjenning.</p>\n</li>\n<li>\n<p><strong>Eiendommene etter 1. Haslum</strong><br>\nOppfÃ¸lging av diskusjonen om hva vi skal gjÃ¸re med de to ekstra speiderhyttene vi har ansvar for.</p>\n</li>\n<li>\n<p><strong><a href=\"https://docs.google.com/spreadsheets/d/e/2PACX-1vSEb-DOGxZX4M6YBHZX792HgYRenybNi89UdJz8tYYBI1V7D-8VzogTUzMEZdk--aeMgtJRIqsnJaYe/pubhtml?gid=0&#x26;single=true\">Budsjett 2021</a></strong><br>\nForslag til budsjett for neste Ã¥r.</p>\n</li>\n<li>\n<p><strong>Valg</strong></p>\n<ol>\n<li>Gruppeleder (for to Ã¥r)</li>\n<li>Styremedlem (for to Ã¥r)</li>\n<li>Representanter til kretsting (10 representanter, for ett Ã¥r)</li>\n<li>Kasserer</li>\n<li>Revisor (for ett Ã¥r)</li>\n<li>ForeldrerÃ¥d (5 representanter, for ett Ã¥r)</li>\n</ol>\n</li>\n</ol>\n<p>Vel mÃ¸tt!</p>");

				const frontmatter$m = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Ã…rsmÃ¸te 8. juni pÃ¥ Speiderhuset","featuredimage":"/img/upload/leirbaal.jpg","description":"Speidere og foreldre innkalles til gruppetingets Ã¥rsmÃ¸te pÃ¥ baksiden av Speiderhuset, mandag 8. juni kl. 18-19.","date":"2020-05-25T17:50:49.417Z","expireInDays":60,"tags":["Ã¥rsmÃ¸te"]};
				const file$m = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-05-25-Ã¥rsmÃ¸te-8-juni-pÃ¥-speiderhuset.md";
				const url$m = "/artikler/2020-05-25-Ã¥rsmÃ¸te-8-juni-pÃ¥-speiderhuset";
				function rawContent$m() {
					return "\nDette ble en litt annerledes vÃ¥r. Vi har vÃ¦rt gjennom en uventet og krevende tid, men nÃ¥ gleder vi oss over at patruljene og flokken forsiktig har begynt med mÃ¸ter igjen.\n\nFÃ¸r vi tar sommerferie er det viktig Ã¥ fÃ¥ gjennomfÃ¸rt et Ã¥rsmÃ¸te, hvor vi kan mÃ¸tes og legge planer for resten av Ã¥ret. Det er pÃ¥ Ã¥rsmÃ¸tet vi bestemmer hva vi skal gjÃ¸re framover og jeg hÃ¥per mange speidere har lyst til Ã¥ vÃ¦re med og bestemme!\n\nVi trenger ogsÃ¥ flere foreldre som kan vÃ¦re med Ã¥ drive speidergruppa, og hjelpe til med store eller smÃ¥ oppgaver.\n\n**OBS! Av hensyn til smittevern ber vi om at alle [registrerer seg som deltakere](https://forms.gle/iE3fKmLAgTMFDMmF8) innen fredag 5. juni**, sÃ¥ vi kan planlegge etter hvor mange som kommer. Ã…rsmÃ¸tet vil bli gjennomfÃ¸rt utendÃ¸rs, med god plass. Det vil bli servert pizza til registrerte deltakere.\n\nSakspapirer legges ut pÃ¥ nadderud.no ca. en uke fÃ¸r Ã¥rsmÃ¸tet. Hvis noen har saker dere Ã¸nsker Ã¥ ta opp pÃ¥ Ã¥rsmÃ¸tet, kan de sendes til [mats@nadderud.no](mailto:mats@nadderud.no) innen 1. juni.\n\n## Saksliste\n\n1. **Konstituering**\n\n   1. Valg av mÃ¸teleder\n   2. Valg av referent og to representanter til Ã¥ underskrive protokollen\n   3. Godkjenning av innkalling og saksliste\n\n2. **[Ã…rsmelding 2019](https://docs.google.com/document/d/e/2PACX-1vQ7COFw5tgyFnr_ZJrzM8B7mMcC9r_8nU1Nmv1xeE348r3huOo9haochSbsRF5xlamFDyQ-_90jtya1/pub)**\\\n   Gruppestyrets Ã¥rsmelding legges fram for godkjenning. Rapport fra enhetene og Mason Hill.\n3. **[Regnskap 2019](https://drive.google.com/file/d/1w109Ti6FyHXvepxszRNdDByDCQDwuwb8/view?usp=sharing)**\\\n   Regnskap legges fram for godkjenning.\n4. **Eiendommene etter 1. Haslum**\\\n   OppfÃ¸lging av diskusjonen om hva vi skal gjÃ¸re med de to ekstra speiderhyttene vi har ansvar for.\n5. **[Budsjett 2021](https://docs.google.com/spreadsheets/d/e/2PACX-1vSEb-DOGxZX4M6YBHZX792HgYRenybNi89UdJz8tYYBI1V7D-8VzogTUzMEZdk--aeMgtJRIqsnJaYe/pubhtml?gid=0&single=true)**\\\n   Forslag til budsjett for neste Ã¥r.\n6. **Valg**\n\n   1. Gruppeleder (for to Ã¥r)\n   2. Styremedlem (for to Ã¥r)\n   3. Representanter til kretsting (10 representanter, for ett Ã¥r)\n   4. Kasserer\n   5. Revisor (for ett Ã¥r)\n   6. ForeldrerÃ¥d (5 representanter, for ett Ã¥r)\n\nVel mÃ¸tt!\n";
				}
				function compiledContent$m() {
					return html$m;
				}
				function getHeadings$m() {
					return [{"depth":2,"slug":"saksliste","text":"Saksliste"}];
				}
				async function Content$m() {
					const { layout, ...content } = frontmatter$m;
					content.file = file$m;
					content.url = url$m;
					const contentFragment = createVNode(Fragment, { 'set:html': html$m });
					return createVNode($$ArticleLayout, {
									file: file$m,
									url: url$m,
									content,
									frontmatter: content,
									headings: getHeadings$m(),
									rawContent: rawContent$m,
									compiledContent: compiledContent$m,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$m[Symbol.for('astro.needsHeadRendering')] = false;

const _page14 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$m,
  compiledContent: compiledContent$m,
  default: Content$m,
  file: file$m,
  frontmatter: frontmatter$m,
  getHeadings: getHeadings$m,
  images: images$m,
  rawContent: rawContent$m,
  url: url$m
}, Symbol.toStringTag, { value: 'Module' }));

const images$l = {
					
				};

				function updateImageReferences$l(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$l[imagePath].src, ...images$l[imagePath].attributes})
					);
				}

				const html$l = updateImageReferences$l("<p>Det er snart klart for vinterens vakreste eventyr! Ã…rets snÃ¸huletur arrangeres 28. februar - 1. mars</p>\n<p>Nadderuds tradisjonsrike snÃ¸huletur er for alle som gÃ¥r i 8. klasse eller hÃ¸yere, og er en fin og spennende mÃ¥te Ã¥ bli kjent med vinterspeiding, hÃ¸yfjell og snÃ¸hulegraving. Vi gÃ¥r ikke langt, men fokuserer pÃ¥ hulegraving. Vi drar til HaugastÃ¸l om vÃ¦r og snÃ¸ er bra, ellers vil vi pÃ¥ kort varsel kunne endre til annet sted.</p>\n<p>Avreise fra parkeringsplassen bak Rema Nadderud (v/Rikets sal) klokka 17 pÃ¥ fredag 28. februar.</p>\n<p>Vi sover i telt fra fredag til lÃ¸rdag, og har hele lÃ¸rdagen til Ã¥ grave. SÃ¸ndag har vi tid til bÃ¥de lek og lÃ¦ring, fÃ¸r vi drar hjem. Hjemkomst blir sÃ¸ndag kveld, tidspunkt avhenger av vÃ¦r og fÃ¸re, men vi regner med at det blir omtrent klokka 20.</p>\n<p>Middag kjÃ¸pes inn felles, fÃ¸lg forÃ¸vrig <a href=\"/img/upload/utstyrsliste%20vinter.pdf\">vedlagt utstyrsliste</a>. Det er veldig fint med sÃ¥ mange kokeapparater som mulig. Vi fordeler fellesutstyr pÃ¥ veien opp. Pris inkluderer middag lÃ¸rdag og transport: Prisen er 500 kroner pr pers. Vipps til Stian ved oppmÃ¸te eller tidligere.</p>\n<p>Det vil bli infomÃ¸te etter troppsmÃ¸tet mandag 3.februar kl 19:30 pÃ¥ speiderhuset for alle speidere som vurderer Ã¥ vÃ¦re med pÃ¥ turen, ellers er det bare ta kontakt om det er noe dere lurer pÃ¥.</p>\n<p><strong>PÃ¥melding til Stian innen 24. februar pÃ¥ <a href=\"mailto:stian@nadderud.no\">stian@nadderud.no</a> eller mobil <a href=\"tel:91128204\">911 28 204</a>.</strong></p>\n<p><em>NB: Vi har begrenset antall plasser - fÃ¸rstemann til mÃ¸lla!</em></p>\n<p>Speiderhilsen</p>\n<p>Stian</p>");

				const frontmatter$l = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"SnÃ¸huletur 28. februar - 1. mars","date":"2020-02-02T06:43:00.367Z","description":"Det er snart klart for vinterens vakreste eventyr! Ã…rets snÃ¸huletur arrangeres 28. februar - 1. mars","featuredimage":"/img/upload/skitur paa fjell.jpg","expireInDays":60,"tags":["troppen","rover"]};
				const file$l = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-02-02-snÃ¸huletur-28-februar-1-mars.md";
				const url$l = "/artikler/2020-02-02-snÃ¸huletur-28-februar-1-mars";
				function rawContent$l() {
					return "\nDet er snart klart for vinterens vakreste eventyr! Ã…rets snÃ¸huletur arrangeres 28. februar - 1. mars\n\nNadderuds tradisjonsrike snÃ¸huletur er for alle som gÃ¥r i 8. klasse eller hÃ¸yere, og er en fin og spennende mÃ¥te Ã¥ bli kjent med vinterspeiding, hÃ¸yfjell og snÃ¸hulegraving. Vi gÃ¥r ikke langt, men fokuserer pÃ¥ hulegraving. Vi drar til HaugastÃ¸l om vÃ¦r og snÃ¸ er bra, ellers vil vi pÃ¥ kort varsel kunne endre til annet sted.\n\nAvreise fra parkeringsplassen bak Rema Nadderud (v/Rikets sal) klokka 17 pÃ¥ fredag 28. februar.\n\nVi sover i telt fra fredag til lÃ¸rdag, og har hele lÃ¸rdagen til Ã¥ grave. SÃ¸ndag har vi tid til bÃ¥de lek og lÃ¦ring, fÃ¸r vi drar hjem. Hjemkomst blir sÃ¸ndag kveld, tidspunkt avhenger av vÃ¦r og fÃ¸re, men vi regner med at det blir omtrent klokka 20.\n\nMiddag kjÃ¸pes inn felles, fÃ¸lg forÃ¸vrig [vedlagt utstyrsliste](/img/upload/utstyrsliste%20vinter.pdf). Det er veldig fint med sÃ¥ mange kokeapparater som mulig. Vi fordeler fellesutstyr pÃ¥ veien opp. Pris inkluderer middag lÃ¸rdag og transport: Prisen er 500 kroner pr pers. Vipps til Stian ved oppmÃ¸te eller tidligere.\n\nDet vil bli infomÃ¸te etter troppsmÃ¸tet mandag 3.februar kl 19:30 pÃ¥ speiderhuset for alle speidere som vurderer Ã¥ vÃ¦re med pÃ¥ turen, ellers er det bare ta kontakt om det er noe dere lurer pÃ¥.\n\n**PÃ¥melding til Stian innen 24. februar pÃ¥ [stian@nadderud.no](mailto:stian@nadderud.no) eller mobil [911 28 204](tel:91128204).**\n\n_NB: Vi har begrenset antall plasser - fÃ¸rstemann til mÃ¸lla!_\n\nSpeiderhilsen\n\nStian\n";
				}
				function compiledContent$l() {
					return html$l;
				}
				function getHeadings$l() {
					return [];
				}
				async function Content$l() {
					const { layout, ...content } = frontmatter$l;
					content.file = file$l;
					content.url = url$l;
					const contentFragment = createVNode(Fragment, { 'set:html': html$l });
					return createVNode($$ArticleLayout, {
									file: file$l,
									url: url$l,
									content,
									frontmatter: content,
									headings: getHeadings$l(),
									rawContent: rawContent$l,
									compiledContent: compiledContent$l,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$l[Symbol.for('astro.needsHeadRendering')] = false;

const _page15 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$l,
  compiledContent: compiledContent$l,
  default: Content$l,
  file: file$l,
  frontmatter: frontmatter$l,
  getHeadings: getHeadings$l,
  images: images$l,
  rawContent: rawContent$l,
  url: url$l
}, Symbol.toStringTag, { value: 'Module' }));

const images$k = {
					
				};

				function updateImageReferences$k(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$k[imagePath].src, ...images$k[imagePath].attributes})
					);
				}

				const html$k = updateImageReferences$k("<p>Nadderud speidergruppe skal heise flagget pÃ¥ Hosle skole, men for Ã¥ holde antall deltakere ved arrangementet lavt nok skal speideren kun stille med 10 personer. Det er derfor kun flaggpatruljen (Ekorn) og noen ledere som stiller. Dersom noen utover disse gjerne vil stille mÃ¥ det avklares direkte med Stian (911 28 204).</p>\n<p>Hele seansen ved flaggheis pÃ¥ Hosle skole blir streamet pÃ¥ nett, sÃ¥ det vil vÃ¦re mulig Ã¥ fÃ¸lge den hjemmefra. Sendes pÃ¥ â€œ17. mai pÃ¥ Hosle skoleâ€ pÃ¥ Facebook.</p>\n<p>Vi skal ogsÃ¥ heise flagget pÃ¥ Haslum skole. Her er det vanligvis fÃ¥ som stiller, sÃ¥ de av speiderne som har tilhÃ¸righet til Haslum kan gjerne stille samme med Martin C til flaggheis kl 08:00 der.</p>\n<p>Den tradisjonsrike frokosten for fÃ¸rerpatrulje og ledere blir det dessverre ikke noe av i Ã¥r.</p>\n<p>Det speideren derimot skal gjÃ¸re i Ã¥r, er Ã¥ gÃ¥ i flaggborg i tog sammen med Hosle og Bekkestua skolekorps, men uten skoleklassene. OppmÃ¸te pÃ¥ Hosle skole 11:30 og avslutning pÃ¥ Bekkestua skole noe fÃ¸r kl 13:00. Speidere i 8.klasse og eldre kan melde seg pÃ¥ til Stian (911 28 204) for Ã¥ bli med i flaggborgen. OgsÃ¥ toget vil bli sendt direkte pÃ¥ â€œ17. mai pÃ¥ Hosle skoleâ€ pÃ¥ Facebook.</p>\n<p>PÃ¥ vegne av hele Nadderud speidergruppe Ã¸nsker vi dere alle en god 17. mai-feiring!</p>");

				const frontmatter$k = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Informasjon om 17. mai 2020","featuredimage":"/img/upload/flagg2.jpg","description":"Nasjonaldagen nÃ¦rmer seg, og som dere alle vet blir det en annerledes 17. mai i Ã¥r.","date":"2020-05-12T17:57:39.352Z","expireInDays":60,"tags":["alle"]};
				const file$k = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-05-12-informasjon-om-17-mai-2020.md";
				const url$k = "/artikler/2020-05-12-informasjon-om-17-mai-2020";
				function rawContent$k() {
					return "\nNadderud speidergruppe skal heise flagget pÃ¥ Hosle skole, men for Ã¥ holde antall deltakere ved arrangementet lavt nok skal speideren kun stille med 10 personer. Det er derfor kun flaggpatruljen (Ekorn) og noen ledere som stiller. Dersom noen utover disse gjerne vil stille mÃ¥ det avklares direkte med Stian (911 28 204).\n\nHele seansen ved flaggheis pÃ¥ Hosle skole blir streamet pÃ¥ nett, sÃ¥ det vil vÃ¦re mulig Ã¥ fÃ¸lge den hjemmefra. Sendes pÃ¥ \"17. mai pÃ¥ Hosle skoleâ€ pÃ¥ Facebook.\n\nVi skal ogsÃ¥ heise flagget pÃ¥ Haslum skole. Her er det vanligvis fÃ¥ som stiller, sÃ¥ de av speiderne som har tilhÃ¸righet til Haslum kan gjerne stille samme med Martin C til flaggheis kl 08:00 der.\n\nDen tradisjonsrike frokosten for fÃ¸rerpatrulje og ledere blir det dessverre ikke noe av i Ã¥r.\n\nDet speideren derimot skal gjÃ¸re i Ã¥r, er Ã¥ gÃ¥ i flaggborg i tog sammen med Hosle og Bekkestua skolekorps, men uten skoleklassene. OppmÃ¸te pÃ¥ Hosle skole 11:30 og avslutning pÃ¥ Bekkestua skole noe fÃ¸r kl 13:00. Speidere i 8.klasse og eldre kan melde seg pÃ¥ til Stian (911 28 204) for Ã¥ bli med i flaggborgen. OgsÃ¥ toget vil bli sendt direkte pÃ¥ \"17. mai pÃ¥ Hosle skole\" pÃ¥ Facebook.\n\nPÃ¥ vegne av hele Nadderud speidergruppe Ã¸nsker vi dere alle en god 17. mai-feiring!\n";
				}
				function compiledContent$k() {
					return html$k;
				}
				function getHeadings$k() {
					return [];
				}
				async function Content$k() {
					const { layout, ...content } = frontmatter$k;
					content.file = file$k;
					content.url = url$k;
					const contentFragment = createVNode(Fragment, { 'set:html': html$k });
					return createVNode($$ArticleLayout, {
									file: file$k,
									url: url$k,
									content,
									frontmatter: content,
									headings: getHeadings$k(),
									rawContent: rawContent$k,
									compiledContent: compiledContent$k,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$k[Symbol.for('astro.needsHeadRendering')] = false;

const _page16 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$k,
  compiledContent: compiledContent$k,
  default: Content$k,
  file: file$k,
  frontmatter: frontmatter$k,
  getHeadings: getHeadings$k,
  images: images$k,
  rawContent: rawContent$k,
  url: url$k
}, Symbol.toStringTag, { value: 'Module' }));

const images$j = {
					
				};

				function updateImageReferences$j(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$j[imagePath].src, ...images$j[imagePath].attributes})
					);
				}

				const html$j = updateImageReferences$j("<p>HÃ¥per alle gamle og nye speidere er klare for Ã¥ kjempe i den gjeve konkurransen om Ã¥ bli Ã¥rets flagg- eller bannerpatrulje!</p>\n<p>I Ã¥r starter troppskonkurransen lÃ¸rdag 19 oktober pÃ¥ Hauger T-banestasjon kl 10.00. T-banen gÃ¥r fra Bekkestua T-banestasjon kl 09.36 og kl 09.51, vi oppfordrer alle til Ã¥ ta kollektivt. Neste dag, sÃ¸ndag 20 oktober, er vi fremme ved parkeringa ved Burudvann kl 14.00. Vi sover ute i gapahuk om natten.</p>\n<p>PÃ¥ turen gÃ¥r vi i speiderskjerf.</p>\n<h2 id=\"pakkeliste\">Pakkeliste:</h2>\n<ul>\n<li>Sovepose</li>\n<li>Liggeunderlag</li>\n<li>Uteligger/grevling (hvis du har)</li>\n<li>Varm ullgenser (det blir kaldt om kvelden)</li>\n<li>Ekstra par ullsokker</li>\n<li>Lue, votter og skjerf</li>\n<li>UllundertÃ¸y</li>\n<li>UndertÃ¸yskift</li>\n<li>Toalettsaker</li>\n<li>Ekstra skift</li>\n<li>RegntÃ¸y</li>\n<li>Kniv</li>\n<li>Lommelykt</li>\n<li>Fyrstikker</li>\n<li>Kopp, tallerken og bestikk</li>\n<li>Papir og blyant</li>\n<li>Personlig fÃ¸rstehjelp</li>\n<li>3 brÃ¸dmÃ¥ltider</li>\n<li>Middag som kan tilberedes pÃ¥ bÃ¥l</li>\n<li>Godteri til kvelden</li>\n<li>Ublandet saft, â€Rett i koppenâ€ e.l.</li>\n<li>Vannflaske med vann</li>\n<li>Haikebrett eller skjÃ¦refjÃ¸l (mÃ¥ vÃ¦re stor nok til at mat ikke faller pÃ¥ udsiden under matkonkurranse)</li>\n</ul>\n<p>Peffen har ansvar for Ã¥ ta med patruljeutstyr til konkurransen: Kompass, kartlomme, pressening, oppvaskbÃ¸rste, oppvasksÃ¥pe og tÃ¸rkehÃ¥ndkle, sÃ¸ppelsekk/poser til avfallsortering, surretau, primus/kokeapparat, Ã¸ks, sag, hammer og patruljens fÃ¸rstehjelpsutstyr (henting av utstyr avtales med utstyrsannsvarlig Stian pÃ¥ tlf 911 28 204).</p>\n<p>PÃ¥melding skjer til Merete (<a href=\"mailto:mbhaukedal@gmail.com\">mbhaukedal@gmail.com</a>) innen onsdag 16 oktober.</p>\n<p>Ta gjerne kontakt hvis det er noen spÃ¸rsmÃ¥l.</p>\n<p>Vi gleder oss til Ã¥ dra pÃ¥ tur med dere!!</p>\n<p>Speiderhilsen fra lederne!</p>");

				const frontmatter$j = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Troppskonk 19-20 oktober","featuredimage":"/img/upload/20181013_122906.jpg","description":"Endelig er det pÃ¥ tide med hÃ¸stens fÃ¸rste troppstur!","date":"2019-10-19T08:00:00.000Z","expireInDays":60,"tags":["troppen"]};
				const file$j = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2019-09-25-troppskonk-19-20-oktober.md";
				const url$j = "/artikler/2019-09-25-troppskonk-19-20-oktober";
				function rawContent$j() {
					return "\nHÃ¥per alle gamle og nye speidere er klare for Ã¥ kjempe i den gjeve konkurransen om Ã¥ bli Ã¥rets flagg- eller bannerpatrulje!\n\nI Ã¥r starter troppskonkurransen lÃ¸rdag 19 oktober pÃ¥ Hauger T-banestasjon kl 10.00. T-banen gÃ¥r fra Bekkestua T-banestasjon kl 09.36 og kl 09.51, vi oppfordrer alle til Ã¥ ta kollektivt. Neste dag, sÃ¸ndag 20 oktober, er vi fremme ved parkeringa ved Burudvann kl 14.00. Vi sover ute i gapahuk om natten.\n\nPÃ¥ turen gÃ¥r vi i speiderskjerf.\n\n## Pakkeliste:\n\n- Sovepose\n- Liggeunderlag\n- Uteligger/grevling (hvis du har)\n- Varm ullgenser (det blir kaldt om kvelden)\n- Ekstra par ullsokker\n- Lue, votter og skjerf\n- UllundertÃ¸y\n- UndertÃ¸yskift\n- Toalettsaker\n- Ekstra skift\n- RegntÃ¸y\n- Kniv\n- Lommelykt\n- Fyrstikker\n- Kopp, tallerken og bestikk\n- Papir og blyant\n- Personlig fÃ¸rstehjelp\n- 3 brÃ¸dmÃ¥ltider\n- Middag som kan tilberedes pÃ¥ bÃ¥l\n- Godteri til kvelden\n- Ublandet saft, â€Rett i koppenâ€ e.l.\n- Vannflaske med vann\n- Haikebrett eller skjÃ¦refjÃ¸l (mÃ¥ vÃ¦re stor nok til at mat ikke faller pÃ¥ udsiden under matkonkurranse)\n\nPeffen har ansvar for Ã¥ ta med patruljeutstyr til konkurransen: Kompass, kartlomme, pressening, oppvaskbÃ¸rste, oppvasksÃ¥pe og tÃ¸rkehÃ¥ndkle, sÃ¸ppelsekk/poser til avfallsortering, surretau, primus/kokeapparat, Ã¸ks, sag, hammer og patruljens fÃ¸rstehjelpsutstyr (henting av utstyr avtales med utstyrsannsvarlig Stian pÃ¥ tlf 911 28 204).\n\nPÃ¥melding skjer til Merete ([mbhaukedal@gmail.com](mailto:mbhaukedal@gmail.com)) innen onsdag 16 oktober.\n\nTa gjerne kontakt hvis det er noen spÃ¸rsmÃ¥l.\n\nVi gleder oss til Ã¥ dra pÃ¥ tur med dere!!\n\nSpeiderhilsen fra lederne!\n";
				}
				function compiledContent$j() {
					return html$j;
				}
				function getHeadings$j() {
					return [{"depth":2,"slug":"pakkeliste","text":"Pakkeliste:"}];
				}
				async function Content$j() {
					const { layout, ...content } = frontmatter$j;
					content.file = file$j;
					content.url = url$j;
					const contentFragment = createVNode(Fragment, { 'set:html': html$j });
					return createVNode($$ArticleLayout, {
									file: file$j,
									url: url$j,
									content,
									frontmatter: content,
									headings: getHeadings$j(),
									rawContent: rawContent$j,
									compiledContent: compiledContent$j,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$j[Symbol.for('astro.needsHeadRendering')] = false;

const _page17 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$j,
  compiledContent: compiledContent$j,
  default: Content$j,
  file: file$j,
  frontmatter: frontmatter$j,
  getHeadings: getHeadings$j,
  images: images$j,
  rawContent: rawContent$j,
  url: url$j
}, Symbol.toStringTag, { value: 'Module' }));

const images$i = {
					
				};

				function updateImageReferences$i(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$i[imagePath].src, ...images$i[imagePath].attributes})
					);
				}

				const html$i = updateImageReferences$i("<p>Bli med pÃ¥ den morsomme konkurransen om Ã¥ bli Ã¥rets flagg- eller bannerpatrulje! Vinnerpatruljen fÃ¥r Ã¦ren av Ã¥ heise flagget pÃ¥ Hosle skole den 17. mai. HÃ¥per gamle og nye speidere Ã¸nsker Ã¥ vÃ¦re med!</p>\n<p>Dato: 10.-11. oktober<br>\nFor hvem: Alle i troppen<br>\nOppmÃ¸te: Se Spond eller mail<br>\nHenting: Se Spond eller mail<br>\nPÃ¥melding: PÃ¥ Spond<br>\n<br>\nPÃ¥ turen gÃ¥r vi i speiderskjerf(de som har)<br>\n<br>\nForslag til pakkeliste:</p>\n<ul>\n<li>Sovepose</li>\n<li>Liggeunderlag</li>\n<li>Uteligger/grevling (hvis du har)</li>\n<li>Varm ullgenser (det blir kaldt om kvelden)</li>\n<li>Ekstra par ullsokker</li>\n<li>Lue, votter og skjerf</li>\n<li>UllundertÃ¸y</li>\n<li>UndertÃ¸yskift</li>\n<li>Toalettsaker</li>\n<li>Ekstra skift</li>\n<li>RegntÃ¸y</li>\n<li>Kniv</li>\n<li>Lommelykt</li>\n<li>Fyrstikker</li>\n<li>Kopp, tallerken og bestikk</li>\n<li>Papir og blyant</li>\n<li>Personlig fÃ¸rstehjelp</li>\n<li>3 brÃ¸dmÃ¥ltider</li>\n<li>Middag som kan tilberedes pÃ¥ bÃ¥l eller med varmt vann</li>\n<li>Godteri til kvelden</li>\n<li>Ublandet saft, â€Rett i koppenâ€ e.l.</li>\n<li>Vannflaske med vann</li>\n<li>Haikebrett eller skjÃ¦refjÃ¸l (mÃ¥ vÃ¦re stor nok til at mat ikke faller pÃ¥ utsiden under matkonkurranse)</li>\n</ul>\n<p>Peffen har ansvar for Ã¥ ta med patruljeutstyr til konkurransen:<br>\nKompass, kartlomme, presenning, oppvaskbÃ¸rste, oppvasksÃ¥pe og tÃ¸rkehÃ¥ndkle, sÃ¸ppelsekk/poser til avfallssortering, surretau, primus/kokeapparat, sag/Ã¸ks og patruljens fÃ¸rstehjelpsutstyr<br>\n<br>\nHenting av utstyr avtales med utstyransvarlig Stian pÃ¥ tlf 911 28 204<br>\n<br>\nHvis det er noen spÃ¸rsmÃ¥l ta kontakt til Martin pÃ¥ mail (<a href=\"mailto:martin@nadderud.no\">martin@nadderud.no</a>) eller telefon (918 50 048)<br>\n<br>\nVi gleder oss til Ã¥ dra pÃ¥ tur med dere!<br>\n<br>\nSpeiderhilsen fra lederne!</p>");

				const frontmatter$i = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Troppskonk 10.-11. oktober","featuredimage":"/img/upload/skjermbilde-2020-09-27-kl.-23.19.49.png","description":"GjÃ¸r klar speiderkunskapen og konkurranseinstinktet til Ã¥rets fÃ¸rste speidertur, nemlig troppskonkuransen!","date":"2020-09-27T21:11:48.275Z","expireInDays":39,"tags":["Troppen"]};
				const file$i = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-09-27-troppskonk-10-11-oktober.md";
				const url$i = "/artikler/2020-09-27-troppskonk-10-11-oktober";
				function rawContent$i() {
					return "\nBli med pÃ¥ den morsomme konkurransen om Ã¥ bli Ã¥rets flagg- eller bannerpatrulje! Vinnerpatruljen fÃ¥r Ã¦ren av Ã¥ heise flagget pÃ¥ Hosle skole den 17. mai. HÃ¥per gamle og nye speidere Ã¸nsker Ã¥ vÃ¦re med!\n\nDato: 10.-11. oktober\\\nFor hvem: Alle i troppen\\\nOppmÃ¸te: Se Spond eller mail\\\nHenting: Se Spond eller mail\\\nPÃ¥melding: PÃ¥ Spond\\\n\\\nPÃ¥ turen gÃ¥r vi i speiderskjerf(de som har)\\\n\\\nForslag til pakkeliste:\n\n- Sovepose\n- Liggeunderlag\n- Uteligger/grevling (hvis du har)\n- Varm ullgenser (det blir kaldt om kvelden)\n- Ekstra par ullsokker\n- Lue, votter og skjerf\n- UllundertÃ¸y\n- UndertÃ¸yskift\n- Toalettsaker\n- Ekstra skift\n- RegntÃ¸y\n- Kniv\n- Lommelykt\n- Fyrstikker\n- Kopp, tallerken og bestikk\n- Papir og blyant\n- Personlig fÃ¸rstehjelp\n- 3 brÃ¸dmÃ¥ltider\n- Middag som kan tilberedes pÃ¥ bÃ¥l eller med varmt vann\n- Godteri til kvelden\n- Ublandet saft, â€Rett i koppenâ€ e.l.\n- Vannflaske med vann\n- Haikebrett eller skjÃ¦refjÃ¸l (mÃ¥ vÃ¦re stor nok til at mat ikke faller pÃ¥ utsiden under matkonkurranse)\n\nPeffen har ansvar for Ã¥ ta med patruljeutstyr til konkurransen:\\\nKompass, kartlomme, presenning, oppvaskbÃ¸rste, oppvasksÃ¥pe og tÃ¸rkehÃ¥ndkle, sÃ¸ppelsekk/poser til avfallssortering, surretau, primus/kokeapparat, sag/Ã¸ks og patruljens fÃ¸rstehjelpsutstyr\\\n\\\nHenting av utstyr avtales med utstyransvarlig Stian pÃ¥ tlf 911 28 204\\\n\\\nHvis det er noen spÃ¸rsmÃ¥l ta kontakt til Martin pÃ¥ mail ([martin@nadderud.no](mailto:martin@nadderud.no)) eller telefon (918 50 048)\\\n\\\nVi gleder oss til Ã¥ dra pÃ¥ tur med dere!\\\n\\\nSpeiderhilsen fra lederne!\n";
				}
				function compiledContent$i() {
					return html$i;
				}
				function getHeadings$i() {
					return [];
				}
				async function Content$i() {
					const { layout, ...content } = frontmatter$i;
					content.file = file$i;
					content.url = url$i;
					const contentFragment = createVNode(Fragment, { 'set:html': html$i });
					return createVNode($$ArticleLayout, {
									file: file$i,
									url: url$i,
									content,
									frontmatter: content,
									headings: getHeadings$i(),
									rawContent: rawContent$i,
									compiledContent: compiledContent$i,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$i[Symbol.for('astro.needsHeadRendering')] = false;

const _page18 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$i,
  compiledContent: compiledContent$i,
  default: Content$i,
  file: file$i,
  frontmatter: frontmatter$i,
  getHeadings: getHeadings$i,
  images: images$i,
  rawContent: rawContent$i,
  url: url$i
}, Symbol.toStringTag, { value: 'Module' }));

const images$h = {
					
				};

				function updateImageReferences$h(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$h[imagePath].src, ...images$h[imagePath].attributes})
					);
				}

				const html$h = updateImageReferences$h("<p>Vi er veldig glad for at vi har fÃ¥tt til Ã¥ gjennomfÃ¸re ulike speideraktiviteter den siste tiden, men mÃ¥ nÃ¥ dessverre stoppe inntil 11 april.</p>\n<p>Inntil videre Ã¸nsker vi dere en god vÃ¥r, nyt vÃ¥rsola og kom dere pÃ¥ tur! Anbefaler en tur til GrÃ¥magan (bildet) mellom nordre og sÃ¸ndre KolsÃ¥stopp.</p>\n<p>Takk til alle lederne, roverne og peffer og asser som har gjort en kjempejobb med Ã¥ legge til rette for gode aktiviteter utendÃ¸rs!</p>\n<p>Hilsen Merete, gruppeleder</p>");

				const frontmatter$h = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Nye koronarestriksjoner","featuredimage":"/img/upload/grÃ¥magan.jpg","description":"Etter nye koronarestriksjoner ser vi dessverre at vi mÃ¥ stoppe speideraktiviteter for en stund. Vi hÃ¥per pÃ¥ Ã¥ komme sterkere tilbake etter 11 april. ","date":"2021-03-15T20:23:32.776Z","expireInDays":60,"tags":["-"]};
				const file$h = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2021-03-15-nye-koronarestriksjoner.md";
				const url$h = "/artikler/2021-03-15-nye-koronarestriksjoner";
				function rawContent$h() {
					return "\nVi er veldig glad for at vi har fÃ¥tt til Ã¥ gjennomfÃ¸re ulike speideraktiviteter den siste tiden, men mÃ¥ nÃ¥ dessverre stoppe inntil 11 april.\n\nInntil videre Ã¸nsker vi dere en god vÃ¥r, nyt vÃ¥rsola og kom dere pÃ¥ tur! Anbefaler en tur til GrÃ¥magan (bildet) mellom nordre og sÃ¸ndre KolsÃ¥stopp.\n\nTakk til alle lederne, roverne og peffer og asser som har gjort en kjempejobb med Ã¥ legge til rette for gode aktiviteter utendÃ¸rs!\n\nHilsen Merete, gruppeleder\n";
				}
				function compiledContent$h() {
					return html$h;
				}
				function getHeadings$h() {
					return [];
				}
				async function Content$h() {
					const { layout, ...content } = frontmatter$h;
					content.file = file$h;
					content.url = url$h;
					const contentFragment = createVNode(Fragment, { 'set:html': html$h });
					return createVNode($$ArticleLayout, {
									file: file$h,
									url: url$h,
									content,
									frontmatter: content,
									headings: getHeadings$h(),
									rawContent: rawContent$h,
									compiledContent: compiledContent$h,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$h[Symbol.for('astro.needsHeadRendering')] = false;

const _page19 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$h,
  compiledContent: compiledContent$h,
  default: Content$h,
  file: file$h,
  frontmatter: frontmatter$h,
  getHeadings: getHeadings$h,
  images: images$h,
  rawContent: rawContent$h,
  url: url$h
}, Symbol.toStringTag, { value: 'Module' }));

const images$g = {
					
				};

				function updateImageReferences$g(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$g[imagePath].src, ...images$g[imagePath].attributes})
					);
				}

				const html$g = updateImageReferences$g("<p>Vi har denne hÃ¸sten endelig fÃ¥tt gjennomfÃ¸rt de fleste mÃ¸ter og turer som vi Ã¸nsker, og bÃ¥de flokk og tropp har vÃ¦rt pÃ¥ tur og er ellers mye ute. Dessverre mÃ¥tte vi avlyse vÃ¥r tradisjonsrike nissefest, men vi gleder oss til en ordentlig nissefest neste Ã¥r!</p>\n<p>Det har vÃ¦rt veldig gÃ¸y Ã¥ dele speiderminner med dere denne hÃ¸sten og vi ser frem til flere gode speiderminner til vÃ¥ren! Kos dere med julegodt, gaver, snÃ¸ og ellers alt som hÃ¸rer jula til, sÃ¥ gleder vi til Ã¥ se dere i januar!</p>\n<p>Speiderjulehilsen fra Nadderud speidergruppe.</p>");

				const frontmatter$g = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"God Jul og Godt nytt Ã¥r","featuredimage":"/img/upload/nisser.jpg","description":"Vi takker for Ã¥ret som har gÃ¥tt og Ã¸nsker dere alle god jul og godt nytt Ã¥r!","date":"2021-12-14T06:56:18.824Z","expireInDays":60,"tags":["Jul"]};
				const file$g = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2021-12-14-god-jul-og-godt-nytt-Ã¥r.md";
				const url$g = "/artikler/2021-12-14-god-jul-og-godt-nytt-Ã¥r";
				function rawContent$g() {
					return "\nVi har denne hÃ¸sten endelig fÃ¥tt gjennomfÃ¸rt de fleste mÃ¸ter og turer som vi Ã¸nsker, og bÃ¥de flokk og tropp har vÃ¦rt pÃ¥ tur og er ellers mye ute. Dessverre mÃ¥tte vi avlyse vÃ¥r tradisjonsrike nissefest, men vi gleder oss til en ordentlig nissefest neste Ã¥r!\n\nDet har vÃ¦rt veldig gÃ¸y Ã¥ dele speiderminner med dere denne hÃ¸sten og vi ser frem til flere gode speiderminner til vÃ¥ren! Kos dere med julegodt, gaver, snÃ¸ og ellers alt som hÃ¸rer jula til, sÃ¥ gleder vi til Ã¥ se dere i januar!\n\nSpeiderjulehilsen fra Nadderud speidergruppe.\n";
				}
				function compiledContent$g() {
					return html$g;
				}
				function getHeadings$g() {
					return [];
				}
				async function Content$g() {
					const { layout, ...content } = frontmatter$g;
					content.file = file$g;
					content.url = url$g;
					const contentFragment = createVNode(Fragment, { 'set:html': html$g });
					return createVNode($$ArticleLayout, {
									file: file$g,
									url: url$g,
									content,
									frontmatter: content,
									headings: getHeadings$g(),
									rawContent: rawContent$g,
									compiledContent: compiledContent$g,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$g[Symbol.for('astro.needsHeadRendering')] = false;

const _page20 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$g,
  compiledContent: compiledContent$g,
  default: Content$g,
  file: file$g,
  frontmatter: frontmatter$g,
  getHeadings: getHeadings$g,
  images: images$g,
  rawContent: rawContent$g,
  url: url$g
}, Symbol.toStringTag, { value: 'Module' }));

const images$f = {
					
				};

				function updateImageReferences$f(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$f[imagePath].src, ...images$f[imagePath].attributes})
					);
				}

				const html$f = updateImageReferences$f("<p>Lions Hosle-Eiksmarka stiller med meget bra utstyr, ordentlige biljekker og trykklufts-driller for Ã¥ skru muttere av og pÃ¥ bilene â€“ det eneste vi selv mÃ¥ stille med er arbeidshansker.</p>\n<p>Vi trenger 3 team Ã¡ 6 personer. Personene som stiller mÃ¥ vÃ¦re litt sterke og over 17 Ã¥r.</p>\n<p>Dette er en sosial og fin aktivitet hvor man mÃ¸ter mange hyggelige mennesker fra nÃ¦rmiljÃ¸et!</p>\n<p><strong>NÃ¥r kan DU stille?</strong></p>\n<ul>\n<li><strong>Team 1: lÃ¸rdag 31. Oktober kl. 09.00 til 12.00</strong></li>\n<li><strong>Team 2: lÃ¸rdag 31. Oktober kl. 12.00 til 15.00</strong></li>\n<li><strong>Team 3: sÃ¸ndag 1. November kl. 11.30 til 15.00</strong></li>\n</ul>\n<p><strong>Meld deg pÃ¥ med navn og telefonnummer til<a href=\"mailto:plankemann@hotmail.com\">berittheide@gmail.com</a>sÃ¥ fort som mulig.</strong></p>\n<p><strong>PÃ¥ vegne av foreldrerÃ¥det</strong></p>\n<p>Berit TennÃ¸y Heide</p>\n<p><a href=\"mailto:berittheide@gmail.com\">berittheide@gmail.com</a></p>\n<p>Tel.: 91 88 27 62</p>\n<p>Bildet er lÃ¥nt fra facebook-siden til Lion fra en tidligere hjulskiftaksjon.</p>");

				const frontmatter$f = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Ã…rets hjulskiftaksjon!","featuredimage":"/img/upload/hjulskift.jpg","description":"HÃ¸stens hjulskiftaksjon skjer lÃ¸rdag 31. Oktober og sÃ¸ndag 1. November i skolegÃ¥rden pÃ¥ Hosle skole.*\n\nNadderud Speidergruppe fortsetter det gode samarbeidet med Lions Hosle-Eiksmarka og pengene vi fÃ¥r fra Lions er et viktig bidrag til driften av speidergruppa og vedlikeholdet av Mason Hill.","date":"2020-10-06T20:44:48.504Z","expireInDays":60,"tags":["-"]};
				const file$f = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-10-06-Ã¥rets-hjulskiftaksjon.md";
				const url$f = "/artikler/2020-10-06-Ã¥rets-hjulskiftaksjon";
				function rawContent$f() {
					return "\nLions Hosle-Eiksmarka stiller med meget bra utstyr, ordentlige biljekker og trykklufts-driller for Ã¥ skru muttere av og pÃ¥ bilene â€“ det eneste vi selv mÃ¥ stille med er arbeidshansker.\n\nVi trenger 3 team Ã¡ 6 personer. Personene som stiller mÃ¥ vÃ¦re litt sterke og over 17 Ã¥r.\n\nDette er en sosial og fin aktivitet hvor man mÃ¸ter mange hyggelige mennesker fra nÃ¦rmiljÃ¸et!\n\n**NÃ¥r kan DU stille?**\n\n- **Team 1: lÃ¸rdag 31. Oktober kl. 09.00 til 12.00**\n- **Team 2: lÃ¸rdag 31. Oktober kl. 12.00 til 15.00**\n- **Team 3: sÃ¸ndag 1. November kl. 11.30 til 15.00**\n\n**Meld deg pÃ¥ med navn og telefonnummer til[berittheide@gmail.com](mailto:plankemann@hotmail.com)sÃ¥ fort som mulig.**\n\n**PÃ¥ vegne av foreldrerÃ¥det**\n\nBerit TennÃ¸y Heide\n\n[berittheide@gmail.com](mailto:berittheide@gmail.com)\n\nTel.: 91 88 27 62\n\nBildet er lÃ¥nt fra facebook-siden til Lion fra en tidligere hjulskiftaksjon.\n";
				}
				function compiledContent$f() {
					return html$f;
				}
				function getHeadings$f() {
					return [];
				}
				async function Content$f() {
					const { layout, ...content } = frontmatter$f;
					content.file = file$f;
					content.url = url$f;
					const contentFragment = createVNode(Fragment, { 'set:html': html$f });
					return createVNode($$ArticleLayout, {
									file: file$f,
									url: url$f,
									content,
									frontmatter: content,
									headings: getHeadings$f(),
									rawContent: rawContent$f,
									compiledContent: compiledContent$f,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$f[Symbol.for('astro.needsHeadRendering')] = false;

const _page21 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$f,
  compiledContent: compiledContent$f,
  default: Content$f,
  file: file$f,
  frontmatter: frontmatter$f,
  getHeadings: getHeadings$f,
  images: images$f,
  rawContent: rawContent$f,
  url: url$f
}, Symbol.toStringTag, { value: 'Module' }));

const images$e = {
					
				};

				function updateImageReferences$e(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$e[imagePath].src, ...images$e[imagePath].attributes})
					);
				}

				const html$e = updateImageReferences$e("<p>Vi har hatt enormt stor interesse fra tredje- og fjerdeklassinger i Ã¥r, og det setter vi veldig stor pris pÃ¥! Flokken teller i Ã¸yeblikket 35 medlemmer (fordelt pÃ¥ to kohorter), men flere enn det klarer vi ikke Ã¥ fÃ¸lge opp pÃ¥ en god mÃ¥te, verken pedagogisk eller smittevernmessig. Derfor har vi dessverre blitt nÃ¸dt til Ã¥ lage en venteliste for tredje- og fjerdeklassingene. Du kan fortsatt registrere barnet ditt under â€œBli speiderâ€, men barnet kan ikke regne med Ã¥ begynne med Ã©n gang. Isteden fÃ¥r han eller hun en plass pÃ¥ ventelista, og sÃ¥ tar vi kontakt sÃ¥ fort det blir en ledig plass i flokken.</p>");

				const frontmatter$e = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Venteliste i flokken","featuredimage":"/img/upload/pionering.jpg","description":"Flokken kan ikke ta inn flere speidere i Ã¸yeblikket, men du kan sette deg pÃ¥ venteliste.","date":"2020-10-06T09:25:55.465Z","expireInDays":87,"tags":["flokk"]};
				const file$e = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-10-06-venteliste-i-flokken.md";
				const url$e = "/artikler/2020-10-06-venteliste-i-flokken";
				function rawContent$e() {
					return "\nVi har hatt enormt stor interesse fra tredje- og fjerdeklassinger i Ã¥r, og det setter vi veldig stor pris pÃ¥! Flokken teller i Ã¸yeblikket 35 medlemmer (fordelt pÃ¥ to kohorter), men flere enn det klarer vi ikke Ã¥ fÃ¸lge opp pÃ¥ en god mÃ¥te, verken pedagogisk eller smittevernmessig. Derfor har vi dessverre blitt nÃ¸dt til Ã¥ lage en venteliste for tredje- og fjerdeklassingene. Du kan fortsatt registrere barnet ditt under \"Bli speider\", men barnet kan ikke regne med Ã¥ begynne med Ã©n gang. Isteden fÃ¥r han eller hun en plass pÃ¥ ventelista, og sÃ¥ tar vi kontakt sÃ¥ fort det blir en ledig plass i flokken.\n";
				}
				function compiledContent$e() {
					return html$e;
				}
				function getHeadings$e() {
					return [];
				}
				async function Content$e() {
					const { layout, ...content } = frontmatter$e;
					content.file = file$e;
					content.url = url$e;
					const contentFragment = createVNode(Fragment, { 'set:html': html$e });
					return createVNode($$ArticleLayout, {
									file: file$e,
									url: url$e,
									content,
									frontmatter: content,
									headings: getHeadings$e(),
									rawContent: rawContent$e,
									compiledContent: compiledContent$e,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$e[Symbol.for('astro.needsHeadRendering')] = false;

const _page22 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$e,
  compiledContent: compiledContent$e,
  default: Content$e,
  file: file$e,
  frontmatter: frontmatter$e,
  getHeadings: getHeadings$e,
  images: images$e,
  rawContent: rawContent$e,
  url: url$e
}, Symbol.toStringTag, { value: 'Module' }));

const images$d = {
					
				};

				function updateImageReferences$d(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$d[imagePath].src, ...images$d[imagePath].attributes})
					);
				}

				const html$d = updateImageReferences$d("<p>I den siste tiden har bÃ¥de Folkehelseinstituttet og BÃ¦rum kommune oppdatert sine koronainnstramninger. Norges speiderforbund har oppdatert sine retningslinjer i henhold til Fhi. Kommunen legger heldigvis ikke ytterligere fÃ¸ringer for aktiviteter for barn og unge,</p>\n<p>Vi kan fortsatt holde speidermÃ¸ter, men vi Ã¸nsker at alle bruker eget utstyr sÃ¥ langt det er mulig, spriter hender og holder avstand sÃ¥ godt de kan.</p>\n<p>Det er enda viktigere enn fÃ¸r at vi opererer med kohorter pÃ¥ maks 20 speidere fra start til slutt under mÃ¸tene. I en periode vil vi registrere hvem som deltar pÃ¥ hvert mÃ¸te, dette slettes lÃ¸pende.</p>\n<p>For flokken og troppen er det litt ulikt hvordan vi har valgt Ã¥ lÃ¸se dette.</p>\n<p>- I flokken er det vurdert at gruppa deles inn i to kohorter som har mÃ¸ter annenhver tirsdag, disse deles igjen inn i mindre faste grupper. Flokkleder sendte ut informasjon om dette sÃ¸ndag, ta kontakt med Yngve Benestad HÃ¥gvar dersom dere har ytterligere spÃ¸rsmÃ¥l, <a href=\"mailto:yngve.hagvar@gmail.com\">yngve.hagvar@gmail.com</a>.</p>\n<p>- For troppen har vi vurdert at vi ikke fÃ¥r til troppsmÃ¸ter hvor vi mÃ¸tes hele gruppa samlet, men vi fÃ¥r til Ã¥ avholde patruljemÃ¸ter i faste, mindre kohorter. Av samme grunn vil det ogsÃ¥ fortsatt vÃ¦re mulig Ã¥ gjennomfÃ¸re patruljeturer. Haslumseterturen vil vi prÃ¸ve Ã¥ gjennomfÃ¸re som en dagstur. Dersom noen har spÃ¸rsmÃ¥l til troppen kan dere ta kontakt med Martin Clementz, <a href=\"mailto:martin@nadderud.no\">martin@nadderud.no</a>.</p>\n<p>Vi hÃ¥per vi kan holde juleavslutning som vi pleier, men vil komme tilbake til dette ved et senere tidspunkt.</p>\n<p>Vi Ã¸nsker at speidere med forkjÃ¸lelsessymptomer stÃ¥r over speideraktiviteter inntil de er friske nok til Ã¥ dra pÃ¥ skolen.</p>\n<p>Vi setter stor pris pÃ¥ det gode samarbeidet med dere denne perioden og hÃ¥per pÃ¥ Ã¥ kunne drive speideraktiviteter som normalt sÃ¥ fort som mulig.</p>\n<p>Bare ta kontakt dersom dere har spÃ¸rsmÃ¥l.</p>\n<p>Hilsen lederne for flokken, troppen og roverlaget.</p>\n<p>Merete Haukedal, gruppeleder</p>");

				const frontmatter$d = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Speiding i koronatid","featuredimage":"/img/upload/sauejordet.jpg","description":"Det er en vanskelig tid Ã¥ drive speiding som vi Ã¸nsker for tiden, men vi fortsetter med de aktivitetene vi vurderer er iht. retningslinjer for smittevern. ","date":"2020-11-10T14:49:01.997Z","expireInDays":60,"tags":["-"]};
				const file$d = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-11-10-speiding-i-koronatid.md";
				const url$d = "/artikler/2020-11-10-speiding-i-koronatid";
				function rawContent$d() {
					return "\nI den siste tiden har bÃ¥de Folkehelseinstituttet og BÃ¦rum kommune oppdatert sine koronainnstramninger. Norges speiderforbund har oppdatert sine retningslinjer i henhold til Fhi. Kommunen legger heldigvis ikke ytterligere fÃ¸ringer for aktiviteter for barn og unge,\n\nVi kan fortsatt holde speidermÃ¸ter, men vi Ã¸nsker at alle bruker eget utstyr sÃ¥ langt det er mulig, spriter hender og holder avstand sÃ¥ godt de kan.\n\nDet er enda viktigere enn fÃ¸r at vi opererer med kohorter pÃ¥ maks 20 speidere fra start til slutt under mÃ¸tene. I en periode vil vi registrere hvem som deltar pÃ¥ hvert mÃ¸te, dette slettes lÃ¸pende.\n\nFor flokken og troppen er det litt ulikt hvordan vi har valgt Ã¥ lÃ¸se dette.\n\n\\- I flokken er det vurdert at gruppa deles inn i to kohorter som har mÃ¸ter annenhver tirsdag, disse deles igjen inn i mindre faste grupper. Flokkleder sendte ut informasjon om dette sÃ¸ndag, ta kontakt med Yngve Benestad HÃ¥gvar dersom dere har ytterligere spÃ¸rsmÃ¥l, yngve.hagvar@gmail.com.\n\n\\- For troppen har vi vurdert at vi ikke fÃ¥r til troppsmÃ¸ter hvor vi mÃ¸tes hele gruppa samlet, men vi fÃ¥r til Ã¥ avholde patruljemÃ¸ter i faste, mindre kohorter. Av samme grunn vil det ogsÃ¥ fortsatt vÃ¦re mulig Ã¥ gjennomfÃ¸re patruljeturer. Haslumseterturen vil vi prÃ¸ve Ã¥ gjennomfÃ¸re som en dagstur. Dersom noen har spÃ¸rsmÃ¥l til troppen kan dere ta kontakt med Martin Clementz, martin@nadderud.no.\n\nVi hÃ¥per vi kan holde juleavslutning som vi pleier, men vil komme tilbake til dette ved et senere tidspunkt.\n\nVi Ã¸nsker at speidere med forkjÃ¸lelsessymptomer stÃ¥r over speideraktiviteter inntil de er friske nok til Ã¥ dra pÃ¥ skolen.\n\nVi setter stor pris pÃ¥ det gode samarbeidet med dere denne perioden og hÃ¥per pÃ¥ Ã¥ kunne drive speideraktiviteter som normalt sÃ¥ fort som mulig.\n\nBare ta kontakt dersom dere har spÃ¸rsmÃ¥l.\n\nHilsen lederne for flokken, troppen og roverlaget.\n\nMerete Haukedal, gruppeleder\n";
				}
				function compiledContent$d() {
					return html$d;
				}
				function getHeadings$d() {
					return [];
				}
				async function Content$d() {
					const { layout, ...content } = frontmatter$d;
					content.file = file$d;
					content.url = url$d;
					const contentFragment = createVNode(Fragment, { 'set:html': html$d });
					return createVNode($$ArticleLayout, {
									file: file$d,
									url: url$d,
									content,
									frontmatter: content,
									headings: getHeadings$d(),
									rawContent: rawContent$d,
									compiledContent: compiledContent$d,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$d[Symbol.for('astro.needsHeadRendering')] = false;

const _page23 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$d,
  compiledContent: compiledContent$d,
  default: Content$d,
  file: file$d,
  frontmatter: frontmatter$d,
  getHeadings: getHeadings$d,
  images: images$d,
  rawContent: rawContent$d,
  url: url$d
}, Symbol.toStringTag, { value: 'Module' }));

const images$c = {
					
				};

				function updateImageReferences$c(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$c[imagePath].src, ...images$c[imagePath].attributes})
					);
				}

				const html$c = updateImageReferences$c("<p>Men selv om vi ikke kan mÃ¸tes er det likevel mulig Ã¥ gjennomfÃ¸re speideraktiviteter. Ta med deg familien pÃ¥ tur i skogen og vis dem hvordan man lager bÃ¥l eller setter opp gapahuk!</p>\n<p>Det er ogsÃ¥ fortsatt mulig Ã¥ ta koronamerket, flere av speiderne i troppen tok dette i fjor vÃ¥r. Merket kan fint tas hjemme og bekreftes av forelder til leder nÃ¥r merket er gjennomfÃ¸rt.</p>\n<p>Se: <a href=\"https://speiding.no/speiderprogram/speiderbasen/korona-dugnad-fordypningsmerke-alle-enheter\">https://speiding.no/speiderprogram/speiderbasen/korona-dugnad-fordypningsmerke-alle-enheter</a></p>\n<p>Det er ogsÃ¥ mulig at din leder finner pÃ¥ noe morsomt opplegg pÃ¥ facebook (flokken) eller pÃ¥ spond (troppen/roverlag)!</p>\n<p>Vi hÃ¥per Ã¥ se dere igjen sÃ¥ snart som mulig.</p>\n<p>Hilsen lederne</p>");

				const frontmatter$c = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Speiding i koronatid","featuredimage":"/img/upload/koronamerket.jpg","description":"Etter pressekonferansen mandag ser vi dessverre ingen annen lÃ¸sning enn Ã¥ avlyse alle speidermÃ¸ter frem til 18 januar. Dette vil gjelde for alle enheter, bÃ¥de flokken, troppen og roverlaget. Vi vil sende ut ny informasjon etter 18 januar. ","date":"2021-01-04T20:38:14.684Z","expireInDays":60,"tags":["-"]};
				const file$c = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2021-01-04-speiding-i-koronatid.md";
				const url$c = "/artikler/2021-01-04-speiding-i-koronatid";
				function rawContent$c() {
					return "\nMen selv om vi ikke kan mÃ¸tes er det likevel mulig Ã¥ gjennomfÃ¸re speideraktiviteter. Ta med deg familien pÃ¥ tur i skogen og vis dem hvordan man lager bÃ¥l eller setter opp gapahuk!\n\nDet er ogsÃ¥ fortsatt mulig Ã¥ ta koronamerket, flere av speiderne i troppen tok dette i fjor vÃ¥r. Merket kan fint tas hjemme og bekreftes av forelder til leder nÃ¥r merket er gjennomfÃ¸rt.\n\nSe: https://speiding.no/speiderprogram/speiderbasen/korona-dugnad-fordypningsmerke-alle-enheter\n\nDet er ogsÃ¥ mulig at din leder finner pÃ¥ noe morsomt opplegg pÃ¥ facebook (flokken) eller pÃ¥ spond (troppen/roverlag)!\n\nVi hÃ¥per Ã¥ se dere igjen sÃ¥ snart som mulig.\n\nHilsen lederne\n";
				}
				function compiledContent$c() {
					return html$c;
				}
				function getHeadings$c() {
					return [];
				}
				async function Content$c() {
					const { layout, ...content } = frontmatter$c;
					content.file = file$c;
					content.url = url$c;
					const contentFragment = createVNode(Fragment, { 'set:html': html$c });
					return createVNode($$ArticleLayout, {
									file: file$c,
									url: url$c,
									content,
									frontmatter: content,
									headings: getHeadings$c(),
									rawContent: rawContent$c,
									compiledContent: compiledContent$c,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$c[Symbol.for('astro.needsHeadRendering')] = false;

const _page24 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$c,
  compiledContent: compiledContent$c,
  default: Content$c,
  file: file$c,
  frontmatter: frontmatter$c,
  getHeadings: getHeadings$c,
  images: images$c,
  rawContent: rawContent$c,
  url: url$c
}, Symbol.toStringTag, { value: 'Module' }));

const images$b = {
					
				};

				function updateImageReferences$b(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$b[imagePath].src, ...images$b[imagePath].attributes})
					);
				}

				const html$b = updateImageReferences$b("<p>Vi minner om at det vil vÃ¦re viktig Ã¥ ha to meters avstand, og vi hÃ¥per derfor dere fordeler dere godt utover denne tiden. Dersom det blir mange pÃ¥ en gang fÃ¥r vi lage kÃ¸ pÃ¥ parkeringsplassen:)</p>\n<p>Vi sees!</p>\n<p>Hilsen fÃ¸rerpatrulja og lederne.</p>");

				const frontmatter$b = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Speideroverraskelse!","featuredimage":"/img/upload/sauejordet.jpg","description":"KjÃ¦re speidere og foreldre! \n\nDet er dessverre fortsatt ikke forsvarlig Ã¥ holde speidermÃ¸ter enda, men vi har ikke glemt dere! FÃ¸rstkommende mandag, 4. mai, Ã¸nsker vi Ã¥ gi alle speiderne en liten speideroverraskelse. MÃ¸t opp pÃ¥ speiderhuset en gang mellom kl. 18 og 19, slÃ¥ av en kort prat med en speiderleder eller kanskje en peff/ass og fÃ¥ med en liten overraskelse hjem! \n\nVi minner om at det vil vÃ¦re viktig Ã¥ ha to meters avstand, og vi hÃ¥per derfor dere fordeler dere godt utover denne tiden. Dersom det blir mange pÃ¥ en gang fÃ¥r vi lage kÃ¸ pÃ¥ parkeringsplassen:)\n\nVi sees!\n\nHilsen fÃ¸rerpatrulja og lederne.","date":"2020-04-28T14:21:11.404Z","expireInDays":60,"tags":["."]};
				const file$b = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-04-28-speideroverraskelse.md";
				const url$b = "/artikler/2020-04-28-speideroverraskelse";
				function rawContent$b() {
					return "\nVi minner om at det vil vÃ¦re viktig Ã¥ ha to meters avstand, og vi hÃ¥per derfor dere fordeler dere godt utover denne tiden. Dersom det blir mange pÃ¥ en gang fÃ¥r vi lage kÃ¸ pÃ¥ parkeringsplassen:)\n\nVi sees!\n\nHilsen fÃ¸rerpatrulja og lederne.\n";
				}
				function compiledContent$b() {
					return html$b;
				}
				function getHeadings$b() {
					return [];
				}
				async function Content$b() {
					const { layout, ...content } = frontmatter$b;
					content.file = file$b;
					content.url = url$b;
					const contentFragment = createVNode(Fragment, { 'set:html': html$b });
					return createVNode($$ArticleLayout, {
									file: file$b,
									url: url$b,
									content,
									frontmatter: content,
									headings: getHeadings$b(),
									rawContent: rawContent$b,
									compiledContent: compiledContent$b,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$b[Symbol.for('astro.needsHeadRendering')] = false;

const _page25 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$b,
  compiledContent: compiledContent$b,
  default: Content$b,
  file: file$b,
  frontmatter: frontmatter$b,
  getHeadings: getHeadings$b,
  images: images$b,
  rawContent: rawContent$b,
  url: url$b
}, Symbol.toStringTag, { value: 'Module' }));

const images$a = {
					
				};

				function updateImageReferences$a(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$a[imagePath].src, ...images$a[imagePath].attributes})
					);
				}

				const html$a = updateImageReferences$a("<p><strong>MÃ¸tet vil foregÃ¥ pÃ¥ Teams. Bli med fra datamaskin eller mobilapp</strong></p>\n<p><a href=\"https://teams.microsoft.com/l/meetup-join/19%3ameeting_OTFkZWEzY2MtNTkwNC00ZGU2LTlhZDYtYTg4ZGE2ZDg1MTYw%40thread.v2/0?context=%7b%22Tid%22%3a%2296d3f1be-d534-4dd8-a05a-7a86a0fc11b0%22%2c%22Oid%22%3a%225702ba5d-0078-4d04-af81-8cdbbcd1db54%22%7d\">Klikk her for Ã¥ bli med pÃ¥ mÃ¸tet</a></p>\n<p>Dette er agendaen pÃ¥ Ã¥rsmÃ¸tet. Hvis det er noe dere Ã¸nsker Ã¥ ta opp, send melding eller mail til Merete.</p>\n<ol>\n<li>\n<p><strong>Konstituering</strong></p>\n<ol>\n<li>Valg av mÃ¸teleder</li>\n<li>Valg av referent og to representanter til Ã¥ underskrive protokollen</li>\n<li>Godkjenning av innkalling og saksliste</li>\n</ol>\n</li>\n<li>\n<p><strong><a href=\"https://drive.google.com/file/d/1d8clS6y3AFdEkoERjD1PtYHs9ieznXEe/view?usp=sharing\">Ã…rsmelding 2020</a></strong><br>\nGruppestyrets Ã¥rsmelding legges fram for godkjenning. Rapport fra enhetene og Mason Hill.</p>\n</li>\n<li>\n<p><strong><a href=\"https://drive.google.com/file/d/1UvgEcj0ED3yjraZmreXMdFoHX_kkjmKU/view?usp=sharing\">Regnskap 2020</a></strong><br>\nRegnskap legges fram for godkjenning.</p>\n</li>\n<li>\n<p><strong>Eventuelt</strong></p>\n</li>\n<li>\n<p><strong><a href=\"https://drive.google.com/file/d/1jp_5f6XHPOVAv8kN8cWytmEMC8ekngiO/view?usp=sharing\">Budsjett 2022</a></strong><br>\nForslag til budsjett for neste Ã¥r.</p>\n</li>\n<li>\n<p><strong>Valg</strong></p>\n<ol>\n<li>Styremedlem (for to Ã¥r)</li>\n<li>Styremedlem (for to Ã¥r)</li>\n<li>Representanter til kretsting (10 representanter, for ett Ã¥r)</li>\n<li>Kasserer (for ett Ã¥r)</li>\n<li>Revisor (for ett Ã¥r)</li>\n<li>ForeldrerÃ¥d (5 representanter, for ett Ã¥r)</li>\n</ol>\n</li>\n</ol>");

				const frontmatter$a = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Ã…rsmÃ¸te 31. mai 2021","featuredimage":"/img/upload/flagg.jpeg","description":"Snart er det Ã¥rsmÃ¸te! Her finner dere Ã¥rsmeldingen fra 2020, regnskap, og videre budsjett for 2022. BÃ¥de speidere og foreldre oppfordres til Ã¥ vÃ¦re med!","date":"2021-05-13T11:14:12.427Z","expireInDays":60,"tags":["alle"]};
				const file$a = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2021-05-13-Ã¥rsmÃ¸te-31-mai-2021.md";
				const url$a = "/artikler/2021-05-13-Ã¥rsmÃ¸te-31-mai-2021";
				function rawContent$a() {
					return "\n**MÃ¸tet vil foregÃ¥ pÃ¥ Teams. Bli med fra datamaskin eller mobilapp**\n\n[Klikk her for Ã¥ bli med pÃ¥ mÃ¸tet](https://teams.microsoft.com/l/meetup-join/19%3ameeting_OTFkZWEzY2MtNTkwNC00ZGU2LTlhZDYtYTg4ZGE2ZDg1MTYw%40thread.v2/0?context=%7b%22Tid%22%3a%2296d3f1be-d534-4dd8-a05a-7a86a0fc11b0%22%2c%22Oid%22%3a%225702ba5d-0078-4d04-af81-8cdbbcd1db54%22%7d)\n\nDette er agendaen pÃ¥ Ã¥rsmÃ¸tet. Hvis det er noe dere Ã¸nsker Ã¥ ta opp, send melding eller mail til Merete.\n\n1. **Konstituering**\n\n   1. Valg av mÃ¸teleder\n   2. Valg av referent og to representanter til Ã¥ underskrive protokollen\n   3. Godkjenning av innkalling og saksliste\n\n2. **[Ã…rsmelding 2020](https://drive.google.com/file/d/1d8clS6y3AFdEkoERjD1PtYHs9ieznXEe/view?usp=sharing)**\\\n   Gruppestyrets Ã¥rsmelding legges fram for godkjenning. Rapport fra enhetene og Mason Hill.\n3. **[Regnskap 2020](https://drive.google.com/file/d/1UvgEcj0ED3yjraZmreXMdFoHX_kkjmKU/view?usp=sharing)**\\\n   Regnskap legges fram for godkjenning.\n4. **Eventuelt**\n5. **[Budsjett 2022](https://drive.google.com/file/d/1jp_5f6XHPOVAv8kN8cWytmEMC8ekngiO/view?usp=sharing)**\\\n   Forslag til budsjett for neste Ã¥r.\n6. **Valg**\n\n   1. Styremedlem (for to Ã¥r)\n   2. Styremedlem (for to Ã¥r)\n   3. Representanter til kretsting (10 representanter, for ett Ã¥r)\n   4. Kasserer (for ett Ã¥r)\n   5. Revisor (for ett Ã¥r)\n   6. ForeldrerÃ¥d (5 representanter, for ett Ã¥r)\n";
				}
				function compiledContent$a() {
					return html$a;
				}
				function getHeadings$a() {
					return [];
				}
				async function Content$a() {
					const { layout, ...content } = frontmatter$a;
					content.file = file$a;
					content.url = url$a;
					const contentFragment = createVNode(Fragment, { 'set:html': html$a });
					return createVNode($$ArticleLayout, {
									file: file$a,
									url: url$a,
									content,
									frontmatter: content,
									headings: getHeadings$a(),
									rawContent: rawContent$a,
									compiledContent: compiledContent$a,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$a[Symbol.for('astro.needsHeadRendering')] = false;

const _page26 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$a,
  compiledContent: compiledContent$a,
  default: Content$a,
  file: file$a,
  frontmatter: frontmatter$a,
  getHeadings: getHeadings$a,
  images: images$a,
  rawContent: rawContent$a,
  url: url$a
}, Symbol.toStringTag, { value: 'Module' }));

const images$9 = {
					
				};

				function updateImageReferences$9(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$9[imagePath].src, ...images$9[imagePath].attributes})
					);
				}

				const html$9 = updateImageReferences$9("<p>OppmÃ¸te og sted: se arrangementet pÃ¥ Spond</p>\n<p>For Ã¥ gjennomfÃ¸re turen trenger vi bÃ¥de foreldre som kan kjÃ¸re og hente, samt en bil med hengerfeste til kano-hengeren. Gi beskjed hvis dere har ekstra plasser i bilen, slik at speidere som Ã¸nsker Ã¥ bli med uten muligheten til Ã¥ kjÃ¸re kan bli med. I tillegg kan du sende beskjed hvis dere har bil med hengerfeste og kan tenke Ã¥ kjÃ¸re kanohengeren vÃ¥r.</p>\n<p>Patruljeutstyr: Kompass, presenning, surretau og patruljens fÃ¸rstehjelpsutstyr. Eventuelt primus (hvis dere vil). Ring utstyrsansvarlig Stian pÃ¥ telefon 911 28 204 for Ã¥ avtale henting av utstyr.</p>\n<h1 id=\"husk-redningsvest\">!!!HUSK redningsvest!!!</h1>\n<p>Vel mÃ¸tt!</p>\n<p>â€”â€”â€”</p>\n<p>Veibeskrivelse</p>\n<p><a href=\"https://www.google.no/maps/dir/%C3%98ygardveien+49A,+1357+Bekkestua/60.4318056,10.2738333/@60.1725318,10.1476195,116056m/am=t/data=!3m2!1e3!4b1!4m8!4m7!1m5!1m1!1s0x46416cd61d0f6097:0xe26c2936136078b!2m2!1d10.5884322!2d59.9250535!1m0?hl=no\">google.no/maps/dir/Ã˜ygardveien+49A,+1357+Bekkestua/60.4318056,10.2738333/@60.1725318,10.1476195,116056m/am=t/data=!3m2!1e3!4b1!4m8!4m7!1m5!1m1!1s0x46416cd61d0f6097:0xe26c2936136078b!2m2!1d10.5884322!2d59.9250535!1m0?hl=no</a></p>");

				const frontmatter$9 = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Kanotur pÃ¥ Fjorda!","featuredimage":"/img/upload/20190608_153548.jpg","description":"Klar for en knallstart pÃ¥ sommeren? Det er endelig til for kanotur, der vi padler gjennom eldoradoet Fjorda pÃ¥ Hadeland. Flott vÃ¦r og varmt vann er bestilt, sÃ¥ ta med badedrakt og bli med!","date":"2021-05-30T09:07:25.342Z","expireInDays":60,"tags":["troppen"]};
				const file$9 = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2021-05-30-kanotur-pÃ¥-fjorda.md";
				const url$9 = "/artikler/2021-05-30-kanotur-pÃ¥-fjorda";
				function rawContent$9() {
					return "\nOppmÃ¸te og sted: se arrangementet pÃ¥ Spond\n\nFor Ã¥ gjennomfÃ¸re turen trenger vi bÃ¥de foreldre som kan kjÃ¸re og hente, samt en bil med hengerfeste til kano-hengeren. Gi beskjed hvis dere har ekstra plasser i bilen, slik at speidere som Ã¸nsker Ã¥ bli med uten muligheten til Ã¥ kjÃ¸re kan bli med. I tillegg kan du sende beskjed hvis dere har bil med hengerfeste og kan tenke Ã¥ kjÃ¸re kanohengeren vÃ¥r.\n\nPatruljeutstyr: Kompass, presenning, surretau og patruljens fÃ¸rstehjelpsutstyr. Eventuelt primus (hvis dere vil). Ring utstyrsansvarlig Stian pÃ¥ telefon 911 28 204 for Ã¥ avtale henting av utstyr.\n\n# !!!HUSK redningsvest!!!\n\nVel mÃ¸tt!\n\nâ€”â€”â€”\n\nVeibeskrivelse\n\n[google.no/maps/dir/Ã˜ygardveien+49A,+1357+Bekkestua/60.4318056,10.2738333/@60.1725318,10.1476195,116056m/am=t/data=!3m2!1e3!4b1!4m8!4m7!1m5!1m1!1s0x46416cd61d0f6097:0xe26c2936136078b!2m2!1d10.5884322!2d59.9250535!1m0?hl=no](https://www.google.no/maps/dir/%C3%98ygardveien+49A,+1357+Bekkestua/60.4318056,10.2738333/@60.1725318,10.1476195,116056m/am=t/data=!3m2!1e3!4b1!4m8!4m7!1m5!1m1!1s0x46416cd61d0f6097:0xe26c2936136078b!2m2!1d10.5884322!2d59.9250535!1m0?hl=no)\n";
				}
				function compiledContent$9() {
					return html$9;
				}
				function getHeadings$9() {
					return [{"depth":1,"slug":"husk-redningsvest","text":"!!!HUSK redningsvest!!!"}];
				}
				async function Content$9() {
					const { layout, ...content } = frontmatter$9;
					content.file = file$9;
					content.url = url$9;
					const contentFragment = createVNode(Fragment, { 'set:html': html$9 });
					return createVNode($$ArticleLayout, {
									file: file$9,
									url: url$9,
									content,
									frontmatter: content,
									headings: getHeadings$9(),
									rawContent: rawContent$9,
									compiledContent: compiledContent$9,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$9[Symbol.for('astro.needsHeadRendering')] = false;

const _page27 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$9,
  compiledContent: compiledContent$9,
  default: Content$9,
  file: file$9,
  frontmatter: frontmatter$9,
  getHeadings: getHeadings$9,
  images: images$9,
  rawContent: rawContent$9,
  url: url$9
}, Symbol.toStringTag, { value: 'Module' }));

const images$8 = {
					
				};

				function updateImageReferences$8(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$8[imagePath].src, ...images$8[imagePath].attributes})
					);
				}

				const html$8 = updateImageReferences$8("<p>Turen starter pÃ¥ Skytterkollen kl. 11:00 lÃ¸rdag, og slutter samme sted kl. 15:00 pÃ¥ sÃ¸ndag.</p>\n<p>Haslumseter kapell er et koselig sted utstyrt med strÃ¸m og vann, spill og gitar og piano for maks god stemning. Det er store soverom med madrasser og senger til alle. Det er ogsÃ¥ en kiosk, der det er mulighet for Ã¥ kjÃ¸pe noe digg pÃ¥ kvelden.</p>\n<p>Klokka 12 pÃ¥ sÃ¸ndag er det gudstjeneste i kapellet. Foreldre, familie og venner er velkommen opp til denne. EtterpÃ¥ blir det salg av vafler og kaffe.</p>\n<p>Spennende program er under utarbeidelse!</p>\n<p>Vi drar i turklÃ¦r og speiderskjerf. Husk varme klÃ¦r. Det er en god idÃ© Ã¥ pakke i poser i sekken, slik at ting ikke blir vÃ¥te. Ta gjerne med speiderskjorta.</p>\n<p>Pakkeliste:</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #0d1117; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Sovepose</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Varm ullgenser</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Ekstra par ullsokker</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Lue, votter og skjerf</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ UllundertÃ¸y</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ UndertÃ¸yskift</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Toalettsaker</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Ekstra skift</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ RegntÃ¸y</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Spikke-kniv</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Lommelykt/hodelykt</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Fyrstikker</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Nadderud-sangbok (kan kjÃ¸pes i kiosken for 20 kr)</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Kopp, tallerken og bestikk</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Papir og blyant</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Personlig fÃ¸rstehjelp</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Minst 3 brÃ¸dmÃ¥ltider</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Egen middag (tilbedes pÃ¥ primus eller bÃ¥l, avtal gjerne i patruljen)</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Godteri til kvelden</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Ublandet saft,â€ Rett i koppenâ€ e.l.</span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\"></span></span>\n<span class=\"line\"><span style=\"color: #c9d1d9\">â€¢ Litt lommepenger til kiosken</span></span></code></pre>\n<p>Patruljeutstyr: Kokeapparat og fÃ¸rstehjelpsutstyr.</p>\n<p>PÃ¥melding innen tirsdag 12.november til Stian pÃ¥ mail til <a href=\"mailto:stian@nadderud.no\">stian@nadderud.no</a>. SpÃ¸rsmÃ¥l? Ta kontakt pÃ¥ mail eller mobil(911 28 204)</p>");

				const frontmatter$8 = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Haslumseter-tur","date":"2019-11-13T20:09:21.449Z","description":"16.-17. november er det tur for hele troppen til Haslumseter kapell!","featuredimage":"/img/upload/haslumseter_kpl2.jpg","expireInDays":60,"tags":["troppen"]};
				const file$8 = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2019-11-13-haslumseter-tur.md";
				const url$8 = "/artikler/2019-11-13-haslumseter-tur";
				function rawContent$8() {
					return "\nTuren starter pÃ¥ Skytterkollen kl. 11:00 lÃ¸rdag, og slutter samme sted kl. 15:00 pÃ¥ sÃ¸ndag.\n\nHaslumseter kapell er et koselig sted utstyrt med strÃ¸m og vann, spill og gitar og piano for maks god stemning. Det er store soverom med madrasser og senger til alle. Det er ogsÃ¥ en kiosk, der det er mulighet for Ã¥ kjÃ¸pe noe digg pÃ¥ kvelden.\n\nKlokka 12 pÃ¥ sÃ¸ndag er det gudstjeneste i kapellet. Foreldre, familie og venner er velkommen opp til denne. EtterpÃ¥ blir det salg av vafler og kaffe.\n\nSpennende program er under utarbeidelse!\n\nVi drar i turklÃ¦r og speiderskjerf. Husk varme klÃ¦r. Det er en god idÃ© Ã¥ pakke i poser i sekken, slik at ting ikke blir vÃ¥te. Ta gjerne med speiderskjorta.\n\nPakkeliste:\n\n    â€¢ Sovepose\n\n    â€¢ Varm ullgenser\n\n    â€¢ Ekstra par ullsokker\n\n    â€¢ Lue, votter og skjerf\n\n    â€¢ UllundertÃ¸y\n\n    â€¢ UndertÃ¸yskift\n\n    â€¢ Toalettsaker\n\n    â€¢ Ekstra skift\n\n    â€¢ RegntÃ¸y\n\n    â€¢ Spikke-kniv\n\n    â€¢ Lommelykt/hodelykt\n\n    â€¢ Fyrstikker\n\n    â€¢ Nadderud-sangbok (kan kjÃ¸pes i kiosken for 20 kr)\n\n    â€¢ Kopp, tallerken og bestikk\n\n    â€¢ Papir og blyant\n\n    â€¢ Personlig fÃ¸rstehjelp\n\n    â€¢ Minst 3 brÃ¸dmÃ¥ltider\n\n    â€¢ Egen middag (tilbedes pÃ¥ primus eller bÃ¥l, avtal gjerne i patruljen)\n\n    â€¢ Godteri til kvelden\n\n    â€¢ Ublandet saft,â€ Rett i koppenâ€ e.l.\n\n    â€¢ Litt lommepenger til kiosken\n\nPatruljeutstyr: Kokeapparat og fÃ¸rstehjelpsutstyr.\n\nPÃ¥melding innen tirsdag 12.november til Stian pÃ¥ mail til stian@nadderud.no. SpÃ¸rsmÃ¥l? Ta kontakt pÃ¥ mail eller mobil(911 28 204)\n";
				}
				function compiledContent$8() {
					return html$8;
				}
				function getHeadings$8() {
					return [];
				}
				async function Content$8() {
					const { layout, ...content } = frontmatter$8;
					content.file = file$8;
					content.url = url$8;
					const contentFragment = createVNode(Fragment, { 'set:html': html$8 });
					return createVNode($$ArticleLayout, {
									file: file$8,
									url: url$8,
									content,
									frontmatter: content,
									headings: getHeadings$8(),
									rawContent: rawContent$8,
									compiledContent: compiledContent$8,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$8[Symbol.for('astro.needsHeadRendering')] = false;

const _page28 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$8,
  compiledContent: compiledContent$8,
  default: Content$8,
  file: file$8,
  frontmatter: frontmatter$8,
  getHeadings: getHeadings$8,
  images: images$8,
  rawContent: rawContent$8,
  url: url$8
}, Symbol.toStringTag, { value: 'Module' }));

const images$7 = {
					
				};

				function updateImageReferences$7(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$7[imagePath].src, ...images$7[imagePath].attributes})
					);
				}

				const html$7 = updateImageReferences$7("<p>ChiafrÃ¸ kan ogsÃ¥ spires, slik som karse. Det minner om karse, men de er litt stÃ¸rre i bladene. ChiafrÃ¸ er veldig rik pÃ¥ Omega-3-fettsyrer og har masse antioksidanter, mineraler og vitaminer i seg. Resultatet gir en frisk smak. Pass bare pÃ¥ at chiafrÃ¸ene ikke fÃ¥r for mye vann, ellers drukner de veldig lett. Bruk derfor en liten skÃ¥l nÃ¥r chiafrÃ¸ene skal dyrkes.</p>\n<h3 id=\"utstyr\">Utstyr</h3>\n<ul>\n<li>ChiafrÃ¸ - <em>Vann i sprayflaske -</em> SkÃ¥l - <em>Sil/bakepapir -</em> Eventuelt jord -* Eventuelt gaffel</li>\n</ul>\n<h3 id=\"framgangsmÃ¥te-uten-jord\">FramgangsmÃ¥te (uten jord)</h3>\n<p>- <em>BlÃ¸tlegg frÃ¸ene, og la de ligge i vann i 5-10 minutter. -</em> Finn fram en sil, og hvis det ikke er tilgjengelig, lag mange hull med en gaffel i bakepapir eller liknende. - <em>Putt sÃ¥ frÃ¸ene oppÃ¥ bakepapiret/silen uten at frÃ¸ene ligger oppÃ¥ hverandre. -</em> Putt sÃ¥ bakepapiret/silen med frÃ¸ene oppÃ¥ den lille skÃ¥len. - <em>Dekk skÃ¥len til, slik at frÃ¸ene ikke tÃ¸rker ut pga. lys. -</em> Dusj frÃ¸ene 2 ganger om dagen med en sprayflaske, slik at spirene er fuktige. - <em>Etter 2 dager med tildekking, kan skÃ¥len stÃ¥ i lyset. -</em> Etter 6-8 dager er de ferdige!</p>\n<h3 id=\"framgangsmÃ¥te-med-jord\">FramgangsmÃ¥te (med jord)</h3>\n<p>- <em>Fukt jorden godt i en skÃ¥l. NB! Ikke fukt frÃ¸ene. -</em> Dryss frÃ¸ene oppÃ¥ jorden. - <em>Dekk til frÃ¸ene, slik at de er i mÃ¸rket. -</em> Etter at frÃ¸ene har spiret litt, ta vekk tildekningen (etter ca. 2 dager). - <em>Dusj frÃ¸ene med flaske hver dag. -</em> Etter 6-8 dager er de ferdige!</p>");

				const frontmatter$7 = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Spire chiafrÃ¸","featuredimage":"/img/upload/chiafrÃ¸.jpeg","description":"Her er oppskriften pÃ¥ hvordan man kan sÃ¥ chiafrÃ¸, bÃ¥de med jord og uten jord! Dette er en del av pÃ¥skepakken til troppen (5. 10. klasse) i speidergruppa. ","date":"2021-03-22T22:01:13.351Z","expireInDays":30,"tags":["troppen"]};
				const file$7 = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2021-03-22-dyrke-chiafrÃ¸.md";
				const url$7 = "/artikler/2021-03-22-dyrke-chiafrÃ¸";
				function rawContent$7() {
					return "\nChiafrÃ¸ kan ogsÃ¥ spires, slik som karse. Det minner om karse, men de er litt stÃ¸rre i bladene. ChiafrÃ¸ er veldig rik pÃ¥ Omega-3-fettsyrer og har masse antioksidanter, mineraler og vitaminer i seg. Resultatet gir en frisk smak. Pass bare pÃ¥ at chiafrÃ¸ene ikke fÃ¥r for mye vann, ellers drukner de veldig lett. Bruk derfor en liten skÃ¥l nÃ¥r chiafrÃ¸ene skal dyrkes.\n\n### Utstyr\n\n- ChiafrÃ¸ - _Vann i sprayflaske -_ SkÃ¥l - _Sil/bakepapir -_ Eventuelt jord -\\* Eventuelt gaffel\n\n### FramgangsmÃ¥te (uten jord)\n\n\\- _BlÃ¸tlegg frÃ¸ene, og la de ligge i vann i 5-10 minutter. -_ Finn fram en sil, og hvis det ikke er tilgjengelig, lag mange hull med en gaffel i bakepapir eller liknende. - _Putt sÃ¥ frÃ¸ene oppÃ¥ bakepapiret/silen uten at frÃ¸ene ligger oppÃ¥ hverandre. -_ Putt sÃ¥ bakepapiret/silen med frÃ¸ene oppÃ¥ den lille skÃ¥len. - _Dekk skÃ¥len til, slik at frÃ¸ene ikke tÃ¸rker ut pga. lys. -_ Dusj frÃ¸ene 2 ganger om dagen med en sprayflaske, slik at spirene er fuktige. - _Etter 2 dager med tildekking, kan skÃ¥len stÃ¥ i lyset. -_ Etter 6-8 dager er de ferdige!\n\n### FramgangsmÃ¥te (med jord)\n\n\\- _Fukt jorden godt i en skÃ¥l. NB! Ikke fukt frÃ¸ene. -_ Dryss frÃ¸ene oppÃ¥ jorden. - _Dekk til frÃ¸ene, slik at de er i mÃ¸rket. -_ Etter at frÃ¸ene har spiret litt, ta vekk tildekningen (etter ca. 2 dager). - _Dusj frÃ¸ene med flaske hver dag. -_ Etter 6-8 dager er de ferdige!\n";
				}
				function compiledContent$7() {
					return html$7;
				}
				function getHeadings$7() {
					return [{"depth":3,"slug":"utstyr","text":"Utstyr"},{"depth":3,"slug":"framgangsmÃ¥te-uten-jord","text":"FramgangsmÃ¥te (uten jord)"},{"depth":3,"slug":"framgangsmÃ¥te-med-jord","text":"FramgangsmÃ¥te (med jord)"}];
				}
				async function Content$7() {
					const { layout, ...content } = frontmatter$7;
					content.file = file$7;
					content.url = url$7;
					const contentFragment = createVNode(Fragment, { 'set:html': html$7 });
					return createVNode($$ArticleLayout, {
									file: file$7,
									url: url$7,
									content,
									frontmatter: content,
									headings: getHeadings$7(),
									rawContent: rawContent$7,
									compiledContent: compiledContent$7,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$7[Symbol.for('astro.needsHeadRendering')] = false;

const _page29 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$7,
  compiledContent: compiledContent$7,
  default: Content$7,
  file: file$7,
  frontmatter: frontmatter$7,
  getHeadings: getHeadings$7,
  images: images$7,
  rawContent: rawContent$7,
  url: url$7
}, Symbol.toStringTag, { value: 'Module' }));

const images$6 = {
					
				};

				function updateImageReferences$6(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$6[imagePath].src, ...images$6[imagePath].attributes})
					);
				}

				const html$6 = updateImageReferences$6("<p>Ho, ho, ho! Du trodde du kunne tyvstarte med mandeljakten! Ho, ho ho! Du fÃ¥r vente til mandag 7. desember 2020, kl 16. Da vil jakten starte pÃ¥ Spond..</p>");

				const frontmatter$6 = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"mandeljakten","featuredimage":"/img/upload/nisser.jpg","description":"PÃ¥ lÃ¥ven sitter nissen med sin julegrÃ¸t, sÃ¥ god og sÃ¸t! ","date":"2019-12-24T13:16:33.570Z","expireInDays":0,"tags":["troppen"]};
				const file$6 = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2020-11-29-mandeljakten.md";
				const url$6 = "/artikler/2020-11-29-mandeljakten";
				function rawContent$6() {
					return "\nHo, ho, ho! Du trodde du kunne tyvstarte med mandeljakten! Ho, ho ho! Du fÃ¥r vente til mandag 7. desember 2020, kl 16. Da vil jakten starte pÃ¥ Spond..\n";
				}
				function compiledContent$6() {
					return html$6;
				}
				function getHeadings$6() {
					return [];
				}
				async function Content$6() {
					const { layout, ...content } = frontmatter$6;
					content.file = file$6;
					content.url = url$6;
					const contentFragment = createVNode(Fragment, { 'set:html': html$6 });
					return createVNode($$ArticleLayout, {
									file: file$6,
									url: url$6,
									content,
									frontmatter: content,
									headings: getHeadings$6(),
									rawContent: rawContent$6,
									compiledContent: compiledContent$6,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$6[Symbol.for('astro.needsHeadRendering')] = false;

const _page30 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$6,
  compiledContent: compiledContent$6,
  default: Content$6,
  file: file$6,
  frontmatter: frontmatter$6,
  getHeadings: getHeadings$6,
  images: images$6,
  rawContent: rawContent$6,
  url: url$6
}, Symbol.toStringTag, { value: 'Module' }));

const images$5 = {
					
				};

				function updateImageReferences$5(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$5[imagePath].src, ...images$5[imagePath].attributes})
					);
				}

				const html$5 = updateImageReferences$5("<p>FÃ¸r utgangen av mars er det viktig Ã¥ fÃ¥ gjennomfÃ¸rt Ã¥rsmÃ¸te. Det er pÃ¥ Ã¥rsmÃ¸tet vi bestemmer hva vi skal gjÃ¸re framover og Ã¸konomien i gruppa, vi hÃ¥per mange speidere har lyst til Ã¥ vÃ¦re med og bestemme! Speidere over 12 Ã¥r og foreldre kan avgi stemme, men alle speidere kan delta.</p>\n<p><strong><a href=\"https://drive.google.com/file/d/1GTVF0D0F_K5iYjWp9uCNkzNAUnn8rpfp/view?usp=sharing\">Saksliste</a></strong></p>\n<ol>\n<li>\n<p><strong>Konstituering</strong></p>\n<ol>\n<li>Valg av mÃ¸teleder</li>\n<li>Valg av referent og to representanter til Ã¥ underskrive protokollen</li>\n<li>Godkjenning av innkalling og saksliste</li>\n</ol>\n</li>\n<li>\n<p><strong><a href=\"https://drive.google.com/file/d/1xBIg5oaQqB2E7y_uCM7e_BISQwekw7Dz/view?usp=sharing\">Ã…rsmelding 2021</a></strong>. Gruppestyrets Ã¥rsmelding legges fram for godkjenning. Rapport fra enhetene og Mason Hill.</p>\n</li>\n<li>\n<p><strong><a href=\"https://drive.google.com/file/d/1BQdAGTMRpXy7OZ2uncGicKMOro4bOyZZ/view?usp=sharing\">Regnskap 2021</a>.</strong> Regnskap legges fram for godkjenning.</p>\n</li>\n<li>\n<p><strong><a href=\"https://drive.google.com/file/d/1X77QMfdHMwDcWoW51U9F_mLGYHZ88Qqd/view?usp=sharing\">Budsjett 2023</a></strong>. Forslag til budsjett for neste Ã¥r.</p>\n</li>\n<li>\n<p><strong>Eventuelt</strong></p>\n</li>\n<li>\n<p><strong>Valg</strong></p>\n<ol>\n<li>Styremedlem og gruppeleder (for to Ã¥r)</li>\n<li>Styremedlem (for to Ã¥r)</li>\n<li>Representanter til kretsting (10 representanter, for ett Ã¥r)</li>\n<li>Kasserer (for ett Ã¥r)</li>\n<li>Revisor (for ett Ã¥r)</li>\n<li>ForeldrerÃ¥d (5 representanter, for ett Ã¥r)</li>\n</ol>\n</li>\n</ol>\n<p><br>\nVi trenger ogsÃ¥ flere foreldre som kan vÃ¦re med Ã¥ drive speidergruppa, og hjelpe til med store eller smÃ¥ oppgaver.<br>\n<br>\nHvis noen har saker dere Ã¸nsker Ã¥ ta opp pÃ¥ Ã¥rsmÃ¸tet, kan de sendes til <a href=\"mailto:mbhaukedal@gmail.com\">mbhaukedal@gmail.com</a> innen 24 mars.<br>\n<br>\nVi hÃ¥per pÃ¥ godt oppmÃ¸te av bÃ¥de speidere, foreldre, rovere og ledere!<br>\nVel mÃ¸tt.<br>\n<br>\nHilsen styret, v. gruppeleder Merete Haukedal</p>");

				const frontmatter$5 = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Ã…rsmÃ¸te 2022","featuredimage":"/img/upload/img_20210703_081612_706.jpg","description":"Speidere og foreldre innkalles til gruppetingets Ã¥rsmÃ¸te, mandag 28 mars kl. 19.15-20.30 pÃ¥ speiderhuset.","date":"2022-03-10T08:44:55.756Z","expireInDays":60,"tags":["troppen","alle"]};
				const file$5 = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2022-03-10-Ã¥rsmÃ¸te-2022.md";
				const url$5 = "/artikler/2022-03-10-Ã¥rsmÃ¸te-2022";
				function rawContent$5() {
					return "\nFÃ¸r utgangen av mars er det viktig Ã¥ fÃ¥ gjennomfÃ¸rt Ã¥rsmÃ¸te. Det er pÃ¥ Ã¥rsmÃ¸tet vi bestemmer hva vi skal gjÃ¸re framover og Ã¸konomien i gruppa, vi hÃ¥per mange speidere har lyst til Ã¥ vÃ¦re med og bestemme! Speidere over 12 Ã¥r og foreldre kan avgi stemme, men alle speidere kan delta.\n\n**[Saksliste](https://drive.google.com/file/d/1GTVF0D0F_K5iYjWp9uCNkzNAUnn8rpfp/view?usp=sharing)**\n\n1. **Konstituering**\n\n   1. Valg av mÃ¸teleder\n   2. Valg av referent og to representanter til Ã¥ underskrive protokollen\n   3. Godkjenning av innkalling og saksliste\n\n2. **[Ã…rsmelding 2021](https://drive.google.com/file/d/1xBIg5oaQqB2E7y_uCM7e_BISQwekw7Dz/view?usp=sharing)**. Gruppestyrets Ã¥rsmelding legges fram for godkjenning. Rapport fra enhetene og Mason Hill.\n3. **[Regnskap 2021](https://drive.google.com/file/d/1BQdAGTMRpXy7OZ2uncGicKMOro4bOyZZ/view?usp=sharing).** Regnskap legges fram for godkjenning.\n4. **[Budsjett 2023](https://drive.google.com/file/d/1X77QMfdHMwDcWoW51U9F_mLGYHZ88Qqd/view?usp=sharing)**. Forslag til budsjett for neste Ã¥r.\n5. **Eventuelt**\n6. **Valg**\n\n   1. Styremedlem og gruppeleder (for to Ã¥r)\n   2. Styremedlem (for to Ã¥r)\n   3. Representanter til kretsting (10 representanter, for ett Ã¥r)\n   4. Kasserer (for ett Ã¥r)\n   5. Revisor (for ett Ã¥r)\n   6. ForeldrerÃ¥d (5 representanter, for ett Ã¥r)\n\n\\\nVi trenger ogsÃ¥ flere foreldre som kan vÃ¦re med Ã¥ drive speidergruppa, og hjelpe til med store eller smÃ¥ oppgaver.\\\n\\\nHvis noen har saker dere Ã¸nsker Ã¥ ta opp pÃ¥ Ã¥rsmÃ¸tet, kan de sendes til [mbhaukedal@gmail.com](mailto:mbhaukedal@gmail.com) innen 24 mars.\\\n\\\nVi hÃ¥per pÃ¥ godt oppmÃ¸te av bÃ¥de speidere, foreldre, rovere og ledere!\\\nVel mÃ¸tt.\\\n\\\nHilsen styret, v. gruppeleder Merete Haukedal\n";
				}
				function compiledContent$5() {
					return html$5;
				}
				function getHeadings$5() {
					return [];
				}
				async function Content$5() {
					const { layout, ...content } = frontmatter$5;
					content.file = file$5;
					content.url = url$5;
					const contentFragment = createVNode(Fragment, { 'set:html': html$5 });
					return createVNode($$ArticleLayout, {
									file: file$5,
									url: url$5,
									content,
									frontmatter: content,
									headings: getHeadings$5(),
									rawContent: rawContent$5,
									compiledContent: compiledContent$5,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$5[Symbol.for('astro.needsHeadRendering')] = false;

const _page31 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$5,
  compiledContent: compiledContent$5,
  default: Content$5,
  file: file$5,
  frontmatter: frontmatter$5,
  getHeadings: getHeadings$5,
  images: images$5,
  rawContent: rawContent$5,
  url: url$5
}, Symbol.toStringTag, { value: 'Module' }));

const images$4 = {
					
				};

				function updateImageReferences$4(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$4[imagePath].src, ...images$4[imagePath].attributes})
					);
				}

				const html$4 = updateImageReferences$4("<p>Ã…rsmÃ¸tet vil foregÃ¥ 31. mai kl 18</p>\n<p>PÃ¥ Ã¥rsmÃ¸tet legger vi frem Ã¸konomi og aktivitet i gruppen for 2020. I tillegg fÃ¥r dere muligheten til Ã¥ stille til ulike verv, der du kan gjÃ¸re en forskjell i gruppa.</p>\n<p>Alle speidere som er 12 Ã¥r, eller eldre kan vÃ¦re med Ã¥ stemme, og stille til de ulike vervene. Foreldre kan ogsÃ¥ vÃ¦re med Ã¥ stemme, og stille til ulike verv.</p>\n<p>Ulike verv:</p>\n<ul>\n<li>Styremedlem, 2 Ã¥r om gangen</li>\n<li>ForeldrerÃ¥det (bare foreldre) 1 Ã¥r om gangen</li>\n<li>Revisor (bare foreldre)</li>\n</ul>\n<p>Hvis dere Ã¸nsker flere detaljer om hva de gjÃ¸r, kan dere sende Martin <em>918 50 048</em> eller Merete <em>411 44 18</em>2 en melding.</p>\n<p>Sakspapirer og mÃ¸telenke kommer nÃ¦rmere mÃ¸te. Det vil foregÃ¥ digitalt.</p>");

				const frontmatter$4 = {"layout":"../../layouts/ArticleLayout.astro","templateKey":"blog-post","title":"Ã…rsmÃ¸te!","featuredimage":"/img/upload/img_4396.jpg","description":"Er du interessert i Ã¥ se hvordan Speidergruppen fungerer? Vil du pÃ¥virke og forme speidergruppen? Alle speidere over 12 Ã¥r kan bli med! ","date":"2021-04-28T18:20:56.914Z","expireInDays":60,"tags":["gruppen"]};
				const file$4 = "/home/martin/Documents/GitHub/mason/src/pages/artikler/2021-04-28-Ã¥rsmÃ¸te.md";
				const url$4 = "/artikler/2021-04-28-Ã¥rsmÃ¸te";
				function rawContent$4() {
					return "\nÃ…rsmÃ¸tet vil foregÃ¥ 31. mai kl 18\n\nPÃ¥ Ã¥rsmÃ¸tet legger vi frem Ã¸konomi og aktivitet i gruppen for 2020. I tillegg fÃ¥r dere muligheten til Ã¥ stille til ulike verv, der du kan gjÃ¸re en forskjell i gruppa.\n\nAlle speidere som er 12 Ã¥r, eller eldre kan vÃ¦re med Ã¥ stemme, og stille til de ulike vervene. Foreldre kan ogsÃ¥ vÃ¦re med Ã¥ stemme, og stille til ulike verv.\n\nUlike verv:\n\n- Styremedlem, 2 Ã¥r om gangen\n- ForeldrerÃ¥det (bare foreldre) 1 Ã¥r om gangen\n- Revisor (bare foreldre)\n\nHvis dere Ã¸nsker flere detaljer om hva de gjÃ¸r, kan dere sende Martin _918 50 048_ eller Merete *411 44 18*2 en melding.\n\nSakspapirer og mÃ¸telenke kommer nÃ¦rmere mÃ¸te. Det vil foregÃ¥ digitalt.\n";
				}
				function compiledContent$4() {
					return html$4;
				}
				function getHeadings$4() {
					return [];
				}
				async function Content$4() {
					const { layout, ...content } = frontmatter$4;
					content.file = file$4;
					content.url = url$4;
					const contentFragment = createVNode(Fragment, { 'set:html': html$4 });
					return createVNode($$ArticleLayout, {
									file: file$4,
									url: url$4,
									content,
									frontmatter: content,
									headings: getHeadings$4(),
									rawContent: rawContent$4,
									compiledContent: compiledContent$4,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$4[Symbol.for('astro.needsHeadRendering')] = false;

const _page32 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$4,
  compiledContent: compiledContent$4,
  default: Content$4,
  file: file$4,
  frontmatter: frontmatter$4,
  getHeadings: getHeadings$4,
  images: images$4,
  rawContent: rawContent$4,
  url: url$4
}, Symbol.toStringTag, { value: 'Module' }));

const $$Astro$4 = createAstro("https://nadderud.no");
const $$Artikler = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$4, $$props, $$slots);
  Astro2.self = $$Artikler;
  const posts = await Astro2.glob(/* #__PURE__ */ Object.assign({"/src/pages/artikler/2019-09-25-troppskonk-19-20-oktober.md": () => Promise.resolve().then(() => _page17),"/src/pages/artikler/2019-10-12-flokk-tur-til-lomma-19-20-oktober.md": () => Promise.resolve().then(() => _page12),"/src/pages/artikler/2019-11-13-haslumseter-tur.md": () => Promise.resolve().then(() => _page28),"/src/pages/artikler/2019-12-01-nissefest-pÃ¥-speiderhuset-mandag-16-desember.md": () => Promise.resolve().then(() => _page5),"/src/pages/artikler/2020-01-16-velkommen-til-et-nytt-speidersemester-og-godt-nytt-Ã¥r.md": () => Promise.resolve().then(() => _page3),"/src/pages/artikler/2020-02-02-snÃ¸huletur-28-februar-1-mars.md": () => Promise.resolve().then(() => _page15),"/src/pages/artikler/2020-03-03-troppsleir-i-jotunheimen-8-15-august.md": () => Promise.resolve().then(() => _page10),"/src/pages/artikler/2020-03-12-avlysninger-knyttet-til-koronaviruset.md": () => Promise.resolve().then(() => _page8),"/src/pages/artikler/2020-04-28-speideroverraskelse.md": () => Promise.resolve().then(() => _page25),"/src/pages/artikler/2020-05-05-troppen-starter-opp-igjen-med-patruljemÃ¸ter.md": () => Promise.resolve().then(() => _page6),"/src/pages/artikler/2020-05-12-informasjon-om-17-mai-2020.md": () => Promise.resolve().then(() => _page16),"/src/pages/artikler/2020-05-17-gratulerer-med-dagen-alle-speidere.md": () => Promise.resolve().then(() => _page11),"/src/pages/artikler/2020-05-25-Ã¥rsmÃ¸te-8-juni-pÃ¥-speiderhuset.md": () => Promise.resolve().then(() => _page14),"/src/pages/artikler/2020-06-10-minileir-sommer-2020-ved-farris.md": () => Promise.resolve().then(() => _page13),"/src/pages/artikler/2020-08-12-oppstart-for-troppen-kanomÃ¸te-pÃ¥-bogstadvannet-7-sept.md": () => Promise.resolve().then(() => _page4),"/src/pages/artikler/2020-08-17-flokken-starter-opp-tirsdag-25-august.md": () => Promise.resolve().then(() => _page9),"/src/pages/artikler/2020-09-27-troppskonk-10-11-oktober.md": () => Promise.resolve().then(() => _page18),"/src/pages/artikler/2020-10-06-venteliste-i-flokken.md": () => Promise.resolve().then(() => _page22),"/src/pages/artikler/2020-10-06-Ã¥rets-hjulskiftaksjon.md": () => Promise.resolve().then(() => _page21),"/src/pages/artikler/2020-11-10-speiding-i-koronatid.md": () => Promise.resolve().then(() => _page23),"/src/pages/artikler/2020-11-29-mandeljakten.md": () => Promise.resolve().then(() => _page30),"/src/pages/artikler/2021-01-04-speiding-i-koronatid.md": () => Promise.resolve().then(() => _page24),"/src/pages/artikler/2021-03-15-nye-koronarestriksjoner.md": () => Promise.resolve().then(() => _page19),"/src/pages/artikler/2021-03-22-dyrke-chiafrÃ¸.md": () => Promise.resolve().then(() => _page29),"/src/pages/artikler/2021-04-28-Ã¥rsmÃ¸te.md": () => Promise.resolve().then(() => _page32),"/src/pages/artikler/2021-05-13-Ã¥rsmÃ¸te-31-mai-2021.md": () => Promise.resolve().then(() => _page26),"/src/pages/artikler/2021-05-30-kanotur-pÃ¥-fjorda.md": () => Promise.resolve().then(() => _page27),"/src/pages/artikler/2021-12-14-god-jul-og-godt-nytt-Ã¥r.md": () => Promise.resolve().then(() => _page20),"/src/pages/artikler/2022-03-10-Ã¥rsmÃ¸te-2022.md": () => Promise.resolve().then(() => _page31),"/src/pages/artikler/2023-04-03-the-conquest-of-the-lord-saviour-bjÃ¸rn.md": () => Promise.resolve().then(() => _page7)}), () => "/src/pages/artikler/*.md");
  const meta = {
    title: "Artikler",
    description: "Alle artiklene til Nadderud speidergruppe. Nyheter, \xE5rsmeldinger, speiderhistorier og mer."
  };
  return renderTemplate`${renderComponent($$result, "PageLayout", $$PageLayout, { "meta": meta, "class": "astro-UBDLURCY" }, { "default": ($$result2) => renderTemplate`${renderComponent($$result2, "Hero", $$Hero, { "title": "Artikler", "image": "/img/upload/b\xE5l.jpeg", "description": "Her kan du finne alle artiklene til Nadderud speidergruppe. Nyheter, \xE5rsmeldinger, speiderhistorier og mer.", "class": "astro-UBDLURCY" })}${maybeRenderHead($$result2)}<main class="astro-UBDLURCY">
    <section class="p-4 astro-UBDLURCY">
      ${posts.sort(
    (a, b) => new Date(String(b.frontmatter.date)).getTime() - new Date(String(a.frontmatter.date)).getTime()
  ).map((post) => {
    const { title, description, featuredimage, tags } = post.frontmatter;
    return renderTemplate`<a class="card bg-base-100 shadow-xl astro-UBDLURCY"${addAttribute(`${post.url}`, "href")}>
                <figure class="h-52 astro-UBDLURCY">
                  <img${addAttribute(featuredimage || "/img/nsf.png", "src")}${addAttribute(`Bilde til artikel: ${title}`, "alt")} loading="lazy" class="astro-UBDLURCY">
                </figure>
                <div class="card-body astro-UBDLURCY">
                  <h2 class="card-title astro-UBDLURCY">${title}</h2>
                  <div class="flex gap-2 astro-UBDLURCY">
                    ${tags && tags.map((tag) => {
      if (!/^$|^\.|\-$/.test(tag))
        return renderTemplate`<span class="badge astro-UBDLURCY">${tag}</span>`;
    })}
                  </div>
                  <p class="astro-UBDLURCY">
                    ${String(description).slice(0, 100)}
                    ${description.length > 100 ? " ..." : ""}
                  </p>
                </div>
              </a>`;
  })}
    </section>
  </main>` })}`;
}, "/home/martin/Documents/GitHub/mason/src/pages/artikler.astro");

const $$file$2 = "/home/martin/Documents/GitHub/mason/src/pages/artikler.astro";
const $$url$2 = "/artikler";

const _page33 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$Artikler,
  file: $$file$2,
  url: $$url$2
}, Symbol.toStringTag, { value: 'Module' }));

const images$3 = {
					
				};

				function updateImageReferences$3(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$3[imagePath].src, ...images$3[imagePath].attributes})
					);
				}

				const html$3 = updateImageReferences$3("<h2 id=\"program\">Program</h2>\n<p>Vi jobber med Ã¥ legge programmet inn pÃ¥ nettsiden. I mellomtiden kan du finne ut hva som er planen fremmover ved Ã¥ sjekke Spond eller kontakte oss. <a href=\"/info\">kontakt oss</a>.</p>");

				const frontmatter$3 = {"layout":"../layouts/MarkdownPageLayout.astro","date":"2019-05-22T17:12:33.962Z","title":"Program","image":"/img/upload/flaate.jpg","description":"Program for Nadderud speidergruppe"};
				const file$3 = "/home/martin/Documents/GitHub/mason/src/pages/program.md";
				const url$3 = "/program";
				function rawContent$3() {
					return "\n## Program\n\nVi jobber med Ã¥ legge programmet inn pÃ¥ nettsiden. I mellomtiden kan du finne ut hva som er planen fremmover ved Ã¥ sjekke Spond eller kontakte oss. [kontakt oss](/info).\n";
				}
				function compiledContent$3() {
					return html$3;
				}
				function getHeadings$3() {
					return [{"depth":2,"slug":"program","text":"Program"}];
				}
				async function Content$3() {
					const { layout, ...content } = frontmatter$3;
					content.file = file$3;
					content.url = url$3;
					const contentFragment = createVNode(Fragment, { 'set:html': html$3 });
					return createVNode($$MarkdownPageLayout, {
									file: file$3,
									url: url$3,
									content,
									frontmatter: content,
									headings: getHeadings$3(),
									rawContent: rawContent$3,
									compiledContent: compiledContent$3,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$3[Symbol.for('astro.needsHeadRendering')] = false;

const _page34 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$3,
  compiledContent: compiledContent$3,
  default: Content$3,
  file: file$3,
  frontmatter: frontmatter$3,
  getHeadings: getHeadings$3,
  images: images$3,
  rawContent: rawContent$3,
  url: url$3
}, Symbol.toStringTag, { value: 'Module' }));

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$Astro$3 = createAstro("https://nadderud.no");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$3, $$props, $$slots);
  Astro2.self = $$Index;
  return renderTemplate(_a || (_a = __template(['<html>\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Content Managment System</title>\n    <link href="/admin/config.yml" type="text/yaml" rel="cms-config-url">\n    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"><\/script>\n  ', '</head>\n  <body>\n    <script src="https://unpkg.com/netlify-cms@^2.10.192/dist/netlify-cms.js"><\/script>\n  </body>\n</html>'])), renderHead($$result));
}, "/home/martin/Documents/GitHub/mason/src/pages/admin/index.astro");

const $$file$1 = "/home/martin/Documents/GitHub/mason/src/pages/admin/index.astro";
const $$url$1 = "/admin";

const _page35 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$Index,
  file: $$file$1,
  url: $$url$1
}, Symbol.toStringTag, { value: 'Module' }));

const images$2 = {
					
				};

				function updateImageReferences$2(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$2[imagePath].src, ...images$2[imagePath].attributes})
					);
				}

				const html$2 = updateImageReferences$2("<h2 id=\"generell-info\">Generell info</h2>\n<ul>\n<li>MÃ¸telokaler: Ã˜ygardveien 49, 1357 Bekkestua</li>\n<li>Postadresse: Nadderud speidergruppe, v/Anne Marie TorbjÃ¸rnsdal, Egne Hjemsvei 3E 1356 Bekkestua</li>\n<li>Telefonnummer: 472 42 810</li>\n<li>E-postadresse: <a href=\"mailto:post@nadderud.no\">post@nadderud.no</a></li>\n<li>Kontonummer: 9235.19.85773</li>\n</ul>\n<p>Â </p>\n<h2 id=\"kontakt-oss\">Kontakt oss</h2>\n<ul>\n<li><strong>Anne Marie TorbjÃ¸rnsdal</strong>, Gruppeleder:<br>\n472 42 810, <a href=\"mailto:annemarietorb@gmail.com\"></a><a href=\"mailto:annemarietorb@gmail.com\">annemarietorb@gmail.com</a></li>\n<li><strong>Philip Godager</strong>, Troppsleder (5.â€“10. klasse):<br>\n477 16 980, <a href=\"mailto:philip1014@outlook.com\"></a><a href=\"mailto:philip1014@outlook.com\">philip1014@outlook.com</a></li>\n<li><strong>Nikolai KragÃ¸e Andresen</strong>, Flokkleder (3.â€“4. klasse):<br>\n997 29 706, <a href=\"mailto:nikolai.andresen@gmail.com\"></a><a href=\"mailto:nikolai.andresen@gmail.com\">nikolai.andresen@gmail.com</a></li>\n</ul>\n<h2 id=\"sosiale-medier\">Sosiale medier</h2>\n<p>Vi er pÃ¥ Facebook og Instagram!</p>\n<ul>\n<li>Facebook: <a href=\"https://www.facebook.com/groups/248612515197643/\">Nadderud speidergruppe</a></li>\n<li>Instagram: <a href=\"https://www.instagram.com/nadderudspeidergruppe/\">@nadderudspeidergruppe</a></li>\n</ul>");

				const frontmatter$2 = {"layout":"../layouts/MarkdownPageLayout.astro","date":"2019-05-22T17:12:33.962Z","title":"Informasjon","image":"/img/upload/flaate.jpg","description":"Spennende friluftsliv for barn og ungdom fra 3. klasse og oppover. Vi er en aktiv speidergruppe med ca. 100 medlemmer som dekker omrÃ¥det Nadderud, Bekkestua, Hosle, Eikeli og Haslum."};
				const file$2 = "/home/martin/Documents/GitHub/mason/src/pages/info.md";
				const url$2 = "/info";
				function rawContent$2() {
					return "\n## Generell info\n\n- MÃ¸telokaler: Ã˜ygardveien 49, 1357 Bekkestua\n- Postadresse: Nadderud speidergruppe, v/Anne Marie TorbjÃ¸rnsdal, Egne Hjemsvei 3E 1356 Bekkestua\n- Telefonnummer: 472 42 810\n- E-postadresse: [post@nadderud.no](mailto:post@nadderud.no)\n- Kontonummer: 9235.19.85773\n\n&nbsp;\n\n## Kontakt oss\n\n- **Anne Marie TorbjÃ¸rnsdal**, Gruppeleder:\\\n  472 42 810, <a href=\"mailto:annemarietorb@gmail.com\">annemarietorb@gmail.com</a>\n- **Philip Godager**, Troppsleder (5.â€“10. klasse):\\\n  477 16 980, <a href=\"mailto:philip1014@outlook.com\">philip1014@outlook.com</a>\n- **Nikolai KragÃ¸e Andresen**, Flokkleder (3.â€“4. klasse):\\\n  997 29 706, <a href=\"mailto:nikolai.andresen@gmail.com\">nikolai.andresen@gmail.com</a>\n\n## Sosiale medier\n\nVi er pÃ¥ Facebook og Instagram!\n\n- Facebook: <a href=\"https://www.facebook.com/groups/248612515197643/\">Nadderud speidergruppe</a>\n- Instagram: <a href=\"https://www.instagram.com/nadderudspeidergruppe/\">@nadderudspeidergruppe</a>\n";
				}
				function compiledContent$2() {
					return html$2;
				}
				function getHeadings$2() {
					return [{"depth":2,"slug":"generell-info","text":"Generell info"},{"depth":2,"slug":"kontakt-oss","text":"Kontakt oss"},{"depth":2,"slug":"sosiale-medier","text":"Sosiale medier"}];
				}
				async function Content$2() {
					const { layout, ...content } = frontmatter$2;
					content.file = file$2;
					content.url = url$2;
					const contentFragment = createVNode(Fragment, { 'set:html': html$2 });
					return createVNode($$MarkdownPageLayout, {
									file: file$2,
									url: url$2,
									content,
									frontmatter: content,
									headings: getHeadings$2(),
									rawContent: rawContent$2,
									compiledContent: compiledContent$2,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$2[Symbol.for('astro.needsHeadRendering')] = false;

const _page36 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$2,
  compiledContent: compiledContent$2,
  default: Content$2,
  file: file$2,
  frontmatter: frontmatter$2,
  getHeadings: getHeadings$2,
  images: images$2,
  rawContent: rawContent$2,
  url: url$2
}, Symbol.toStringTag, { value: 'Module' }));

const $$Astro$2 = createAstro("https://nadderud.no");
const $$WikiPageNavigation = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$2, $$props, $$slots);
  Astro2.self = $$WikiPageNavigation;
  const wikiPages = await Astro2.glob(/* #__PURE__ */ Object.assign({"/src/pages/wiki/om-nettsiden.md": () => Promise.resolve().then(() => _page37)}), () => "/src/pages/wiki/*.md");
  const { selectedPage } = Astro2.props;
  return renderTemplate`${maybeRenderHead($$result)}<ul class="menu p-4 text-base-content menu-compact bg-base-200 w-80">
  <li>
    <a href="/wiki">Wiki forside</a>
  </li>
  ${wikiPages.map((page) => {
    const { title } = page.frontmatter;
    return renderTemplate`<li>
          <a${addAttribute(`${selectedPage === page.frontmatter.title ? "active" : ""} `, "class")}${addAttribute(page.url, "href")}>${title}</a>
        </li>`;
  })}
</ul>`;
}, "/home/martin/Documents/GitHub/mason/src/components/widgets/WikiPageNavigation.astro");

const $$Astro$1 = createAstro("https://nadderud.no");
const $$WikiPageLayout = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);
  Astro2.self = $$WikiPageLayout;
  const { frontmatter } = Astro2.props;
  const meta = {
    title: frontmatter.title,
    description: frontmatter.description
  };
  return renderTemplate`${renderComponent($$result, "Layout", $$BaseLayout, { "meta": meta }, { "default": ($$result2) => renderTemplate`${renderSlot($$result2, $$slots["announcement"], renderTemplate`
    ${renderComponent($$result2, "Announcement", $$Announcement, {})}
  `)}${renderSlot($$result2, $$slots["header"], renderTemplate`
    ${renderComponent($$result2, "Header", $$Header, { ...headerData })}
  `)}${maybeRenderHead($$result2)}<div class="drawer drawer-mobile h-auto grow">
    <input id="my-drawer-3" type="checkbox" class="drawer-toggle"> 
    <main class="drawer-content flex flex-col">
       
      <label for="my-drawer-3" class="btn gap-3 m-3 lg:hidden">
        Utforsk Wiki
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="inline-block w-6 h-6 stroke-current"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
      </label>
      <article class="prose p-5 max-w-xl">
        <h1>${frontmatter.title}</h1>
        <p class="italic">${frontmatter.description}</p>
        <hr class="my-1">
      ${renderSlot($$result2, $$slots["default"])}
    </article>
    </main> 
    <div class="drawer-side" style="max-height: 100%;">
      <label for="my-drawer-3" class="drawer-overlay"></label> 
      ${renderComponent($$result2, "WikiPageNavigation", $$WikiPageNavigation, { "selectedPage": frontmatter.title })}
    </div>
  </div>${renderSlot($$result2, $$slots["footer"], renderTemplate`
    ${renderComponent($$result2, "Footer", $$Footer, {})}
  `)}` })}`;
}, "/home/martin/Documents/GitHub/mason/src/layouts/WikiPageLayout.astro");

const images$1 = {
					
				};

				function updateImageReferences$1(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images$1[imagePath].src, ...images$1[imagePath].attributes})
					);
				}

				const html$1 = updateImageReferences$1("<h2 id=\"innhold\">Innhold</h2>\n<p>Denne nettsiden har flere formÃ¥l og funksjoner, og denne teksten vil gi deg en oversikt over alt den har Ã¥ tilby. Vi vil gÃ¥ gjennom formÃ¥let med nettsiden, adminpanelet, arrangementer, tekniske detaljer og kontaktperson.</p>\n<h2 id=\"formÃ¥l\">FormÃ¥l</h2>\n<p>Nettsiden nadderud.no har to hovedformÃ¥l. For det fÃ¸rste Ã¸nsker vi Ã¥ gi informasjon til nye speidere om alle de spennende aktivitetene og opplevelsene vi tilbyr i speidergruppen vÃ¥r. Vi vil at de skal kunne lÃ¦re om vÃ¥re verdier, vÃ¥re tradisjoner og vÃ¥r historie, og vi Ã¸nsker Ã¥ gi dem all den informasjonen de trenger for Ã¥ bli en del av fellesskapet. For det andre bruker vi nettsiden som et verktÃ¸y for Ã¥ lagre og publisere dokumenter som Ã¥rsmÃ¸tepapirer. PÃ¥ denne mÃ¥ten kan alle medlemmene i speidergruppen fÃ¥ tilgang til viktig informasjon nÃ¥r de trenger det.</p>\n<h2 id=\"adminpanelet\">Adminpanelet</h2>\n<p>Vi har laget en egen side pÃ¥ nettsiden som er kun for admin-brukere. Her kan du logge inn og redigere undersider, opprette wiki-sider og artikler, samt laste opp bilder og tekst. For Ã¥ logge inn som admin, kan du navigere til <a href=\"https://nadderud.no/admin\">nadderud.no/admin</a>. Hvis du ikke har en bruker, kan du opprette en og kontakte nettsidens kontaktperson for Ã¥ fÃ¥ tilgang. NÃ¥r du har logget inn, vil du se adminpanelet, hvor du kan gjÃ¸re alle endringene du Ã¸nsker pÃ¥ nettsiden.</p>\n<h2 id=\"arrangementer\">Arrangementer</h2>\n<p>PÃ¥ nettsiden viser vi informasjon om kommende arrangementer som hentes direkte fra Spond. Vi viser forelÃ¸pig kun en begrenset mengde informasjon om arrangementene (bilde, tittel og starttid), men i fremtiden vil det vÃ¦re mulig Ã¥ vise mye mer. Vi begrenser informasjonen som vises fordi Spond er et trygt sted Ã¥ opprette arrangementer, og vi vil ikke at all informasjon skal vÃ¦re offentlig tilgjengelig.</p>\n<h2 id=\"tekniske-detaljer\">Tekniske detaljer</h2>\n<p>Hvis du vil bidra til Ã¥ forbedre nettsiden, kan du finne koden vÃ¥r pÃ¥ Github. Vi har hatt flere versjoner av nettsiden tidligere, men denne varianten er oppkalt etter vÃ¥r favoritt speiderhytte, Mason Hill. Teknologiene som nettsiden bruker er relativt enkle, og hvis du har litt kunnskap om HTML, CSS og JavaScript, vil du raskt kunne sette deg inn i hvordan alt fungerer. Vi bruker blant annet Astro som JS-rammeverk, Netlify Identity, Netlify CMS, Tailwind og Daisyui.</p>\n<h2 id=\"kontaktperson\">Kontaktperson</h2>\n<p>Hvis du har noen spÃ¸rsmÃ¥l om nettsiden eller Ã¸nsker Ã¥ bidra, er du hjertelig velkommen til Ã¥ kontakte vÃ¥r kontaktperson Martin Clementz pÃ¥ <a href=\"mailto:martincclementz@gmail.com\">martincclementz@gmail.com</a>.</p>");

				const frontmatter$1 = {"layout":"../../layouts/WikiPageLayout.astro","title":"Om nettsiden","description":"Alt du trenger Ã¥ vite om nettsiden.","createdDate":"2023-04-09T20:53:00.457Z","updatedDate":"2023-04-09T20:53:01.874Z","tags":[]};
				const file$1 = "/home/martin/Documents/GitHub/mason/src/pages/wiki/om-nettsiden.md";
				const url$1 = "/wiki/om-nettsiden";
				function rawContent$1() {
					return "## Innhold\n\nDenne nettsiden har flere formÃ¥l og funksjoner, og denne teksten vil gi deg en oversikt over alt den har Ã¥ tilby. Vi vil gÃ¥ gjennom formÃ¥let med nettsiden, adminpanelet, arrangementer, tekniske detaljer og kontaktperson.\n\n## FormÃ¥l\n\nNettsiden nadderud.no har to hovedformÃ¥l. For det fÃ¸rste Ã¸nsker vi Ã¥ gi informasjon til nye speidere om alle de spennende aktivitetene og opplevelsene vi tilbyr i speidergruppen vÃ¥r. Vi vil at de skal kunne lÃ¦re om vÃ¥re verdier, vÃ¥re tradisjoner og vÃ¥r historie, og vi Ã¸nsker Ã¥ gi dem all den informasjonen de trenger for Ã¥ bli en del av fellesskapet. For det andre bruker vi nettsiden som et verktÃ¸y for Ã¥ lagre og publisere dokumenter som Ã¥rsmÃ¸tepapirer. PÃ¥ denne mÃ¥ten kan alle medlemmene i speidergruppen fÃ¥ tilgang til viktig informasjon nÃ¥r de trenger det.\n\n## Adminpanelet\n\nVi har laget en egen side pÃ¥ nettsiden som er kun for admin-brukere. Her kan du logge inn og redigere undersider, opprette wiki-sider og artikler, samt laste opp bilder og tekst. For Ã¥ logge inn som admin, kan du navigere til [nadderud.no/admin](https://nadderud.no/admin). Hvis du ikke har en bruker, kan du opprette en og kontakte nettsidens kontaktperson for Ã¥ fÃ¥ tilgang. NÃ¥r du har logget inn, vil du se adminpanelet, hvor du kan gjÃ¸re alle endringene du Ã¸nsker pÃ¥ nettsiden.\n\n## Arrangementer\n\nPÃ¥ nettsiden viser vi informasjon om kommende arrangementer som hentes direkte fra Spond. Vi viser forelÃ¸pig kun en begrenset mengde informasjon om arrangementene (bilde, tittel og starttid), men i fremtiden vil det vÃ¦re mulig Ã¥ vise mye mer. Vi begrenser informasjonen som vises fordi Spond er et trygt sted Ã¥ opprette arrangementer, og vi vil ikke at all informasjon skal vÃ¦re offentlig tilgjengelig.\n\n## Tekniske detaljer\n\nHvis du vil bidra til Ã¥ forbedre nettsiden, kan du finne koden vÃ¥r pÃ¥ Github. Vi har hatt flere versjoner av nettsiden tidligere, men denne varianten er oppkalt etter vÃ¥r favoritt speiderhytte, Mason Hill. Teknologiene som nettsiden bruker er relativt enkle, og hvis du har litt kunnskap om HTML, CSS og JavaScript, vil du raskt kunne sette deg inn i hvordan alt fungerer. Vi bruker blant annet Astro som JS-rammeverk, Netlify Identity, Netlify CMS, Tailwind og Daisyui.\n\n## Kontaktperson\n\nHvis du har noen spÃ¸rsmÃ¥l om nettsiden eller Ã¸nsker Ã¥ bidra, er du hjertelig velkommen til Ã¥ kontakte vÃ¥r kontaktperson Martin Clementz pÃ¥ [martincclementz@gmail.com](mailto:martincclementz@gmail.com).";
				}
				function compiledContent$1() {
					return html$1;
				}
				function getHeadings$1() {
					return [{"depth":2,"slug":"innhold","text":"Innhold"},{"depth":2,"slug":"formÃ¥l","text":"FormÃ¥l"},{"depth":2,"slug":"adminpanelet","text":"Adminpanelet"},{"depth":2,"slug":"arrangementer","text":"Arrangementer"},{"depth":2,"slug":"tekniske-detaljer","text":"Tekniske detaljer"},{"depth":2,"slug":"kontaktperson","text":"Kontaktperson"}];
				}
				async function Content$1() {
					const { layout, ...content } = frontmatter$1;
					content.file = file$1;
					content.url = url$1;
					const contentFragment = createVNode(Fragment, { 'set:html': html$1 });
					return createVNode($$WikiPageLayout, {
									file: file$1,
									url: url$1,
									content,
									frontmatter: content,
									headings: getHeadings$1(),
									rawContent: rawContent$1,
									compiledContent: compiledContent$1,
									'server:root': true,
									children: contentFragment
								});
				}
				Content$1[Symbol.for('astro.needsHeadRendering')] = false;

const _page37 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content: Content$1,
  compiledContent: compiledContent$1,
  default: Content$1,
  file: file$1,
  frontmatter: frontmatter$1,
  getHeadings: getHeadings$1,
  images: images$1,
  rawContent: rawContent$1,
  url: url$1
}, Symbol.toStringTag, { value: 'Module' }));

const images = {
					
				};

				function updateImageReferences(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images[imagePath].src, ...images[imagePath].attributes})
					);
				}

				const html = updateImageReferences("<p>ðŸ‘·â€â™€ï¸ðŸ‘· Wikien er under konstruksjon og vil bli fyldigere etterhvert. ðŸ¦º ðŸ—ï¸</p>");

				const frontmatter = {"layout":"../layouts/WikiPageLayout.astro","title":"Wiki","date":"2019-10-11T14:58:17.793Z","image":"/img/upload/lomma.jpg","description":"I denne wikien finner du informasjon om alt fra speidergruppen, speiderlivet, speiderloven og sanger."};
				const file = "/home/martin/Documents/GitHub/mason/src/pages/wiki.md";
				const url = "/wiki";
				function rawContent() {
					return "\nðŸ‘·â€â™€ï¸ðŸ‘· Wikien er under konstruksjon og vil bli fyldigere etterhvert. ðŸ¦º ðŸ—ï¸";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return createVNode($$WikiPageLayout, {
									file,
									url,
									content,
									frontmatter: content,
									headings: getHeadings(),
									rawContent,
									compiledContent,
									'server:root': true,
									children: contentFragment
								});
				}
				Content[Symbol.for('astro.needsHeadRendering')] = false;

const _page38 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Content,
  compiledContent,
  default: Content,
  file,
  frontmatter,
  getHeadings,
  images,
  rawContent,
  url
}, Symbol.toStringTag, { value: 'Module' }));

const $$Astro = createAstro("https://nadderud.no");
const $$404 = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$404;
  return renderTemplate`${renderComponent($$result, "PageLayout", $$PageLayout, {}, { "default": ($$result2) => renderTemplate`${maybeRenderHead($$result2)}<section class="w-72 m-auto text-center">
        <h1 class="font-extrabold text-4xl">404</h1>
        <p>Beklager vi fant ikke det du lette etter</p>
        <br>
        <a class="link" href="/">Tilbake til forsiden</a>
    </section>` })}`;
}, "/home/martin/Documents/GitHub/mason/src/pages/404.astro");

const $$file = "/home/martin/Documents/GitHub/mason/src/pages/404.astro";
const $$url = "/404";

const _page39 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$404,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

export { _page27 as A, _page28 as B, _page29 as C, _page30 as D, _page31 as E, _page32 as F, _page33 as G, _page34 as H, _page35 as I, _page36 as J, _page37 as K, _page38 as L, _page39 as M, _page0 as _, _page1 as a, _page2 as b, _page3 as c, _page4 as d, _page5 as e, _page6 as f, _page7 as g, _page8 as h, _page9 as i, _page10 as j, _page11 as k, _page12 as l, _page13 as m, _page14 as n, _page15 as o, _page16 as p, _page17 as q, _page18 as r, _page19 as s, _page20 as t, _page21 as u, _page22 as v, _page23 as w, _page24 as x, _page25 as y, _page26 as z };
